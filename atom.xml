<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>——Light!</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://Smlight.github.io/blog/"/>
  <updated>2018-02-26T05:58:25.785Z</updated>
  <id>https://Smlight.github.io/blog/</id>
  
  <author>
    <name>smlight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HHUACM 寒假专题 动态规划</title>
    <link href="https://Smlight.github.io/blog/2018/02/25/hhutraining3/"/>
    <id>https://Smlight.github.io/blog/2018/02/25/hhutraining3/</id>
    <published>2018-02-25T11:40:45.000Z</published>
    <updated>2018-02-26T05:58:25.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="F-数塔"><a href="#F-数塔" class="headerlink" title="F - 数塔"></a><a href="https://vjudge.net/problem/HDU-2084" target="_blank" rel="noopener">F - 数塔</a></h3><p>经典问题，数塔。<br>使用动态规划解决问题的（最重要）前提是：</p><ol><li>问题具有最优子结构</li><li>最优子结构的状态可以记录</li></ol><p><img src="http://acm.hdu.edu.cn/data/images/2084-1.jpg" alt=""><br>例如上图中，以第二层$12$为顶层的数塔就是一个最优子结构。<br>再回到原来的顶层，想得到最终的结果只需要知道第二层两个子结构能得到的最大和，这是可记录的。<br>所以，我们从底层往顶层进行动态规划就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[<span class="number">111</span>][<span class="number">111</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</div><div class="line">                a[i][j]+=max(a[i+<span class="number">1</span>][j],a[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[<span class="number">1</span>][<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="G-免费馅饼"><a href="#G-免费馅饼" class="headerlink" title="G - 免费馅饼"></a><a href="https://vjudge.net/problem/HDU-1176" target="_blank" rel="noopener">G - 免费馅饼</a></h3><p>可以发现时刻的范围不是很大，把每个时刻看作每一层，这个问题就是三条边的数塔。<br>代码中平移一下是为了避免越界问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> dp[N][<span class="number">13</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n) &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> m=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">int</span> x,t;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;t);</div><div class="line">            ++dp[t][x+<span class="number">1</span>];</div><div class="line">            m=max(m,t);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=m;i&gt;=<span class="number">0</span>;i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">11</span>;j++) &#123;</div><div class="line">                dp[i][j]+=max(max(dp[i+<span class="number">1</span>][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j]),dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">0</span>][<span class="number">6</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="A-饭卡"><a href="#A-饭卡" class="headerlink" title="A - 饭卡"></a><a href="https://vjudge.net/problem/HDU-2546" target="_blank" rel="noopener">A - 饭卡</a></h3><p>首先排除余额已经少于$5$的情况，然后分为$m-5$和$5$两部分，前面的$m-5$是个01背包问题，后面的$5$用来买最后一次。若用$dp(x)$表示$x$能买到的最大价值，那么答案为$m-dp(m-5)-a_i (1\le i\le n)$。<br>可以证明，最后买最贵的是最优的。比较复杂，这里仅通过$m-dp(m-5)-a_p$这个式子简要说明，如果最后买的不是最贵的，即 $p’ \neq p$：</p><ul><li>$a_{p’}\le a_{p}$</li><li>背包的物品集合加入了一个体积大的，去掉了一个体积小的；又有价值跟体积的值相等，所以$dp’(m-5)\le dp(m-5)$</li></ul><p>两个减数都减小，最后的结果只会变大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1100</span>;</div><div class="line"><span class="keyword">int</span> a[N],dp[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</div><div class="line">        <span class="keyword">if</span> (m&lt;<span class="number">5</span>) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> p=max_element(a+<span class="number">1</span>,a+n+<span class="number">1</span>)-a;</div><div class="line">            m-=<span class="number">5</span>;</div><div class="line">            <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">                <span class="keyword">if</span> (i==p) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=m;j&gt;=a[i];j--) &#123;</div><div class="line">                    dp[j]=max(dp[j],dp[j-a[i]]+a[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m+<span class="number">5</span>-dp[m]-a[p]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="B-Piggy-Bank"><a href="#B-Piggy-Bank" class="headerlink" title="B - Piggy-Bank"></a><a href="https://vjudge.net/problem/HDU-1114" target="_blank" rel="noopener">B - Piggy-Bank</a></h3><p>已知存钱罐的确切重量，问最小可能价值。是恰好型的完全背包。<br>稍微讲一下完全背包一维的转移方程：<br>$$dp(j)=max(dp(j),dp(j-w_i)+v_i)$$ $j$从小到大枚举时，由于之前的$dp$值已经更新过了，就直接达到了无限个物品的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">10010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</div><div class="line"><span class="keyword">int</span> dp[M];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n,m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">        m-=n;</div><div class="line">        <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</div><div class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">int</span> p,w;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;w);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=w;j&lt;=m;j++) &#123;</div><div class="line">                dp[j]=min(dp[j],dp[j-w]+p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (dp[m]==INF) &#123;</div><div class="line">            <span class="built_in">puts</span>(<span class="string">"This is impossible."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"The minimum amount of money in the piggy-bank is %d.\n"</span>,dp[m]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="C-Investment"><a href="#C-Investment" class="headerlink" title="C - Investment"></a><a href="https://vjudge.net/problem/HDU-1963" target="_blank" rel="noopener">C - Investment</a></h3><p>给出本金、很多种债券和各自的利息，问$y$年以后最多能有多少钱，抽象一下就是做$y$次完全背包。<br>但是这题里面容量太大了做不了完全背包，所以题目里又给了一个条件，债券的价格都是$1000$的整数倍，那么直接把本金除以$1000$当作背包容量就行了，重复做$y$次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> w[<span class="number">22</span>],v[<span class="number">22</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">50000</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> n,M,Y;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;M,&amp;Y);</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w[i],&amp;v[i]);</div><div class="line">            w[i]/=<span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (Y--) &#123;</div><div class="line">            <span class="keyword">int</span> m=M/<span class="number">1000</span>;</div><div class="line">            <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=w[i];j&lt;=m;j++) &#123;</div><div class="line">                    dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            M+=dp[m];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,M);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="D-Common-Subsequence"><a href="#D-Common-Subsequence" class="headerlink" title="D - Common Subsequence"></a><a href="https://vjudge.net/problem/HDU-1159" target="_blank" rel="noopener">D - Common Subsequence</a></h3><p>经典问题，最长公共子序列。<br><img src="http://img.blog.csdn.net/20160529225550069" alt="子串与子序列"><br>设$C(i,j)$为$x_{1\dots i}$和$y_{1\dots j}$的最长公共子序列的长度，那么有：<br>$$\large C(i,j)=\begin{cases}<br>0 &amp; \text{$i=0$ or $j=0$} \\<br>C(i-1,j-1)+1 &amp; i,j\gt 0, x_i=y_j \\<br>max(C(i,j-1),C(i-1,j)) &amp; i,j \gt 0, x_i\neq y_j<br>\end{cases}$$ 第一种情况很好理解。第二种情况就是$x_i$和$y_j$用来匹配了，所以等于了这两个都不用的情况$C(i-1,j-1)$加$1$。第三种情况就是不用$x_i$或者不用$y_j$取一个最大值。<br>其实第三种是最基本的情况，但是由于$max(C(i,j-1),C(i-1,j))$不会比$C(i-1,j-1)+1$更优（为什么？），所以第二种情况中可以不考虑第三种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">char</span> a[<span class="number">1010</span>],b[<span class="number">1010</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a+<span class="number">1</span>,b+<span class="number">1</span>)!=EOF) &#123;</div><div class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</div><div class="line">                <span class="keyword">if</span> (a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="E-Max-Sum"><a href="#E-Max-Sum" class="headerlink" title="E - Max Sum"></a><a href="https://vjudge.net/problem/HDU-1003" target="_blank" rel="noopener">E - Max Sum</a></h3><p>经典问题，最大子列和。（<strong>连续子序列</strong>，相当于子串）<br>状态转移方程也比较简单：<br>$$dp(i)=max(dp(i-1)+a[i],a[i])=max(dp(i-1),0)+a[i]$$ 分别对应两种情况：</p><ol><li>接在上一次序列的后面</li><li>开始一个新的序列</li></ol><p>输出的字典序最小意味着左端点和右端点都要最小。如果先记录右端点再反向计算左端点，那么：</p><ul><li>$dp$值相等时，右端点不被更新</li><li>和相等时，左端点要被更新</li></ul><p>当然也有其它的记录方法，比如利用数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1</span>&lt;&lt;<span class="number">28</span>;</div><div class="line"><span class="keyword">int</span> a[N],f[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n,cas=<span class="number">0</span>;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans=-INF,p,q;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            f[i]=max(f[i<span class="number">-1</span>],<span class="number">0</span>)+a[i];</div><div class="line">            <span class="keyword">if</span> (f[i]&gt;ans) &#123;</div><div class="line">                ans=f[i];</div><div class="line">                q=i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=q;i&gt;=<span class="number">1</span>;i--) &#123;</div><div class="line">            now+=a[i];</div><div class="line">            <span class="keyword">if</span> (now==ans) p=i;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,++cas);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,ans,p,q);</div><div class="line">        <span class="keyword">if</span> (T) <span class="built_in">puts</span>(<span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="H-不要62"><a href="#H-不要62" class="headerlink" title="H - 不要62"></a><a href="https://vjudge.net/problem/HDU-2089" target="_blank" rel="noopener">H - 不要62</a></h3><p>常见$dp$类型：数位$dp$。可以使用数位$dp$的$dfs$型模板，原理自行查阅。<br><em>ps.</em> 这题数据量比较小，可以预处理$O(1)$回答，但是大家还是要好好学习数位$dp$滴。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> D=<span class="number">22</span>;</div><div class="line"><span class="keyword">int</span> dig[D];</div><div class="line">ll f[D][<span class="number">10</span>][<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> fg,<span class="keyword">int</span> limit)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (pos&lt;<span class="number">0</span>) <span class="keyword">return</span> fg==<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!limit&amp;&amp;f[pos][pre][fg]!=<span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> f[pos][pre][fg];</div><div class="line">    &#125;</div><div class="line">    ll res=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last=limit?dig[pos]:<span class="number">9</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=last;i++) &#123;</div><div class="line">        res+=dfs(pos<span class="number">-1</span>,i,fg||(pre==<span class="number">6</span>)&amp;&amp;(i==<span class="number">2</span>)||i==<span class="number">4</span>,limit&amp;&amp;(i==last));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!limit) f[pos][pre][fg]=res;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n) &#123;</div><div class="line">        dig[len++]=n%<span class="number">10</span>;</div><div class="line">        n/=<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(len<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF) &#123;</div><div class="line">        <span class="keyword">if</span> (!n&amp;&amp;!m) <span class="keyword">break</span>;</div><div class="line">        <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve(m)-solve(n<span class="number">-1</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="I-Unidirectional-TSP"><a href="#I-Unidirectional-TSP" class="headerlink" title="I - Unidirectional TSP"></a><a href="https://vjudge.net/problem/HDU-1619" target="_blank" rel="noopener">I - Unidirectional TSP</a></h3><p>常见$dp$类型：网格图$dp$。如果不考虑上下可以穿越，那么转移方程非常简单：<br>$$dp(i,j)=min(dp(i-1,j-1),dp(i,j-1),dp(i+1,j-1))$$ 上下可以穿越时，需要根据$i$的值特殊处理一下，代码里用的是三目表达式。<br>因为题目要求输出路径，所以用$a_i$储存前一列可以转移过来的行号，又因为题目里要求字典序最小，所以先排个序，之后按照顺序更新，并约定<strong>值相等的不能更新</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">28</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N],pre[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dp[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">                <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;i&#125;;</div><div class="line">                a[<span class="number">1</span>]=(i==<span class="number">1</span>)?n:i<span class="number">-1</span>;</div><div class="line">                a[<span class="number">2</span>]=(i==n)?<span class="number">1</span>:i+<span class="number">1</span>;</div><div class="line">                sort(a,a+<span class="number">3</span>);</div><div class="line">                <span class="keyword">int</span> x=INF,y=<span class="number">-1</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++) &#123;</div><div class="line">                    <span class="keyword">if</span> (dp[a[k]][j<span class="number">-1</span>]&lt;x) &#123;</div><div class="line">                        x=dp[y=a[k]][j<span class="number">-1</span>];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                dp[i][j]+=x;</div><div class="line">                pre[i][j]=y;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> x=INF,y=<span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (dp[i][m]&lt;x) &#123;</div><div class="line">                x=dp[y=i][m];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--) &#123;</div><div class="line">            st.push(y);</div><div class="line">            y=pre[y][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">bool</span> fi=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (fi) &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,st.top());</div><div class="line">                fi=<span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,st.top());</div><div class="line">            &#125;</div><div class="line">            st.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="J-DZY-Loves-Sequences"><a href="#J-DZY-Loves-Sequences" class="headerlink" title="J - DZY Loves Sequences"></a><a href="https://vjudge.net/problem/CodeForces-447C" target="_blank" rel="noopener">J - DZY Loves Sequences</a></h3><p>常见类型：扫一遍预处理。分别求出向左和向右最多可以延伸的长度，然后对于每一个$a_i$：</p><ul><li>如果$a_{i-1} + 1 \lt a_{i+1}$，那么$a_i$可以修改为$a_{i-1}$和$a_{i-1}$之间的某个数使得左右两段连接在一起</li><li>如果$a_{i-1} + 1 \ge a_{i+1}$，那么$a_i$只能修改为比$a_{i-1}$大或者比$a_{i-1}$小的数，即左长度加一或者右长度加一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> a[N],l[N],r[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</div><div class="line">    &#125;</div><div class="line">    l[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</div><div class="line">        <span class="keyword">if</span> (a[i<span class="number">-1</span>]&lt;a[i]) l[i]=l[i<span class="number">-1</span>];</div><div class="line">        <span class="keyword">else</span> l[i]=i;</div><div class="line">    &#125;</div><div class="line">    r[n]=n;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i;i--) &#123;</div><div class="line">        <span class="keyword">if</span> (a[i]&lt;a[i+<span class="number">1</span>]) r[i]=r[i+<span class="number">1</span>];</div><div class="line">        <span class="keyword">else</span> r[i]=i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">        l[i]=i-l[i]+<span class="number">1</span>;</div><div class="line">        r[i]=r[i]-i+<span class="number">1</span>;</div><div class="line">        ans=max(ans,max(l[i],r[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">        <span class="keyword">if</span> (a[i<span class="number">-1</span>]+<span class="number">1</span>&lt;a[i+<span class="number">1</span>]) &#123;</div><div class="line">            ans=max(ans,l[i<span class="number">-1</span>]+<span class="number">1</span>+r[i+<span class="number">1</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ans=max(ans,max(l[i<span class="number">-1</span>]+<span class="number">1</span>,r[i+<span class="number">1</span>]+<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;F-数塔&quot;&gt;&lt;a href=&quot;#F-数塔&quot; class=&quot;headerlink&quot; title=&quot;F - 数塔&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-2084&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>CSP超级合集（更新中）</title>
    <link href="https://Smlight.github.io/blog/2018/01/16/CSP%E8%B6%85%E7%BA%A7%E5%90%88%E9%9B%86/"/>
    <id>https://Smlight.github.io/blog/2018/01/16/CSP超级合集/</id>
    <published>2018-01-16T04:28:33.000Z</published>
    <updated>2018-02-05T09:47:21.516Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>听说有些学校能抵机试，准备参加三月份的CSP。<br>仅含题解，代码详见<a href="https://github.com/Smlight/CCFCSP" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="201312-1-出现次数最多的数"><a href="#201312-1-出现次数最多的数" class="headerlink" title="201312-1 出现次数最多的数"></a>201312-1 出现次数最多的数</h3><p>sb-t。计数随便扫一下。</p><h3 id="201312-2-ISBN号码"><a href="#201312-2-ISBN号码" class="headerlink" title="201312-2 ISBN号码"></a>201312-2 ISBN号码</h3><p>sb-t。随便模拟一下。</p><h3 id="201312-3-最大的矩形"><a href="#201312-3-最大的矩形" class="headerlink" title="201312-3 最大的矩形"></a>201312-3 最大的矩形</h3><p>easy mode：枚举左端点，枚举右端点，顺便维护最小值，乘一下更新一下。<br>medium mode：考虑枚举一个点，并使该点就是区间中最低的，那么就是要求向左向右第一个低于当前点的。这件事情可以用单调栈来搞，正反各一遍。</p><h3 id="201312-4-有趣的数"><a href="#201312-4-有趣的数" class="headerlink" title="201312-4 有趣的数"></a>201312-4 有趣的数</h3><p>一眼看上去想搜索，但是仔细一想。。。是个数学题，稍微懵逼了一会儿，还是要慢慢来，列列式子。<br>因为0都在1之前，也就是说最后一个0在第一个1之前，那么它们可以看作一个整体。又因为每个数字至少出线一次，所以第一个一定是0。23同理。<br>设0和1的总位数是$x$，那么首先要在$n$位中选出$x$位，又因为整个串的第一位不能是0，所以应该是$n-1$位，即$C_{n-1}^{x}$。剩下的$n-x$位分给23。然后在这x位中，只要选一个位置断开，前面是0后面是1即可。枚举最末的0，除了不能在最后都可以（必须有1）。23同理。所以答案等于$C_{n-1}^{x} C_{x-1}^{1} C_{n-x-1}^{1}，2 \le x \le n-2$。$n$小于等于1000，阶乘打表或者组合数打表，随便搞搞。</p><h3 id="201312-5-I’m-stuck"><a href="#201312-5-I’m-stuck" class="headerlink" title="201312-5 I’m stuck!"></a>201312-5 I’m stuck!</h3><p>70：我以为$50^4$肯定能过的。。。直接写了个先起点bfs再每个格子bfs的。。。TLE<br>100：可以直接连边在图上和反图上搜。但是不太想重写，所以加了一个反向搜的函数，注意反向的时候判断的是要到的那个格子的连通方向。</p><h3 id="201312-总结"><a href="#201312-总结" class="headerlink" title="201312 总结"></a>201312 总结</h3><p>作为全系列第一场，非常简单，甚至不需要什么算法知识就能ak。</p><h3 id="201403-1-相反数"><a href="#201403-1-相反数" class="headerlink" title="201403-1 相反数"></a>201403-1 相反数</h3><p>不会重复，直接取绝对值找出现两次的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Before&quot;&gt;&lt;a href=&quot;#Before&quot; class=&quot;headerlink&quot; title=&quot;Before&quot;&gt;&lt;/a&gt;Before&lt;/h3&gt;&lt;p&gt;听说有些学校能抵机试，准备参加三月份的CSP。&lt;br&gt;仅含题解，代码详见&lt;a href=&quot;https://g
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>zimpha的bc出题录（部分）</title>
    <link href="https://Smlight.github.io/blog/2017/10/18/zimpha%E7%9A%84bc%E5%87%BA%E9%A2%98%E5%BD%95/"/>
    <id>https://Smlight.github.io/blog/2017/10/18/zimpha的bc出题录/</id>
    <published>2017-10-18T13:46:08.000Z</published>
    <updated>2018-02-12T03:07:58.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A-GCD-is-Funny"><a href="#A-GCD-is-Funny" class="headerlink" title="A - GCD is Funny"></a><a href="https://vjudge.net/problem/HDU-5902" target="_blank" rel="noopener">A - GCD is Funny</a></h3><p>题意：在黑板上写有$n$个数，每次删掉$a,b,c$三个数并把$d$写两遍，$d$可以是$(a,b),(a,c),(b,c)$。在$n-2$次操作后会留下两个相同的数，输出这个数的所有可能情况。<br>题解：给跪了。。。其实是所有大小超过$1$的子集的$gcd$的集合。。。</p><p>注意点：<strong>值域限制</strong>，说是子集当然不可能直接按子集做，而是利用值域很小这一点标记着做；<strong>gcd下降速度</strong>，两个不一样的数取$gcd$，最大也只能是大数的一半，即<strong>对数级别次</strong>就可以到$1$。</p><h3 id="B-Square-Distance"><a href="#B-Square-Distance" class="headerlink" title="B - Square Distance"></a><a href="https://vjudge.net/problem/HDU-5903" target="_blank" rel="noopener">B - Square Distance</a></h3><p>题意：给一个串$s$，长度为$n$(保证偶数)，输出一个串$t$，要满足：$t$由两个相同的串拼接而成；$s$到$t$的汉明距离恰好为$m$；$t$是所有满足条件的串中字典序最小的。$s,t$均只含小写字母，若$t$不存在输出<code>Impossible</code>。<br>题解：后半段放到前半段综合考虑，用dp可以求出前$i$个字符产生$j$个距离可不可行。因为要输出字典序最小，所以最终的贪心一定是从前往后从小往大，若是直接在这种dp上贪心，会导致最后的距离不一定是$m$。所以这里需要倒着dp，即从第$\frac{n}{2}$个到第$i$个字符产生$j$个距离可不可行。</p><p>注意点：看着很像贪心但是没有具体策略的时候一定要<strong>想一想dp</strong>！不一定只贪心或者只dp，也不一定是用贪心优化dp，像这题就是<strong>在dp得到的表上进行贪心</strong>。</p><h3 id="C-LCIS"><a href="#C-LCIS" class="headerlink" title="C - LCIS"></a><a href="https://vjudge.net/problem/HDU-5904" target="_blank" rel="noopener">C - LCIS</a></h3><p>题意：给出$n$个数的序列$a$和$m$个数的序列$b$，问公共的上升的并且数值连续的子序列的最长长度。<br>题解：对$a$扫一遍得到以$x$结尾的连续值上升子序列的最长长度，同样地对$b$扫一遍，最后枚举结尾是什么数字，取两个结果的较小值更新答案。</p><p>注意点：当对子序列的限制非常强时，很有可能可以<strong>每个序列分开做</strong>，最后再合并到答案。</p><h3 id="D-Black-White-Tree"><a href="#D-Black-White-Tree" class="headerlink" title="D - Black White Tree"></a><a href="https://vjudge.net/problem/HDU-5905" target="_blank" rel="noopener">D - Black White Tree</a></h3><p>题意：$n$个节点的无根树$T$，每个节点是黑色或者白色，求$W = \displaystyle\sum_{a=0}^{n}\sum_{b=0}^{n}{(a+1)(b+1)S(a,b)}$，其中$S(a,b)=1$表示存在一个子树恰好由$a$个白色节点和$b$个黑色节点构成，$S(a,b)=0$表示不存在。$T$的一个子树定义为$T$的一个子图并且是树。<br>题解：对于确定大小的子树，如果可以知道最少以及最多有几个黑色节点，那么答案直接两重循环加一个判断就可以算出来了。所以我们可以进行树形dp求出这个最少和最多。先规定$1$作为根，那么题意中的子树就是规定根以后的连通块，用$f[u][i],g[u][i]$分别表示以$u$为根，大小为$i$时最少和最多的黑色节点数，用$F[i],G[i]$表示连通块大小为$i$时最少和最多的黑色节点数。这个转移直接借助代码来说还更好一点。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void dfs(int u,int fa)</div><div class="line">&#123;</div><div class="line">    sz[u]=<span class="number">1</span>;</div><div class="line">    f[u][<span class="number">1</span>]=g[u][<span class="number">1</span>]=s[u]-<span class="string">'0'</span>;</div><div class="line">    for (int v:eg[u]) &#123;</div><div class="line">        if (v==fa) continue;</div><div class="line">        dfs(v,u);</div><div class="line">        for (int i=sz[u];i&gt;=<span class="number">1</span>;i--) &#123;</div><div class="line">            for (int j=<span class="number">1</span>;j&lt;=sz[v];j++) &#123;</div><div class="line">                f[u][i+j]=min(f[u][i+j],f[u][i]+f[v][j]);</div><div class="line">                g[u][i+j]=max(g[u][i+j],g[u][i]+g[v][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        sz[u]+=sz[v];</div><div class="line">    &#125;</div><div class="line">    for (int i=<span class="number">1</span>;i&lt;=sz[u];i++) &#123;</div><div class="line">        <span class="symbol">F</span>[i]=min(<span class="symbol">F</span>[i],f[u][i]);</div><div class="line">        <span class="symbol">G</span>[i]=max(<span class="symbol">G</span>[i],g[u][i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每个节点被访问深度次，所以最终的复杂度是$O(n^2)$。</p><p>注意点：<strong>无根树的子树</strong>等价于确定一个根以后的<strong>连通块</strong>。</p><h3 id="F-Aaronson"><a href="#F-Aaronson" class="headerlink" title="F - Aaronson"></a><a href="https://vjudge.net/problem/HDU-5747" target="_blank" rel="noopener">F - Aaronson</a></h3><p>题意：$x_{0}+2x_{1}+4x_{2}+…+2^{m}x_{m}=n$的解是$(x_0,x_1,x_2,…,x_m)$，$x_i \ge 0$，求$\displaystyle\sum_{i=0}^{m} x_i$的最小值，$(0 \le n,m \le 10^9)$。<br>题解：若$m$比较小，特殊处理一下$x_m$，剩下的以及其他的情况都是二进制表示的$1$的个数。</p><h3 id="G-Bellovin"><a href="#G-Bellovin" class="headerlink" title="G - Bellovin"></a><a href="https://vjudge.net/problem/HDU-5748" target="_blank" rel="noopener">G - Bellovin</a></h3><p>题意：长度为$n$的$a$序列，求一个长度也为$n$的$b$序列满足，$a$中以$a_i$结尾的$LIS$长度和$b$中以$b_i$结尾的$LIS$长度相等$(1\le i \le n)$，$b$的字典序最小。<br>题解：因为$b_i$最小是$1$，直接把$a$中以$a_i$结尾的$LIS$长度当作$b_i$即可。</p><h3 id="H-Colmerauer"><a href="#H-Colmerauer" class="headerlink" title="H - Colmerauer"></a><a href="https://vjudge.net/problem/HDU-5749" target="_blank" rel="noopener">H - Colmerauer</a></h3><p>题意：一个矩阵的权值定义为其所含的所有鞍点的值的和，若一个点在列上是唯一最大值，在行上是唯一最小值，则其为鞍点。又在矩阵$M$上定义$S(a,b)$，表示所有大小为$a$行$b$列的子矩阵的权值和。现给出矩阵$M$，求$W = (\displaystyle\sum_{a=1}^{n}\sum_{b=1}^{m}{a \cdot b \cdot S(a,b)}) \text{ mod } 2^{32}$。<br>题解：很容易想到单点贡献。对于矩阵中的每一个点，我们暴力出（或者用单调栈优化一下）它能往上下左右延伸的长度，然后直接贡献即可。</p><p>注意点：左右长度的算式没有理清楚，应该<strong>写出原始的公式再进行化简</strong>。</p><h3 id="I-Dertouzos"><a href="#I-Dertouzos" class="headerlink" title="I - Dertouzos"></a><a href="https://vjudge.net/problem/HDU-5750" target="_blank" rel="noopener">I - Dertouzos</a></h3><p>题意：$n$的真因子是不为$n$的因子。给出$n$和$d$，问有多少小于$n$的数的最大真因子是$d$。<br>题解：即$pd=m&lt;n$，显然有</p><ol><li>$p \le \frac{n-1}{d}$；</li><li>$p$必须为质数；【如若不然，则$p$有真因子$q$，$qd$是比$d$更大的$m$的真因子。 </li><li>$p \le c$，其中$c$为$d$的最小质因子。【如若不然，则$\frac{d}{c}\times p$是比$d$更大的$m$的真因子。</li></ol><p>由2，我们先做一遍筛法以及前缀和。再算出1的界，最后用筛出来的质数去算3的界。</p><p>注意点：用筛出来的质数去算3的界会有$O(\sqrt{d})$的复杂度，当$d$很大($\approx 10^{9}$)时会超时，而此时1的界必然比较小，应该<strong>在超过已有的界时及时退出</strong>。</p><h3 id="J-Eades"><a href="#J-Eades" class="headerlink" title="J - Eades"></a><a href="https://vjudge.net/problem/HDU-5751" target="_blank" rel="noopener">J - Eades</a></h3><p>题意：长度为$n$的$a$序列，定义$g(l,r)$为$a_l$到$a_r$的最大值，定义$f(l,r)=\displaystyle\sum_{i=l}^{r}[a_i = g(l,r)]$。求对于所有$1\le k \le n$的$k$分别有多少对$(l,r)$满足$f(l,r)=k$。<br>题解：如果$a_i$要对$f$函数有贡献的话必须是这个区间内最大的，所以首先用单调栈求出往左以及往右第一个大于$a_i$的位置。那么在$L+1…R-1$中，$a_i$这个值将区间分为若干段，朴素的想法是直接枚举左端点和右端点在哪一段上然后累加到答案，但是这样还是$O(n^2)$的<del>【其实处理得好能卡过</del>，不过进一步可以发现具体贡献到哪一个答案其实只跟$j-i$(两个段编号的差)有关，那么把其中一个反过来就是一个卷积形式，可以套一个$fft$。</p><p>注意点：具体细节较多，<strong>想不清楚时一定要耐心&amp;动手模拟一下</strong>。</p><h3 id="K-LCP-Array"><a href="#K-LCP-Array" class="headerlink" title="K - LCP Array"></a><a href="https://vjudge.net/problem/HDU-5635" target="_blank" rel="noopener">K - LCP Array</a></h3><p>题意：$s$是一个$1base$的字符串，记$a_i=lcp(ssuff_i,suff_{i+1})$，$(1 \le i &lt; n)$。现给出$a$序列，问有多少只含小写字母的字符串$s$满足这个序列。<br>题解：若$a_i$不为$0$，那么$s_i…s_{i+a_{i}}$这些字符必须全都相同(手动模拟一下)，由此推出从后往前：$a_i$不为$0$则必须连续地增加，若不满足答案为$0$；$a_i$为$0$则将答案乘上25。</p><h3 id="L-Shortest-Path"><a href="#L-Shortest-Path" class="headerlink" title="L - Shortest Path"></a><a href="https://vjudge.net/problem/HDU-5636" target="_blank" rel="noopener">L - Shortest Path</a></h3><p>题意：$n$个点的无向图，原来在$i$和$i+1$之间有边，现在添加3条边，所有边的权值都是$1$，每次询问$u$到$v$的最短路是多少。<br>题解：实际上就是改变了6个点(或者不到6个)之间的距离，直接Floyd。询问的时候直接暴力枚举穿过哪两个点。</p><p>注意点：不要忘记跟初始的距离取$min$。</p><h3 id="M-Transform"><a href="#M-Transform" class="headerlink" title="M - Transform"></a><a href="https://vjudge.net/problem/HDU-5637" target="_blank" rel="noopener">M - Transform</a></h3><p>题意：给出$n$个数，可以对整数$x$进行两种操作，</p><ol><li>翻转$x$的一个bit；</li><li>$x \leftarrow x\ xor\ a_i$ 。</li></ol><p>每次询问把$S$变成$T$最少需要几步。<br>题解：两个操作都可以归结为$xor$，所以从$S$走到$T$跟从$0$走到$S\ xor\ T$是等价的。直接以$0$为起点按两种操作进行$bfs$，$O(1)$回答。</p><p>注意点：<strong>状态数trick</strong>，虽然每次有几十条边，但是最后询问的范围只有$10^5$左右，最多也就是$0$到$(2^{17}-1)$每个点都走一遍。</p><h3 id="N-Toposort"><a href="#N-Toposort" class="headerlink" title="N - Toposort"></a><a href="https://vjudge.net/problem/HDU-5638" target="_blank" rel="noopener">N - Toposort</a></h3><p>题意：有向无环图有$n$个点$m$条边，问恰好删除$k$条边可以做到的字典序最小的拓扑序。<br>题解：考虑字典序最小，首先$1$号点放在第一绝对比放在第二好，那么：如果$1$号点当前的入度$d_1$小于等于$k$，直接将这$d_1$条边全部删除即可；如果大于，再测试$2$号点、$3$号点……。用优先队列保证每次取出的是最小编号的点，每条边访问一次，每个点最多入队$n$次，复杂度感觉上是$O((n+m)log{n})$。</p><p>注意点：<strong>对字典序和贪心的理解不够深刻</strong>。</p><h3 id="O-Deletion"><a href="#O-Deletion" class="headerlink" title="O - Deletion"></a><a href="https://vjudge.net/problem/HDU-5639" target="_blank" rel="noopener">O - Deletion</a></h3><p>题意：无向图$G$有$n$个点$m$条边，每次可以删除一个边集，要求这个边集组成的导出子图的每个连通分量最多只有一个环。问最少几次可以把图$G$完全删除。<br>题解：对于一个连通分量，若至多一个环，那它就是一个广义的环加外向树（可以没有环或者没有树）。环加树又可以理解为每个点最多一个出度，再反推回去，若有答案为$k$，那么等价于给图$G$中的每条边定向，使得所有点的出度均不超过$k$。考虑到一条边$(u,v)$，要么在$u$是出度要么在$v$是出度，新建一个点$x_{uv}$表示原图中的这条边，那么它要么与$u$匹配要么与$v$匹配。在这个新图中，左边的点(原图的点)最多匹配$k$次，右边的点(原图的边)最多匹配$1$次，且当右边的点完全匹配时$k$是一个可行的答案，可以二分答案每次判断最大流是不是等于$m$。xg最后提到其实二分可以不要，因为右边的点到汇的容量始终是$1$，每次改改增广路啥的。<del>【然而这种操作本菜鸡就没必要学了吧。。。</del></p><p>注意点：环、树、环加树的<strong>点数边数</strong>以及<strong>度数</strong>都有特殊的结论。</p><h3 id="P-Card-Game"><a href="#P-Card-Game" class="headerlink" title="P - Card Game"></a><a href="https://cn.vjudge.net/problem/HDU-5494" target="_blank" rel="noopener">P - Card Game</a></h3><p>题意：Soda 和 Beta 各有$n$张牌，两人随机抽$m$张牌，用它们的和比大小，问 Soda 能不能稳赢。<br>题解：取 Soda 最小的$m$张跟 Beta 最大的$m$张，它们的和比一下大小。</p><h3 id="Q-LCS"><a href="#Q-LCS" class="headerlink" title="Q - LCS"></a><a href="https://cn.vjudge.net/problem/HDU-5495" target="_blank" rel="noopener">Q - LCS</a></h3><p>题意：有两个排列${a_1, a_2, …, a_n}$，${b_1, b_2, …, b_n}$，要找到另一个排列${p_1, p_2, …, p_n}$，使得${a_{p_1},a_{p_2},…,a_{p_n}}$和${b_{p_1},b_{p_2},…,b_{p_n}}$的$LCS$最长，输出$LCS$长度的最大值。<br>题解：$b$是$a$的置换，长度为$l$的环能产生$l-1$的$LCS$。</p><p>注意点：特判环长度为1。</p><h3 id="R-Beauty-of-Sequence"><a href="#R-Beauty-of-Sequence" class="headerlink" title="R - Beauty of Sequence"></a><a href="https://vjudge.net/problem/HDU-5496" target="_blank" rel="noopener">R - Beauty of Sequence</a></h3><p>题意：定义魅力值为一个序列去除序列中连续重复元素(每一段只保留一个)后的序列的和。给出$n$个数的序列$a$，求$a$的所有子序列的魅力值之和。<br>题解：考虑单点贡献，并且出现连续相同值时只有最左边的要贡献。那么对于$a_i$，只要之前的子序列不以$a_i$结尾就可以贡献，累加答案以后更新一下以$a_i$结尾的子序列的数量即可。</p><p>注意点：不用考虑本质不同。</p><h3 id="U-Souvenir"><a href="#U-Souvenir" class="headerlink" title="U - Souvenir"></a><a href="https://vjudge.net/problem/HDU-5310" target="_blank" rel="noopener">U - Souvenir</a></h3><p>题意：$p$块钱可以买1个纪念品，$q$块钱可以买纪念品套装，内含$m$个纪念品，问要给$n$个人各发一个纪念品至少要多少钱。<br>题解：只有三种情况，只用$p$，只用$q$，用$q$直到剩下不到$m$的用$p$。</p><p>注意点：显然是可以多买的。</p><h3 id="W-Sequence"><a href="#W-Sequence" class="headerlink" title="W - Sequence"></a><a href="https://vjudge.net/problem/HDU-5312" target="_blank" rel="noopener">W - Sequence</a></h3><p>题意：一个数列的第$n(n \ge 1)$项为$3n(n-1)+1$，给出一个数$m$，问至少几个数的和能恰好等于$m$。如，$22 = 19 + 1 + 1 + 1 = 7 + 7 + 7 + 1$。若不能，输出$-1$。<br>题解：联想到三角形数$a_{n}=\frac{1}{2}n(n-1)$，至多3个三角形数可以表示任意自然数。而$3n(n-1)+1=6a_{n}+1$，那么$m\equiv ans \mod 6$。特判一下$ans$等于$1$或$2$，否则就是$3\dots 8$中与$m$同余的数。</p><p>注意点：<strong>特判也需要考虑复杂度</strong>！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;A-GCD-is-Funny&quot;&gt;&lt;a href=&quot;#A-GCD-is-Funny&quot; class=&quot;headerlink&quot; title=&quot;A - GCD is Funny&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-59
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017ICPC乌鲁木齐网络赛 全题解</title>
    <link href="https://Smlight.github.io/blog/2017/09/25/2017urumqi_online/"/>
    <id>https://Smlight.github.io/blog/2017/09/25/2017urumqi_online/</id>
    <published>2017-09-25T03:26:37.000Z</published>
    <updated>2018-02-09T13:19:33.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/09/09/icpc_urumqi" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="A-Banana"><a href="#A-Banana" class="headerlink" title="A. Banana"></a>A. Banana</h3><p>直接暴力。</p><h3 id="B-Out-out-control-cars"><a href="#B-Out-out-control-cars" class="headerlink" title="B. Out-out-control cars"></a>B. Out-out-control cars</h3><p>可以看作相对运动，然后三条射线跟三条线段判相交。<br>要注意的是大三角形的射线不碰到小三角形也可以yes，这个我们可以通过两个都判一遍来解决。<br>还有一种情况（数据里好像没有）是两者相对静止并且一个套一个，按照题意也是yes。</p><h3 id="C-Coconut"><a href="#C-Coconut" class="headerlink" title="C. Coconut"></a>C. Coconut</h3><p>直接模拟。</p><h3 id="D-Hack-Portals"><a href="#D-Hack-Portals" class="headerlink" title="D. Hack Portals"></a>D. Hack Portals</h3><p>poj原题。<del>没做过，所以比赛的时候也没做</del><br>按照坐标排序后，有一个贪心的结论：i到j这一段区间中，最优情况下最后一个做的不是i就是j。<br>考虑区间dp，我们用dp[i][j][0]表示i到j这一段最后做i的最小花费，dp[i][j][1]表示i到j这一段最后做j的最小花费。<br>转移还是挺容易的，转移了以后还要再考虑一下开放的时间。</p><h3 id="E-Half-consecutive-Numbers"><a href="#E-Half-consecutive-Numbers" class="headerlink" title="E. Half-consecutive Numbers"></a>E. Half-consecutive Numbers</h3><p>打表。<del>反正我们队只会打表了</del><br><img src="http://img.blog.csdn.net/20170928164144650" alt="q巨题解"></p><h3 id="F-Islands"><a href="#F-Islands" class="headerlink" title="F. Islands"></a>F. Islands</h3><p>hdu原题。<br>缩点以后看出度为0的点数和入度为0的点数，答案为较大值。注意特判只有1个scc。</p><h3 id="G-Query-on-a-string"><a href="#G-Query-on-a-string" class="headerlink" title="G. Query on a string"></a>G. Query on a string</h3><p>因为模式串的长度很短，小于等于10，所以修改一个字符最多只会影响主串中10个位置的匹配情况。那么操作可以转化为10次单点修改和区间求和，用一个树状数组维护就可以了。有影响的那个部分可以用kmp匹配一下。</p><h3 id="H-Skiing"><a href="#H-Skiing" class="headerlink" title="H. Skiing"></a>H. Skiing</h3><p>队友一下子就读懂了，加个源跑最长路就行。</p><h3 id="I-Colored-Graph"><a href="#I-Colored-Graph" class="headerlink" title="I. Colored Graph"></a>I. Colored Graph</h3><p>比赛的时候直接抄的论文。<del>还抄错了好多次</del><br>回忆同色三角形的计数过程，其实是算了异色三角形的个数$S$，$S=\frac{1}{2}\sum_{i=1}^{V}{a_{i}(V-1-a_{i})}$ 。<br>现要使得同色三角形个数尽量小，那么就要使每个点的${a_{i}(V-1-a_{i})}$尽量大。<br>由于和一定，两项自然是越接近结果越大。考虑把点集分为两个，每个集合内部的边都是白色，两个集合之间的都是黑色。<br>若$V$是偶数，那么每个点的值都是一模一样的，不用调整。<br>下面重点讨论$V$是奇数的情况，记$n=\lfloor \frac{V}{2} \rfloor$，则两个点集$V1$，$V2$的大小分别为$n$，$n+1$。<br>在$V1$中，每个点有$n+1$条黑边和$n-1$条白边，这一定是可以更优的。<br>首先把黑边分散地改成白边，即把在$i$和$n+i$之间的黑边改成白边，此时$V1$的点会很平衡，不过$V2$中有$n$个点变成了$n-1$条黑边和$n+1$条白边。<br>所以还能更优，当然这时不能再改$n$条边了，要不然就会没完了。将$V2$修改过的$n$个点分成$\frac{n}{2}$组点对，各点对中的白边改成黑边，那么这$n$个点有$n$条黑边和$n$条白边，非常恰好。如果$n$也是奇数，那么就不能这么恰好了，但是大体是一样的，见代码。</p><h3 id="J-Our-Journey-of-Dalian-Ends"><a href="#J-Our-Journey-of-Dalian-Ends" class="headerlink" title="J. Our Journey of Dalian Ends"></a>J. Our Journey of Dalian Ends</h3><p>hdu原题。<br>中转站为源做一遍最小费用流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>后缀自动机·基本概念</title>
    <link href="https://Smlight.github.io/blog/2017/08/27/SAM/"/>
    <id>https://Smlight.github.io/blog/2017/08/27/SAM/</id>
    <published>2017-08-27T01:30:33.000Z</published>
    <updated>2018-02-22T10:41:24.046Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color: red">以下全文转载自<a href="http://hihocoder.com/problemset/problem/1441" target="_blank" rel="noopener">hihocoder</a></span>，今天看了一遍突然就懂了，难道我以前看的都是假文章？<br>小Hi：今天我们来学习一个强大的字符串处理工具：后缀自动机（Suffix Automaton，简称SAM）。<strong>对于一个字符串S，它对应的后缀自动机是一个最小的确定有限状态自动机（DFA），接受且只接受S的后缀。</strong></p><p>小Hi：比如对于字符串S=”aabbabd”，它的后缀自动机是：<br><img src="http://media.hihocoder.com/problem_images/20161203/14807564643248.png" alt=""><br>其中红色状态是终结状态。你可以发现对于S的后缀，我们都可以从S出发沿着字符标示的路径（蓝色实线）转移，最终到达终结状态。例如”bd”对应的路径是S59，”abd”对应的路径是S189，”abbabd”对应的路径是S184679。而对于不是S后缀的字符串，你会发现从S出发，最后会到达非终结状态或者“无路可走”。<strong>特别的，对于S的子串，最终会到达一个合法状态。</strong>例如”abba”路径是S1846，”bbab”路径是S5467。<strong>而对于其他不是S子串的字符串，最终会“无路可走”。</strong>例如”aba”对应S18X，”aaba”对应S123X。（X表示没有转移匹配该字符）</p><p>小Ho：好像很厉害的样子！对于任意字符串都能构造出一个SAM吗？另外图中那些绿色虚线是什么？</p><p>小Hi：是的，任意字符串都能构造出一个SAM。我们知道SAM本质上是一个DFA，DFA可以用一个五元组<strong>&lt;字符集，状态集，转移函数、起始状态、终结状态集&gt;</strong>来表示。下面我们将依次介绍对于一个给定的字符串S如何确定它对应的<strong>状态集</strong>和<strong>转移函数</strong>。至于那些绿色虚线虽然不是DFA的一部分，却是SAM的重要部分，有了这些链接SAM是如虎添翼，我们后面再细讲。</p><h2 id="SAM的States"><a href="#SAM的States" class="headerlink" title="SAM的States"></a>SAM的States</h2><p>小Hi：这一节我们将介绍给定一个字符串S，如何确定S对应的SAM有哪些状态。首先我们先介绍一个概念<strong>子串的结束位置集合</strong>endpos。对于S的一个子串s，endpos(s) = s在S中所有出现的结束位置集合。还是以S=”aabbabd”为例，endpos(“ab”) = {3, 6}，因为”ab”一共出现了2次，结束位置分别是3和6。同理endpos(“a”) = {1, 2, 5}, endpos(“abba”) = {5}。</p><p>小Hi：我们把S的所有子串的endpos都求出来。如果两个子串的endpos相等，就把这两个子串归为一类。最终这些endpos的等价类就构成的SAM的状态集合。例如对于S=”aabbabd”：</p><table><thead><tr><th>状态</th><th>子串</th><th>endpos</th></tr></thead><tbody><tr><td>S</td><td>空串</td><td>{0,1,2,3,4,5,6}</td></tr><tr><td>1</td><td>a</td><td>{1,2,5}</td></tr><tr><td>2</td><td>aa</td><td>{2}</td></tr><tr><td>3</td><td>aab</td><td>{3}</td></tr><tr><td>4</td><td>aabb,abb,bb</td><td>{4}</td></tr><tr><td>5</td><td>b</td><td>{3,4,6}</td></tr><tr><td>6</td><td>aabba,abba,bba,ba</td><td>{5}</td></tr><tr><td>7</td><td>aabbab,abbab,bbab,bab</td><td>{6}</td></tr><tr><td>8</td><td>ab</td><td>{3,6}</td></tr><tr><td>9</td><td>aabbabd,abbabd,bbabd,babd,abd,bd,d</td><td>{7}</td></tr></tbody></table><p>小Ho：这些状态恰好就是上面SAM图中的状态。</p><p>小Hi：没错。此外，这些状态还有一些美妙的性质，且等我一一道来。首先对于S的两个子串s1和s2，不妨设length(s1) &lt;= length(s2)，那么<strong>s1是s2的后缀当且仅当endpos(s1) ⊇ endpos(s2)，s1不是s2的后缀当且仅当endpos(s1) ∩ endpos(s2) = ∅。</strong></p><p>小Ho：我验证一下啊… 比如”ab”是”aabbab”的后缀，而endpos(“ab”)={3,6}，endpos(“aabbab”)={6}，是成立的。”b”是”ab”的后缀，endpos(“b”)={3,4,6}, endpos(“ab”)={3,6}也是成立的。”ab”不是”abb”的后缀，endpos(“ab”)={3,6}，endpos(“abb”)={4}，两者没有交集也是成立的。怎么证明呢？</p><p>小Hi：证明还是比较直观的。首先证明<strong>s1是s2的后缀=&gt;endpos(s1) ⊇ endpos(s2)</strong>：既然s1是s2后缀，所以每次s2出现时s1以必然伴随出现，所以有endpos(s1) ⊇ endpos(s2)。再证明<strong>endpos(s1) ⊇ endpos(s2)=&gt;s1是s2的后缀</strong>：我们知道对于S的子串s2，endpos(s2)不会是空集，所以endpos(s1) ⊇ endpos(s2)=&gt;存在结束位置x使得s1结束于x，并且s2也结束于x，又length(s1) &lt;= length(s2)，所以s1是s2的后缀。综上我们可知<strong>s1是s2的后缀当且仅当endpos(s1) ⊇ endpos(s2)。s1不是s2的后缀当且仅当endpos(s1) ∩ endpos(s2) = ∅</strong>是一个简单的推论，不再赘述。</p><p>小Ho：我好像对SAM的状态有一些认识了！我刚才看上面的表格就觉得SAM的一个状态里包含的子串好像有规律。考虑到SAM中的一个状态包含的子串都具有相同的endpos，那它们应该都互为后缀？</p><p>小Hi：你观察力还挺敏锐的。下面我们就来讲讲一个状态包含的子串究竟有什么关系。上文提到我们把S的所有子串按endpos分类，每一类就代表一个状态，所以我们可以认为一个状态包含了若干个子串。我们用substrings(st)表示状态st中包含的所有子串的集合，longest(st)表示st包含的最长的子串，shortest(st)表示st包含的最短的子串。例如对于状态7，substring(7)={aabbab,abbab,bbab,bab}，longest(7)=aabbab，shortest(7)=bab。</p><p>小Hi：<strong>对于一个状态st，以及任意s∈substrings(st)，都有s是longest(st)的后缀。</strong>证明比较容易，因为endpos(s)=endpos(longest(st))，所以endpos(s) ⊇ endpos(longest(st))，根据我们刚才证明的结论有s是longest(st)的后缀。</p><p>小Hi：此外，<strong>对于一个状态st，以及任意的longest(st)的后缀s，如果s的长度满足：length(shortest(st)) &lt;= length(s) &lt;= length(longsest(st))，那么s∈substrings(st)。</strong>证明也是比较容易，因为：length(shortest(st)) &lt;= length(s) &lt;= length(longsest(st))，所以endpos(shortest(st)) ⊇ endpos(s) ⊇ endpos(longest(st))， 又endpos(shortest(st)) = endpos(longest(st))，所以endpos(shortest(st)) = endpos(s) = endpos(longest(st))，所以s∈substrings(st)。</p><p>小Ho：这么说来，substrings(st)包含的是longest(st)的一系列<strong>连续</strong>后缀？</p><p>小Hi：没错。比如你看状态7中包含的就是aabbab的长度分别是6，5，4，3的后缀；状态6包含的是aabba的长度分别是5，4，3，2的后缀。</p><h2 id="SAM的Suffix-Links"><a href="#SAM的Suffix-Links" class="headerlink" title="SAM的Suffix Links"></a>SAM的Suffix Links</h2><p>小Hi：前面我们讲到substrings(st)包含的是longest(st)的一系列<strong>连续</strong>后缀。这连续的后缀在某个地方会“断掉”。比如状态7，包含的子串依次是aabbab,abbab,bbab,bab。按照连续的规律下一个子串应该是”ab”，但是”ab”没在状态7里，你能想到这是为什么么？</p><p>小Ho：aabbab,abbab,bbab,bab的endpos都是{6}，下一个”ab”当然也在结束位置6出现过，但是”ab”还在结束位置3出现过，所以”ab”比aabbab,abbab,bbab,bab出现次数更多，于是就被分配到一个新的状态中了。</p><p>小Hi：没错，当longest(st)的某个后缀s在新的位置出现时，就会“断掉”，s会属于新的状态。比如上例中”ab”就属于状态8，endpos(“ab”}={3,6}。当我们进一步考虑”ab”的下一个后缀”b”时，也会遇到相同的情况：”b”还在新的位置4出现过，所以endpos(“b”)={3,4,6}，b属于状态5。在接下去处理”b”的后缀我们会遇到空串，endpos(“”)={0,1,2,3,4,5,6}，状态是起始状态S。</p><p>小Hi：于是我们可以发现一条状态序列：7-&gt;8-&gt;5-&gt;S。这个序列的意义是longest(7)即aabbab的后缀依次在状态7、8、5、S中。我们用Suffix Link这一串状态链接起来，这条link就是上图中的绿色虚线。</p><p>小Ho：原来如此。</p><p>小Hi：Suffix Links后面会有妙用，我们暂且按下不表。</p><h2 id="SAM的Transition-Function"><a href="#SAM的Transition-Function" class="headerlink" title="SAM的Transition Function"></a>SAM的Transition Function</h2><p>小Hi：最后我们来介绍SAM的转移函数。对于一个状态st，我们首先找到从它开始下一个遇到的字符可能是哪些。我们将st遇到的下一个字符集合记作next(st)，有next(st) = {S[i+1] | i ∈ endpos(st)}。例如next(S)={S[1], S[2], S[3], S[4], S[5], S[6], S[7]}={a, b, d}，next(8)={S[4], S[7]}={b, d}。</p><p>小Hi：对于一个状态st来说和一个next(st)中的字符c，你会发现substrings(st)中的所有子串后面接上一个字符c之后，新的子串仍然都属于同一个状态。比如对于状态4，next(4)={a}，aabb,abb,bb后面接上字符a得到aabba，abba，bba，这些子串都属于状态6。</p><p>小Hi：所以我们对于一个状态st和一个字符c∈next(st)，可以定义转移函数trans(st, c) = x | longest(st) + c ∈ substrings(x) 。换句话说，我们在longest(st)（随便哪个子串都会得到相同的结果）后面接上一个字符c得到一个新的子串s，找到包含s的状态x，那么trans(st, c)就等于x。</p><p>小Ho：吼~ 终于把SAM中各个部分搞明白了。</p><p>小Hi：SAM的构造有时空复杂度均为O(length(S))的算法，我们将在后面介绍。这一期你可以先用暴力算法依照定义构造SAM，先对SAM有个直观认识再说。</p><p>小Ho：没问题，暴力算法我最拿手了。我先写程序去了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span style=&quot;color: red&quot;&gt;以下全文转载自&lt;a href=&quot;http://hihocoder.com/problemset/problem/1441&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hihocoder&lt;/a&gt;&lt;/span
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训9 部分题解</title>
    <link href="https://Smlight.github.io/blog/2017/08/23/2017multi9/"/>
    <id>https://Smlight.github.io/blog/2017/08/23/2017multi9/</id>
    <published>2017-08-23T11:24:15.000Z</published>
    <updated>2018-02-21T13:08:54.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/08/22/2017%E5%A4%9A%E6%A0%A19" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1002-Ch’s-gift"><a href="#1002-Ch’s-gift" class="headerlink" title="1002.    Ch’s gift"></a>1002.    Ch’s gift</h3><p>首先考虑序列上的问题。</p><p>$a$ 是一个二维数组，如果第 $i$ 位置的值为 $j$，就在 $a_{i,j}$上加上 $j$ 。那么某个询问 $x,y,a,b$ 的答案就是子矩阵的和。如果一开始就把二维前缀和算出来的话就可以回答$O(1)$，答案等于 $(Sum(y,b)-Sum(y,a-1))-(Sum(x,b)-Sum(x,a-1))$ 。</p><p>考虑到 $a,b$ 的范围非常大，可以把所有询问离散化。当然就算离散化，预处理二维前缀和还是不行的，我们发现前缀和相当于把 $[a,b]$ 拆成 $[1,b]-[1,a-1]$，联想到扫描线，把 $a,b$ 这一维的每个区间拆成两条线，用扫描线从小到大扫这一维，$x,y$ 这一维直接预处理一下前缀和每次 $O(1)$ 查就行了。</p><p>再搬到树上，直接套一个树链剖分就行了，树状数组就能维护。</p><p>ps: 可持久化线段树可以在线回答，等写出来了更新</p><h3 id="1005-FFF-at-Valentine"><a href="#1005-FFF-at-Valentine" class="headerlink" title="1005.    FFF at Valentine"></a>1005.    FFF at Valentine</h3><p>强连通缩点加拓扑序判分叉，不多说了。</p><h3 id="1006-Senior-Pan"><a href="#1006-Senior-Pan" class="headerlink" title="1006.    Senior Pan"></a>1006.    Senior Pan</h3><p>这题主要是题意有点不清楚。。。大小为 $k$ 的端点集合，题目的意思是起点终点不能是同一个【不过也是有道理的。。。</p><p>拆点，加超级源超级汇，再跑一下dij 。这个限制可以每个点维护一下被谁松弛过，比如现在想用 $i$ 松弛 $j’$，如果 $j$ 松弛过 $i’$，直接不让松弛就行了。一个点被松弛的次数小于总点数，复杂度也就是多个 $logn$，具体表现可能比20次dij好一点吧。</p><h3 id="1008-Numbers"><a href="#1008-Numbers" class="headerlink" title="1008.    Numbers"></a>1008.    Numbers</h3><p>从小到大取，$O(n^2logm)$，$n$ 是 $\sqrt{m}$ 级别。</p><h3 id="1010-Two-strings"><a href="#1010-Two-strings" class="headerlink" title="1010.    Two strings"></a>1010.    Two strings</h3><p>主要还是题意比较坑。。。匹配<code>.*</code>是要把<code>.</code>先变成某个字符再处理<code>*</code>。。。</p><p>队友(<em>wenwenla</em>)写了一种dp，先预处理pattern，dp[i]保存pattern前i个字符为止可以匹配到text的最左和最右，可以证明这个界里面的每一个都是可取的。</p><p>具体实现加一维表示最左最右，然后发现第一维可以去掉。</p><p><a href="https://github.com/Smlight/ACMer/blob/master/2017/08/22/2017%E5%A4%9A%E6%A0%A19/1010.cpp" target="_blank" rel="noopener">1010.cpp</a></p><p>时间0ms，就是容易写错。。。比赛的时候前面WA的都交上去了，最后一次AC的代码却没交上去[cry]。。。而且我们亲眼看到点了submit以后页面跳转了。。。结果连提交记录都没有？？</p><p>后来有人说了才发现这样直接正则就能过。<del>这题出得真好？？</del></p><p><a href="https://github.com/Smlight/ACMer/blob/master/2017/08/22/2017%E5%A4%9A%E6%A0%A19/1010_regex.cpp" target="_blank" rel="noopener">1010_regex.cpp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6158 The Designer</title>
    <link href="https://Smlight.github.io/blog/2017/08/20/hdu6158/"/>
    <id>https://Smlight.github.io/blog/2017/08/20/hdu6158/</id>
    <published>2017-08-20T10:31:55.000Z</published>
    <updated>2018-02-12T03:08:09.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>比赛之后有大佬说这题可以用圆的反演来做，学习了一下。</p><p>以两个大圆的切点为反演中心，任取一个反演半径，两个大圆会变成两条平行线。再考虑小圆的反演，由于相切的性质不变，小圆的反演圆就是一列夹在平行线中间的小圆。</p><p>示意图：</p><p><img src="http://img.blog.csdn.net/20170820182706028" alt="圆的反演"></p><p>当然这样还是 $O(n)$ 的，但是看题目里的图就知道小圆会越来越小，小到一定程度以后直接不考虑就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include &lt;bits/stdc++.h&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</div><div class="line"></div><div class="line">typedef <span class="keyword">long</span> <span class="keyword">double</span> ld;</div><div class="line"><span class="keyword">const</span> ld IR2=<span class="number">100</span>;</div><div class="line"><span class="keyword">const</span> ld PI=<span class="number">3.141592653589793238462643383279502884197169399375105820974944592307816</span>L;</div><div class="line"><span class="keyword">struct</span> Point &#123;</div><div class="line">    ld x,y;</div><div class="line">    Point(ld _x=<span class="number">0</span>,ld _y=<span class="number">0</span>):x(_x),y(_y) &#123;&#125;</div><div class="line">    Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> Point(R.x+x,R.y+y);</div><div class="line">    &#125;</div><div class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> Point(R.x-x,R.y-y);</div><div class="line">    &#125;</div><div class="line">    ld <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> R.x*x+R.y*y;</div><div class="line">    &#125;</div><div class="line">    Point <span class="keyword">operator</span> *(<span class="keyword">const</span> ld &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> Point(x*R,y*R);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">double</span> o1=x,o2=y;</div><div class="line">        cout&lt;&lt;o1&lt;&lt;<span class="string">" "</span>&lt;&lt;o2&lt;&lt;<span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></div><div class="line"><span class="function">ld <span class="title">inv_circle</span>(<span class="params">Point O,Point C,ld r</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> IR2*r/(sqr(O-C)-sqr(r));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="function">Point <span class="title">O</span>(<span class="params"><span class="number">0</span>,<span class="number">0</span></span>)</span>;</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">double</span> t1,t2;</div><div class="line">        scanf(<span class="string">"%lf%lf"</span>,&amp;t1,&amp;t2);</div><div class="line">        <span class="keyword">if</span> (t1&gt;t2) swap(t1,t2);</div><div class="line">        ld r=t1,R=t2;</div><div class="line">        <span class="keyword">int</span> n;</div><div class="line">        scanf(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="function">Point <span class="title">P</span>(<span class="params"><span class="number">0.5</span>*IR2/R,<span class="number">0</span></span>)</span>;</div><div class="line">        <span class="function">Point <span class="title">Q</span>(<span class="params"><span class="number">0.5</span>*IR2/r,<span class="number">0</span></span>)</span>;</div><div class="line">        ld L=Q.x-P.x;</div><div class="line">        <span class="function">Point <span class="title">o</span>(<span class="params">(P+Q</span>)*0.5)</span>;</div><div class="line">        ld ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) &#123;</div><div class="line">            <span class="function">Point <span class="title">C</span>(<span class="params">o.x,o.y+(n/<span class="number">2</span></span>)*L)</span>;</div><div class="line">            ld rr=inv_circle(O,C,L*<span class="number">0.5</span>);</div><div class="line">            ans+=PI*rr*rr;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i+i<span class="number">-1</span>&lt;=n;i++) &#123;</div><div class="line">            <span class="function">Point <span class="title">C</span>(<span class="params">o.x,o.y+(i<span class="number">-1</span></span>)*L)</span>;</div><div class="line">            ld rr=inv_circle(O,C,L*<span class="number">0.5</span>);</div><div class="line">            ld area=PI*rr*rr;</div><div class="line">            <span class="keyword">if</span> (area&lt;<span class="number">1e-12</span>) <span class="keyword">break</span>;</div><div class="line">            ans+=area;</div><div class="line">            <span class="keyword">if</span> (i&gt;<span class="number">1</span>) ans+=area;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span> <span class="keyword">out</span>=ans;</div><div class="line">        printf(<span class="string">"%.5f\n"</span>,<span class="keyword">out</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>大佬不愿意透露id，鸣谢csust？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h3&gt;&lt;p&gt;比赛之后有大佬说这题可以用圆的反演来做，学习了一下。&lt;/p&gt;
&lt;p&gt;以两个大圆的切点为反演中心，任取一个反演半径，两个大圆会变成两条平行线。
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6156 Palindrome Function</title>
    <link href="https://Smlight.github.io/blog/2017/08/20/hdu6156/"/>
    <id>https://Smlight.github.io/blog/2017/08/20/hdu6156/</id>
    <published>2017-08-20T09:16:54.000Z</published>
    <updated>2018-02-12T03:08:12.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义函数 $f(n,k)$，当 $n$ 在 $k$ 进制表示为回文数时，$f(n,k)=k$；否则 $f(n,k)=1$ 。求 $\sum_{i=L}^{R}\sum_{j=l}^{r}f(i,j)$ 。（$1 \leq T \leq 10^5, 1 \leq L \leq R \leq 10^9, 2 \leq l \leq r \leq 36$）</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以发现 $l,r$ 的范围很小，直接枚举 $j$ 代表 $j$ 进制，对于 $i$ 用数位dp统计即可。</p><p>比赛的时候竟然没做这一题。。。蠢死了 ┭┮﹏┭┮ </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">typedef long long ll;</div><div class="line">const <span class="keyword">int</span> B=<span class="number">40</span>;</div><div class="line"><span class="keyword">int</span> dig[B],tmp[B];</div><div class="line">ll dp[B][B][B];</div><div class="line"><span class="keyword">int</span> base;</div><div class="line"></div><div class="line">ll dfs(<span class="keyword">int</span> <span class="keyword">pos</span>,<span class="keyword">int</span> start,bool limit)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">pos</span>&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (!limit&amp;&amp;dp[base][<span class="keyword">pos</span>][start]!=-<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> dp[base][<span class="keyword">pos</span>][start];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> <span class="keyword">last</span>=limit?dig[<span class="keyword">pos</span>]:base-<span class="number">1</span>;</div><div class="line">    ll res=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="keyword">last</span>;i++) &#123;</div><div class="line">        tmp[<span class="keyword">pos</span>]=i;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">pos</span>==start&amp;&amp;i==<span class="number">0</span>) &#123;</div><div class="line">            res+=dfs(<span class="keyword">pos</span>-<span class="number">1</span>,start-<span class="number">1</span>,limit&amp;&amp;(i==<span class="keyword">last</span>));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">pos</span>&lt;(start+<span class="number">1</span>)/<span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (i==tmp[start-<span class="keyword">pos</span>]) &#123;</div><div class="line">                res+=dfs(<span class="keyword">pos</span>-<span class="number">1</span>,start,limit&amp;&amp;(i==<span class="keyword">last</span>));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            res+=dfs(<span class="keyword">pos</span>-<span class="number">1</span>,start,limit&amp;&amp;(i==<span class="keyword">last</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!limit) dp[base][<span class="keyword">pos</span>][start]=res;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ll calc(<span class="keyword">int</span> <span class="keyword">x</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">x</span>) &#123;</div><div class="line">        dig[len++]=<span class="keyword">x</span>%base;</div><div class="line">        <span class="keyword">x</span>/=base;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(len-<span class="number">1</span>,len-<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    memset(dp,-<span class="number">1</span>,sizeof(dp));</div><div class="line">    <span class="keyword">int</span> T,cas=<span class="number">0</span>;</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> L,R,l,r;</div><div class="line">        scanf(<span class="string">"%d%d%d%d"</span>,&amp;L,&amp;R,&amp;l,&amp;r);</div><div class="line">        ll ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (base=l;base&lt;=r;base++) &#123;</div><div class="line">            ll cnt=calc(R)-calc(L-<span class="number">1</span>);</div><div class="line">            ans+=cnt*base+(R-L+<span class="number">1</span>-cnt);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,++cas,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;定义函数 $f(n,k)$，当 $n$ 在 $k$ 进制表示为回文数时，$f(n,k)=k$；否则 $f(n,k)=1$ 。求 $\sum_
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训8 部分题解</title>
    <link href="https://Smlight.github.io/blog/2017/08/18/2017multi8/"/>
    <id>https://Smlight.github.io/blog/2017/08/18/2017multi8/</id>
    <published>2017-08-18T00:45:08.000Z</published>
    <updated>2018-02-21T13:08:53.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/08/17/2017%E5%A4%9A%E6%A0%A18" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1001-Army-Formations"><a href="#1001-Army-Formations" class="headerlink" title="1001.    Army Formations"></a>1001.    Army Formations</h3><p>感觉题意有点绕。。。其实就是每个节点一开始就有整个子树的序列，那么这个序列一定是先输入小的再输入大的才能最优。</p><p>不过这个事情也不是两个有序表合并这么简单，因为对于两个序列，只有把某个序列的数一个一个地插入到另一个才能算出答案。这时候就要用到启发式合并，什么是启发式的策略，通俗来讲就是人脑比较倾向于选择的策略。比如在这里就是把短的序列一个一个插到长的里面，比赛的写的线段树合并结果写了一大坨还没调出来，太蠢了😂。。。然后照着题解写了一个树状数组。。。</p><p>代码见附录，<code>dfs</code>用来得到轻重儿子，<code>solve</code>就是插入和合并，要递归重儿子时直接把轻儿子的全部删掉就行了。</p><h3 id="1002-Battlestation-Operational"><a href="#1002-Battlestation-Operational" class="headerlink" title="1002.    Battlestation Operational"></a>1002.    Battlestation Operational</h3><p>求 $f(n)=\sum_{i=1}^{n}\sum_{j=1}^{i} \left\lceil \frac{i}{j} \right\rceil \left[ (i, j) = 1\right]$ 。</p><p>比赛的时候算是瞎猜了一下。。。其实这题反演的理论性还是很好的。</p><p>以下 $n,i,j,k,d$ 均为正整数，且<strong>用 $(i,j)$ 表示 $i$ 和 $j$ 的最大公约数</strong>。</p><p>记 $h(i)=\sum_{j=1}^{i} \left\lceil \frac{i}{j} \right\rceil \left[ (i, j) = 1\right]$，显然 $f(n)$ 为 $h(i)$ 的前缀和。<br>考虑到 $h(i)$ 中与互质有关，不易直接求解，直接令 $g(i)=\sum_{j=1}^{i} \left\lceil \frac{i}{j} \right\rceil$ 。</p><p>将 $g(i)$ 中的 $\left\lceil \frac{i}{j} \right\rceil$ 按 $(i,j)$ 分类。枚举可能的 $(i,j)=d$，则有 $d|i，j=kd，k\le \frac{i}{d}$ 且 $(i,kd)=d$（注意， $k$ 不是从 $1$ 到 $\frac{i}{d}$ 的全集）。现只对这一类求和：<br>$$ \begin{equation}\begin{split}<br> &amp;\sum_{k=1}^{\frac{i}{d}}\left\lceil \frac{i}{kd} \right\rceil \left[ (i, kd) = d\right] \<br>=&amp; \sum_{k=1}^{\frac{i}{d}}\left\lceil \cfrac{\frac{i}{d}}{k} \right\rceil \left[ (\frac{i}{d}, k) = 1\right] \<br>=&amp;\ h(\frac{i}{d})<br>\end{split}\end{equation}$$<br>当 $d$ 取遍 $i$ 的约数，我们有 $g(i)=\sum_{d|i}h(\frac{i}{d})$。<br>由约数的性质，也即 $g(i)=\sum_{d|i}h(d)$ 。<br>这是标准的莫比乌斯反演形式，可以得到 $h(i)=\sum_{d|i} \mu(d) g(\frac{i}{d})$ 。</p><p>小结一下。</p><p><em>如何求解 $f(n)$：</em>$h(i)$ 的前缀和；</p><p><em>如何求解 $h(i)$：</em>莫比乌斯反演；</p><p><em>如何求解 $\mu(i)$：</em>线性筛模板；</p><p><em>如何求解 $g(i)$：</em>按常规考虑枚举分母（$j$），则对于 $i=j$ 的 $g(i)$ 要+1，对于 $i=j+1…2j$ 的 $g(i)$ 要+2，……，也就是说一个 $j$ 相当于多次区间加法；但是这里不需要动态维护，只需要最终结果，所以利用差分的思想，即 $g’(i)=g(i)-g(i-1)$，回顾上述过程就是对 $g’(i)$ 在 $j,j+1,2j+1…$ 的单点修改，容易很多，最后再对 $g’(i)$ 求和即可。</p><p>鸣谢 <strong>quailty, forever97</strong>！</p><h3 id="1008-Hybrid-Crystals"><a href="#1008-Hybrid-Crystals" class="headerlink" title="1008.    Hybrid Crystals"></a>1008.    Hybrid Crystals</h3><h3 id="1011-Killer-Names"><a href="#1011-Killer-Names" class="headerlink" title="1011.    Killer Names"></a>1011.    Killer Names</h3><p><code>dp[i][j]</code>表示前<code>i</code>个字符恰好用到<code>j</code>种字符的方案数，然后把组合数表和dp表预处理一下，每次 $O(m^2)$ 回答。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hihocoder 1553 区间统计</title>
    <link href="https://Smlight.github.io/blog/2017/08/17/hihocoder1553/"/>
    <id>https://Smlight.github.io/blog/2017/08/17/hihocoder1553/</id>
    <published>2017-08-17T02:00:21.000Z</published>
    <updated>2018-02-21T13:08:43.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><a href="http://hihocoder.com/problemset/problem/1553" target="_blank" rel="noopener">#1553 : 区间统计</a> 中文题。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先预处理所有幂次的结果，$O(NK)$；还有IO时间一定要注意。以下均不讨论。</p><p>一看题，无修改区间询问，莫队走起。但是用map复杂度太高了，没算错的话应该是 $O(n^{1.5}logn+m\sqrt{n})$ 。</p><p>考虑到A[]的范围不大，可以对A[]计数，不过没什么卵用。但是对A[]计数以后可以发现，我们不仅可以对值计数还可以对次数计数，也就是说has[i]表示有多少数在当前询问中的<strong>出现次数</strong>等于 i 。</p><p>到这里还是比较容易的，但是如果直接扫has[]复杂度并没有降低 $O(n^{1.5}+mn)$ 。。。</p><p>仍然是考虑分治思想，一次询问最多是整个区间，整个区间中出现次数大于 $\sqrt{n}$ 的数不会超过 $\sqrt{n}$ 个，还可以进行另外的预处理，我就直接<code>multiset</code>暴力了。。。复杂度大概是 $O(n^{1.5}+m\sqrt{n}+(n+m)log{\sqrt{n}})$ 。。。(已经不会算了 _(:△」∠)_ )</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MO=<span class="number">1000000007</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> len;</div><div class="line"><span class="keyword">int</span> po[N][<span class="number">105</span>];</div><div class="line"><span class="keyword">int</span> cnt[N],has[N];</div><div class="line"><span class="keyword">int</span> a[N],anss[M];</div><div class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ss;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> fastIO &#123;</div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100000</span></div><div class="line">    <span class="comment">//fread -&gt; read</span></div><div class="line">    <span class="keyword">bool</span> IOerror = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;</div><div class="line">        <span class="keyword">if</span>(p1 == pend) &#123;</div><div class="line">            p1 = buf;</div><div class="line">            pend = buf + fread(buf, <span class="number">1</span>, BUF_SIZE, <span class="built_in">stdin</span>);</div><div class="line">            <span class="keyword">if</span>(pend == p1) &#123;</div><div class="line">                IOerror = <span class="number">1</span>;</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> *p1++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ch == <span class="string">' '</span> || ch == <span class="string">'\n'</span> || ch == <span class="string">'\r'</span> || ch == <span class="string">'\t'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> ch;</div><div class="line">        <span class="keyword">while</span>(blank(ch = nc()));</div><div class="line">        <span class="keyword">if</span>(IOerror)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">for</span>(x = ch - <span class="string">'0'</span>; (ch = nc()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">#<span class="meta-keyword">undef</span> BUF_SIZE</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Query &#123;</div><div class="line">    <span class="keyword">int</span> L, R, k, ID, block;</div><div class="line">    Query() &#123;&#125;</div><div class="line">    Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> ID):L(l), R(r), k(k), ID(ID) &#123;</div><div class="line">        block = l / len;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;rhs) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span>(block == rhs.block) <span class="keyword">return</span> R &lt; rhs.R;</div><div class="line">        <span class="keyword">return</span> block &lt; rhs.block;</div><div class="line">    &#125;</div><div class="line">&#125; queries[M];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    --has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.erase(ss.find(cnt[n]));</div><div class="line">    &#125;</div><div class="line">    ++cnt[n];</div><div class="line">    ++has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.insert(cnt[n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    --has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.erase(ss.find(cnt[n]));</div><div class="line">    &#125;</div><div class="line">    --cnt[n];</div><div class="line">    ++has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.insert(cnt[n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    fastIO::read(T);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++) &#123;</div><div class="line">        po[i][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">100</span>;j++) &#123;</div><div class="line">            po[i][j]=<span class="number">1L</span>L*po[i][j<span class="number">-1</span>]*i%MO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> n, m;</div><div class="line">        fastIO::read(n);</div><div class="line">        fastIO::read(m);</div><div class="line">        len = <span class="built_in">sqrt</span>(n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            fastIO::read(a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            <span class="keyword">int</span> l,r,k;</div><div class="line">            fastIO::read(l);</div><div class="line">            fastIO::read(r);</div><div class="line">            fastIO::read(k);</div><div class="line">            queries[i] = Query(l, r, k, i);</div><div class="line">        &#125;</div><div class="line">        sort(queries + <span class="number">1</span>, queries + m + <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">1</span>;</div><div class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</div><div class="line">        <span class="built_in">memset</span>(has,<span class="number">0</span>,<span class="keyword">sizeof</span>(has));</div><div class="line">        cnt[a[<span class="number">1</span>]]=<span class="number">1</span>;</div><div class="line">        has[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">        ss.clear();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            Query &amp;qi = queries[i];</div><div class="line">            <span class="keyword">while</span>(R &lt; qi.R) insert(a[++R]);</div><div class="line">            <span class="keyword">while</span>(L &gt; qi.L) insert(a[--L]);</div><div class="line">            <span class="keyword">while</span>(R &gt; qi.R) erase(a[R--]);</div><div class="line">            <span class="keyword">while</span>(L &lt; qi.L) erase(a[L++]);</div><div class="line">            ll ans = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len;j++) &#123;</div><div class="line">                ans+=<span class="number">1L</span>L*has[j]*po[j][qi.k]%MO;</div><div class="line">                ans%=MO;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x:ss) &#123;</div><div class="line">                ans+=po[x][qi.k];</div><div class="line">                ans%=MO;</div><div class="line">            &#125;</div><div class="line">            anss[qi.ID]=ans;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>特别鸣谢 <strong>Claris</strong>！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://hihocoder.com/problemset/problem/1553&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6129 Just do it</title>
    <link href="https://Smlight.github.io/blog/2017/08/17/hdu6129/"/>
    <id>https://Smlight.github.io/blog/2017/08/17/hdu6129/</id>
    <published>2017-08-17T00:41:10.000Z</published>
    <updated>2018-02-12T03:08:14.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为 $n$ 的整数序列 ${a_n}$，对其做 $m$ 次前缀异或和，求最终的序列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对这个过程手动模拟几行，注意不要消去，可以发现第 $m$ 次第 $i$ 个数的结果包含了 $C_{m-1+i-j}^{i-j}$ 次第 $j$ 个数($j\le i$) 。</p><p>首先我们需要判断它的奇偶性。奇偶性相当于2进制的结果，2为质数，可以使用Lucas定理。2进制的每一位只有四种情况，其中 $C_{0}^{1}=0，C_{0}^{0}=C_{1}^{0}=C_{1}^{1}=1$ 。</p><p>将 $m-1$ 和 $i-j$ 的每一位展开，在第 $k$ 位上，如果 $m-1$ 和 $i-j$ 都是 1，那么结果就是 0 。</p><p>从小到大枚举 $k$ ，表示 $i-j$ 的第 $k$ 位为 1，若 $m-1$ 的第 $k$ 位不为 1，那么直接更新<strong>a序列本身</strong>。也就是说，每次只用满足 $i-j=2^{k}$ 的 $a[j]$ 更新 $a[i]$，然而此时的 $a[j]$ 已经被 $k$ 取 $0\dots k-1$ 更新过了，所以相当于考虑了 $i-j$ 在 $0\dots k$ 位的所有情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> a[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n,m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;m--;</div><div class="line">        <span class="keyword">while</span> (k&lt;n) &#123;</div><div class="line">            <span class="keyword">if</span> ((m&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;k;i--) &#123;</div><div class="line">                    a[i]^=a[i-k];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            m&gt;&gt;=<span class="number">1</span>;k&lt;&lt;=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,a[i],<span class="string">" \n"</span>[i==n]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;有一个长度为 $n$ 的整数序列 ${a_n}$，对其做 $m$ 次前缀异或和，求最终的序列。&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 5893 List wants to travel</title>
    <link href="https://Smlight.github.io/blog/2017/08/09/hdu5893/"/>
    <id>https://Smlight.github.io/blog/2017/08/09/hdu5893/</id>
    <published>2017-08-09T09:26:09.000Z</published>
    <updated>2018-02-12T03:09:05.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵树，要求支持：</p><ol><li>询问从u到v整条路径有几段边权（相同边权连成一段）；</li><li>修改从u到v整条路径的边权。</li></ol><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先考虑在序列上的问题，可以用线段树维护颜色段数以及左右端的颜色。<br>对于树上的问题，用树链剖分变成序列上的问题即可。</p><p>但是写起来并不是那么好写的。。。泄露出来的标程写了 6KB 还特别恶心。。。<br>还好我搜到了一份<a href="http://blog.csdn.net/basasuya/article/details/52625574" target="_blank" rel="noopener">非常漂亮的代码</a>，同时建议做树链剖分时把线段树整体作为一个结构体~</p><p>回答询问时还要注意因为两条链都是由浅到深的，拼起来必须有一个要反过来。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">const <span class="keyword">int</span> N=<span class="number">4</span>e4+<span class="number">5</span>;</div><div class="line">struct Edge &#123;</div><div class="line">    <span class="keyword">int</span> go,<span class="keyword">next</span>;</div><div class="line">&#125; eg[N&lt;&lt;<span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> <span class="keyword">last</span>[N],tot,e[N][<span class="number">3</span>];</div><div class="line"><span class="keyword">int</span> num[N],son[N],dep[N],fa[N],<span class="keyword">pos</span>;</div><div class="line"><span class="keyword">int</span> top[N],p[N],fp[N];</div><div class="line"><span class="keyword">int</span> col[N];</div><div class="line"></div><div class="line">void init()</div><div class="line">&#123;</div><div class="line">    tot=<span class="number">0</span>;<span class="keyword">pos</span>=<span class="number">0</span>;</div><div class="line">    memset(<span class="keyword">last</span>,-<span class="number">1</span>,sizeof(<span class="keyword">last</span>));</div><div class="line">    memset(son,-<span class="number">1</span>,sizeof(son));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void addedge(<span class="keyword">int</span> <span class="keyword">x</span>,<span class="keyword">int</span> <span class="keyword">y</span>)</div><div class="line">&#123;</div><div class="line">    eg[tot]=&#123;<span class="keyword">y</span>,<span class="keyword">last</span>[<span class="keyword">x</span>]&#125;;</div><div class="line">    <span class="keyword">last</span>[<span class="keyword">x</span>]=tot++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dfs(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</div><div class="line">&#123;</div><div class="line">    dep[u]=d;</div><div class="line">    fa[u]=pre;</div><div class="line">    num[u]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="keyword">last</span>[u];i!=-<span class="number">1</span>;i=eg[i].next) &#123;</div><div class="line">        <span class="keyword">int</span> &amp;v=eg[i].go;</div><div class="line">        <span class="keyword">if</span> (v!=pre) &#123;</div><div class="line">            dfs(v,u,d+<span class="number">1</span>);</div><div class="line">            num[u]+=num[v];</div><div class="line">            <span class="keyword">if</span> (son[u]==-<span class="number">1</span>||num[v]&gt;num[son[u]]) &#123;</div><div class="line">                son[u]=v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void getpos(<span class="keyword">int</span> u,<span class="keyword">int</span> sp)</div><div class="line">&#123;</div><div class="line">    top[u]=sp;</div><div class="line">    p[u]=++<span class="keyword">pos</span>;</div><div class="line">    fp[p[u]]=u;</div><div class="line">    <span class="keyword">if</span> (son[u]==-<span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">    getpos(son[u],sp);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="keyword">last</span>[u];i!=-<span class="number">1</span>;i=eg[i].next) &#123;</div><div class="line">        <span class="keyword">int</span> &amp;v=eg[i].go;</div><div class="line">        <span class="keyword">if</span> (v!=son[u]&amp;&amp;v!=fa[u]) &#123;</div><div class="line">            getpos(v,v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct SegTree &#123;</div><div class="line">    struct Node &#123;</div><div class="line">        <span class="keyword">int</span> <span class="keyword">lc</span>,rc,cnt;</div><div class="line">        Node(<span class="keyword">int</span> a=-<span class="number">1</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>):<span class="keyword">lc</span>(a),rc(b),cnt(c) &#123;&#125;</div><div class="line">        Node operator +(const Node &amp;R) const &#123;</div><div class="line">            <span class="keyword">if</span> (!cnt) <span class="keyword">return</span> R;</div><div class="line">            <span class="keyword">if</span> (!R.cnt) <span class="keyword">return</span> *this;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="keyword">lc</span>,R.rc,cnt+R.cnt-(rc==R.lc)&#125;;</div><div class="line">        &#125;</div><div class="line">        Node rev() &#123;</div><div class="line">            <span class="keyword">return</span> &#123;rc,<span class="keyword">lc</span>,cnt&#125;;</div><div class="line">        &#125;</div><div class="line">        void <span class="keyword">print</span>() &#123;</div><div class="line">            <span class="keyword">printf</span>(<span class="string">"%d %d %d\n"</span>,<span class="keyword">lc</span>,rc,cnt);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">tr</span>[N&lt;&lt;<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> flag[N&lt;&lt;<span class="number">2</span>];</div><div class="line">    <span class="comment">#define lson rt&lt;&lt;1,l,m</span></div><div class="line">    <span class="comment">#define rson rt&lt;&lt;1|1,m+1,r</span></div><div class="line">    void push_up(<span class="keyword">int</span> rt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">tr</span>[rt]=<span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>]+<span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    void push_down(<span class="keyword">int</span> rt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (flag[rt]!=-<span class="number">1</span>) &#123;</div><div class="line">            flag[rt&lt;&lt;<span class="number">1</span>]=flag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=flag[rt];</div><div class="line">            <span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>]=<span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=&#123;flag[rt],flag[rt],<span class="number">1</span>&#125;;</div><div class="line">            flag[rt]=-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    void build(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</div><div class="line">    &#123;</div><div class="line">        flag[rt]=-<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (l==r) &#123;</div><div class="line">            <span class="keyword">tr</span>[rt]=&#123;col[l],col[l],<span class="number">1</span>&#125;;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> <span class="keyword">m</span>=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        build(lson);</div><div class="line">        build(rson);</div><div class="line">        push_up(rt);</div><div class="line">    &#125;</div><div class="line">    void update(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> col)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) &#123;</div><div class="line">            <span class="keyword">tr</span>[rt]=&#123;col,col,<span class="number">1</span>&#125;;</div><div class="line">            flag[rt]=col;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        push_down(rt);</div><div class="line">        <span class="keyword">int</span> <span class="keyword">m</span>=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (L&lt;=<span class="keyword">m</span>) update(lson,L,R,col);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">m</span>&lt;R) update(rson,L,R,col);</div><div class="line">        push_up(rt);</div><div class="line">    &#125;</div><div class="line">    Node getsum(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">tr</span>[rt];</div><div class="line">        &#125;</div><div class="line">        push_down(rt);</div><div class="line">        <span class="keyword">int</span> <span class="keyword">m</span>=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        Node res;</div><div class="line">        <span class="keyword">if</span> (L&lt;=<span class="keyword">m</span>) res=res+getsum(lson,L,R);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">m</span>&lt;R) res=res+getsum(rson,L,R);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    void change(<span class="keyword">int</span> <span class="keyword">x</span>,<span class="keyword">int</span> <span class="keyword">y</span>,<span class="keyword">int</span> col)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> tx=top[<span class="keyword">x</span>],ty=top[<span class="keyword">y</span>];</div><div class="line">        <span class="keyword">while</span> (tx!=ty) &#123;</div><div class="line">            <span class="keyword">if</span> (dep[tx]&lt;dep[ty]) &#123;</div><div class="line">                swap(tx,ty);</div><div class="line">                swap(<span class="keyword">x</span>,<span class="keyword">y</span>);</div><div class="line">            &#125;</div><div class="line">            update(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[tx],p[<span class="keyword">x</span>],col);</div><div class="line">            <span class="keyword">x</span>=fa[tx];</div><div class="line">            tx=top[<span class="keyword">x</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">x</span>==<span class="keyword">y</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (dep[<span class="keyword">x</span>]&gt;dep[<span class="keyword">y</span>]) &#123;</div><div class="line">            swap(<span class="keyword">x</span>,<span class="keyword">y</span>);</div><div class="line">        &#125;</div><div class="line">        update(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[son[<span class="keyword">x</span>]],p[<span class="keyword">y</span>],col);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> query(<span class="keyword">int</span> <span class="keyword">x</span>,<span class="keyword">int</span> <span class="keyword">y</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> tx=top[<span class="keyword">x</span>],ty=top[<span class="keyword">y</span>];</div><div class="line">        Node X,Y;</div><div class="line">        <span class="keyword">while</span> (tx!=ty) &#123;</div><div class="line">            <span class="keyword">if</span> (dep[tx]&lt;dep[ty]) &#123;</div><div class="line">                Y=getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[ty],p[<span class="keyword">y</span>])+Y;</div><div class="line">                <span class="keyword">y</span>=fa[ty];</div><div class="line">                ty=top[<span class="keyword">y</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                X=getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[tx],p[<span class="keyword">x</span>])+X;</div><div class="line">                <span class="keyword">x</span>=fa[tx];</div><div class="line">                tx=top[<span class="keyword">x</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Node ans;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">x</span>==<span class="keyword">y</span>) &#123;</div><div class="line">            ans=X.rev()+Y;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (dep[<span class="keyword">x</span>]&gt;dep[<span class="keyword">y</span>]) &#123;</div><div class="line">                ans=Y.rev()+getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[son[<span class="keyword">y</span>]],p[<span class="keyword">x</span>])+X;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ans=X.rev()+getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[son[<span class="keyword">x</span>]],p[<span class="keyword">y</span>])+Y;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans.cnt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">#undef lson</span></div><div class="line">    <span class="comment">#undef rson</span></div><div class="line">&#125; mytree;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,<span class="keyword">m</span>;</div><div class="line">    <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;<span class="keyword">m</span>)!=EOF) &#123;</div><div class="line">        init();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</div><div class="line">            scanf(<span class="string">"%d%d%d"</span>,&amp;e[i][<span class="number">0</span>],&amp;e[i][<span class="number">1</span>],&amp;e[i][<span class="number">2</span>]);</div><div class="line">            addedge(e[i][<span class="number">0</span>],e[i][<span class="number">1</span>]);</div><div class="line">            addedge(e[i][<span class="number">1</span>],e[i][<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        getpos(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (dep[e[i][<span class="number">0</span>]]&lt;dep[e[i][<span class="number">1</span>]]) &#123;</div><div class="line">                swap(e[i][<span class="number">0</span>],e[i][<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            col[p[e[i][<span class="number">0</span>]]]=e[i][<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">        mytree.build(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">m</span>--) &#123;</div><div class="line">            char op[<span class="number">9</span>];</div><div class="line">            <span class="keyword">int</span> u,v,w;</div><div class="line">            scanf(<span class="string">"%s%d%d"</span>,op,&amp;u,&amp;v);</div><div class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'C'</span>) &#123;</div><div class="line">                scanf(<span class="string">"%d"</span>,&amp;w);</div><div class="line">                mytree.change(u,v,w);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">printf</span>(<span class="string">"%d\n"</span>,mytree.query(u,v));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给出一棵树，要求支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;询问从u到v整条路径有几段边权（相同边权连成一段）；&lt;/li&gt;
&lt;li&gt;修改从u到v整条路
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 5901 Count primes</title>
    <link href="https://Smlight.github.io/blog/2017/08/05/hdu5901/"/>
    <id>https://Smlight.github.io/blog/2017/08/05/hdu5901/</id>
    <published>2017-08-05T07:46:09.000Z</published>
    <updated>2018-02-12T03:08:23.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>输出[1..n]的质数个数 (1 &lt;= n &lt;= 1e11) 。时间限制6s，空间限制64M 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很显然，要用线性筛的话时间和空间都不够。</p><p>有一种<a href="https://en.wikipedia.org/wiki/Meissel%E2%80%93Lehmer_algorithm" target="_blank" rel="noopener">Meissel–Lehmer算法</a>可以解决该问题，不过本文要介绍的是一种dp解法。</p><p>定义$SR(n,p)$为，$2..n$被小于等于$p$的质数筛后剩下的数的个数；也就是说，在n的范围内，是质数，或者是只由大于$p$的质数相乘得到的数的个数。<br>记小于等于$n$的质数个数为$\pi(n)$，那么显然有$SR(n,n)=\pi(n)$ 。</p><p>对$SR(n,p)$分两类讨论：</p><ul><li>当$p$不是质数或者$n&lt;p^2$时，有$SR(n,p)=SR(n,p-1)$；</li><li>当$p$是质数且$n\ge p^2$时，$SR(n,p)$ 也可由 $SR(n,p-1)$ 推得：$$SR(n,p)= SR(n,p−1)− SR(\frac{n}{p}, p−1)+ SR(p−1,p−1)$$ 表示要从 $2..p-1$ 筛后剩下的数中去掉那些质因子均大于等于 $p$ 且含 $p$ 的数，因为若有小于 $p$ 的质因子则该数已经被筛去了，同理，该数除以p也一定不会被 $2..p-1$ 筛去，所以减去 $SR(\frac{n}{p}, p−1)$，与此同时 $2..p-1$ 的质数也被减掉了，所以加上 $SR(p-1,p-1)$ 。</li></ul><p>当然因为空间限制肯定不能直接这样dp，考虑到整个过程中只用到了 $p$ 和 $\frac{n}{p}$，我们直接分为两段dp， 用<code>H[k]</code>表示 $k\le \sqrt{n}$ 时 $SR(\frac{n}{k},p)$ 的值，用<code>L[k]</code>表示 $k \le \sqrt{n}$ 时 $SR(k,p)$ 的值。</p><p>先放出代码，原作者<em><a href="http://codeforces.com/profile/adkroxx" target="_blank" rel="noopener">adkroxx</a></em>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">320000</span>;</div><div class="line">ll H[N],L[N];</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">SR</span><span class="params">(ll n,ll p)</span></span></div><div class="line">&#123;</div><div class="line">    ll m;</div><div class="line">    <span class="keyword">for</span> (m=<span class="number">1</span>;m*m&lt;=n;++m) &#123;</div><div class="line">        H[m]=n/m<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>;i&lt;=m;++i) &#123;</div><div class="line">        L[i]=i<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (ll i=<span class="number">2</span>;i&lt;=m;++i)&#123;</div><div class="line">        <span class="keyword">if</span> (L[i]==L[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">for</span> (ll j=<span class="number">1</span>;j&lt;=min(m<span class="number">-1</span>,n/i/i);++j) &#123;</div><div class="line">            <span class="keyword">if</span>(i*j&lt;m) H[j]-=H[i*j]-L[i<span class="number">-1</span>];</div><div class="line">            <span class="keyword">else</span> H[j]-=L[n/i/j]-L[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (ll j=m;j&gt;=i*i;--j) &#123;</div><div class="line">            L[j]-=L[j/i]-L[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> H[<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ll n;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n)!=EOF) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,SR(n,n));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>L[],H[]</code>初始化为筛内总的个数(不含1)。代码中的<code>i</code>用来枚举质数(<code>L[i]==L[i-1]</code>表示<code>i</code>不是质数)，然后对于 $j&gt;i^2$ 的 $j$ 都更新一遍dp值，只是放在了两个不同的数组而已：对于 $j\le \sqrt{n}$ 的$j$更新<code>L[]</code>，对于 $j&gt;\sqrt{n}$ 的 $j$ 更新<code>H[]</code>。只要理解了递推式代码还是很好理解的。</p><p>这个算法的时间复杂度为$O(n^{\frac{3}{4}})$（证明可以看参考资料内的下一条评论），虽然不如Meissel–Lehmer算法，但是dp的思想非常巧妙，值得学习。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看到csdn和cnblogs上很多人都是把这份代码当作模板直接贴出来不讲解，不仅不尊重原作者，也有悖大家学习数据结构与算法的初衷，是以我不仅要翻译，还要加上一些自己的理解~~</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://codeforces.com/blog/entry/44466?#comment-290036" target="_blank" rel="noopener">Editorial of Educational Codeforces Round 12</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;输出[1..n]的质数个数 (1 &amp;lt;= n &amp;lt;= 1e11) 。时间限制6s，空间限制64M 。&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训3 部分题解</title>
    <link href="https://Smlight.github.io/blog/2017/08/02/2017multi3/"/>
    <id>https://Smlight.github.io/blog/2017/08/02/2017multi3/</id>
    <published>2017-08-02T02:29:25.000Z</published>
    <updated>2018-02-21T13:08:52.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/08/01/2017%E5%A4%9A%E6%A0%A13" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1003-Kanade’s-sum"><a href="#1003-Kanade’s-sum" class="headerlink" title="1003.    Kanade’s sum"></a>1003.    Kanade’s sum</h3><h3 id="1005-RXD-and-dividing"><a href="#1005-RXD-and-dividing" class="headerlink" title="1005.    RXD and dividing"></a>1005.    RXD and dividing</h3><h3 id="1006-RXD-and-functions"><a href="#1006-RXD-and-functions" class="headerlink" title="1006.    RXD and functions"></a>1006.    RXD and functions</h3><p>易得，$g_m(x)=f(x-\sum a_i)$ 。</p><p>记 $S=\sum a_i $，代入：</p><p>$$\large \begin{equation}\begin{split}<br>g_m(x)&amp;=\sum_{i=0}^{n}c_i(x-S)^i \\<br>&amp;=\sum_{i=0}^{n}c_i\sum_{j=0}^{i}C_{i}^{j}x^j(-S)^{i-j} \\<br>&amp;=x^0\sum_{j=0}^{n}c_jC_{j}^{0}(-S)^{j-0}+\cdots+x^n\sum_{j=0}^{n}c_jC_{j}^{n}(-S)^{j-n} \\<br>&amp;=\sum_{i=0}^{n}x^i\sum_{j=0}^{n}c_jC_{j}^{i}(-S)^{j-i} \\<br>&amp;=\sum_{i=0}^{n}x^i\sum_{j=i}^{n}c_j\cfrac{j!}{i!\cdot (j-i)!}(-S)^{j-i}<br>\end{split}\end{equation}$$<br>$\large \therefore b_i=\cfrac{1}{i!}\sum_{j=i}^{n}j!c_j\cdot \cfrac{(-S)^{j-i}}{(j-i)!}$<br>记$\large A_i=i!c_i，B_i=i!b_i，d_i=A_{n-i}，e_i=\cfrac{(-S)^{i}}{i!}，(1\le i\le n)$<br>$\large B_i=\sum_{k=i}^{n}A_k\cdot e_{k-i}=\sum_{k=0}^{n-i}d_{n-i-k}e_{k}$</p><p>考虑多项式乘法：<br>$A(x) = \sum_{i=0}^{n}a_ix^{i}$<br>$B(x) = \sum_{i=0}^{n}b_ix^{i}$<br>$C(x) = A(x)B(x) = \sum_{i=0}^{2n}c_ix^{i}$<br>$c_j = \sum_{i=0}^{j}a_ib_{j-i}$，</p><p>所以$B_i$即为多项式$D(x)E(x)$第$n-i$项的系数。</p><p>由于题目是在模意义下的，所以要用NTT，且费马质数必须为所给的模数。</p><h3 id="1011-RXD’s-date"><a href="#1011-RXD’s-date" class="headerlink" title="1011. RXD’s date"></a>1011. RXD’s date</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训2 部分题解</title>
    <link href="https://Smlight.github.io/blog/2017/07/28/2017multi2/"/>
    <id>https://Smlight.github.io/blog/2017/07/28/2017multi2/</id>
    <published>2017-07-28T06:20:14.000Z</published>
    <updated>2018-02-21T13:08:51.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/07/27/2017%E5%A4%9A%E6%A0%A12" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1001-Is-Derek-lying"><a href="#1001-Is-Derek-lying" class="headerlink" title="1001.    Is Derek lying?"></a>1001.    Is Derek lying?</h3><p>两个人的分数差、分数和，分别满足一个不等式。</p><h3 id="1003-Maximum-Sequence"><a href="#1003-Maximum-Sequence" class="headerlink" title="1003.    Maximum Sequence"></a>1003.    Maximum Sequence</h3><p>贪心，题解里讲得很好。</p><h3 id="1004-Puzzle"><a href="#1004-Puzzle" class="headerlink" title="1004.    Puzzle"></a>1004.    Puzzle</h3><p>见题解。</p><h3 id="1006-Funny-Function"><a href="#1006-Funny-Function" class="headerlink" title="1006.    Funny Function"></a>1006.    Funny Function</h3><p>碰到这种看起来像找规律的题，先打一个表。<br>给一个打表程序吧。。。</p><p>最后的规律当然比题解复杂一点。。。</p><h3 id="1008-To-my-boyfriend"><a href="#1008-To-my-boyfriend" class="headerlink" title="1008.    To my boyfriend"></a>1008.    To my boyfriend</h3><p>求期望相当于求和，求和可以单点贡献相加。</p><p>因为计算不同的数，也就是相同的数只贡献一次，约定一个子矩阵内如果有多个相同的数字则仅由最上并且最左的那个数字贡献。</p><p>对于某行某列的数，考虑它在子矩阵内能产生贡献的边界：</p><ul><li>对于下边界，没有特别的限制；</li><li>对于上边界，不能到达该列相同的数；</li><li>对于左右边界，与上边界有关，且易知上边界越向上，左右边界越靠近该列。</li></ul><p>显然，对于上边界的限制，我们需要维护该列某数字上一次出现的行号。而对于左右边界，实际上也可以类似地获得。</p><p>记当前这个数为$col$，位于$x$行$y$列。用$j$<strong>由远及近</strong>枚举每一列，将第$j$列上$col$上一次出现的那行的$l$更新为$j$，枚举每一列后，再根据上述左右边界的性质，从第$x-1$行向上不断对$l$取$max$(越来越靠近第$y$列)。$r$也是类似地处理。最后再枚举子矩阵的上界，对于每个上界可以$O(1)$累加贡献。总的复杂度$O(n^3)$。</p><p>最后由于我们约定的是最上且最左，所以左边界要考虑到同一行，右边界不用考虑同一行，这一点在读入前清空数组就会自动满足。</p><h3 id="1009-TrickGCD"><a href="#1009-TrickGCD" class="headerlink" title="1009.    TrickGCD"></a>1009.    TrickGCD</h3><p>栗子原话：</p><blockquote><p>现在感觉数列的值域化考的很多啊<br>数列的值域化，还有n/1+n/2+…+n/n=nlogn<br>这两个东西放在一起很热门</p></blockquote><p>根据题目，其实我们只要保证 1~n 总的gcd满足条件即可。</p><p>首先，我们从2开始枚举x，表示总的gcd至少为x，然后就需要容斥，大概感觉一下容斥系数就是 $-\mu(x)$（不会证），所以最终答案 $\large ans=\sum_{x=2}^{min{a_i}} -\mu(x) \prod_{i=1}^{i=n}\lfloor\cfrac{a_i}{x}\rfloor $ 。</p><p>这时候有两个想法。。。</p><p>一是确定的 $a$ 对于某一段 $x$ 总是同一个值，然后按照类似杜教筛的做法，共有 $2\sqrt{a}$ 段，每一段相当于一次区间乘法，可以类似差分地在区间前后打个标记，复杂度$2n\sqrt{A},A=max{a_i}$，然后就TLE了。。。</p><p>二是确定的 $x$ 对于值域在某一段的 $a$ 总是同一个值，因为答案跟 $a$ 序列的顺序无关，就可以直接把 $a$ 序列值域化，然后对于确定的 $x$ 再枚举 $\lfloor\cfrac{a}{x}\rfloor$ 即可，总的复杂度 $O(MlogM),M=10^5$ 。</p><h3 id="1011-Regular-polygon"><a href="#1011-Regular-polygon" class="headerlink" title="1011.    Regular polygon"></a>1011.    Regular polygon</h3><p>整点结论：只有正四边形。可以 $O(1)$ 映射。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ol><li><a href="http://bestcoder.hdu.edu.cn/blog/2017-multi-university-training-contest-2-solutions-by-%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6/" target="_blank" rel="noopener">solutions BY 电子科技大学</a></li><li><a href="https://raw.githubusercontent.com/Smlight/ACMer/master/2017/07/27/2017%E5%A4%9A%E6%A0%A12/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2017%E8%AE%BA%E6%96%87%E9%9B%86.pdf" target="_blank" rel="noopener">国家集训队2017论文集</a></li><li><a href="http://www.cnblogs.com/nicetomeetu/p/7261147.html" target="_blank" rel="noopener"> To my boyfriend [ 分析,期望 ] </a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训1 部分题解</title>
    <link href="https://Smlight.github.io/blog/2017/07/26/2017multi1/"/>
    <id>https://Smlight.github.io/blog/2017/07/26/2017multi1/</id>
    <published>2017-07-26T02:47:36.000Z</published>
    <updated>2018-02-06T07:34:56.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/07/25/2017%E5%A4%9A%E6%A0%A11" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1001-Add-More-Zero"><a href="#1001-Add-More-Zero" class="headerlink" title="1001. Add More Zero"></a>1001. Add More Zero</h3><h3 id="1002-Balala-Power"><a href="#1002-Balala-Power" class="headerlink" title="1002. Balala Power!"></a>1002. Balala Power!</h3><p>每个字符对答案的贡献都可以看作一个26进制的数字，直接按26进制的从高到低位比较大小。由排序不等式，显然贡献越大的对应的数字越大时答案最大。</p><p>注意点：一个字符一旦做过最高位(位数大于1)就不能被赋值为0。</p><h3 id="1003-Colorful-Tree"><a href="#1003-Colorful-Tree" class="headerlink" title="1003. Colorful Tree"></a>1003. Colorful Tree</h3><p>单独考虑每一种颜色，答案就是对于每种颜色，至少经过一次这种颜色的路径条数之和。反过来思考只需要求有多少条路径没有经过这种颜色即可。</p><p>记$u$的颜色为col[u]。对于$v$，若在子树$v$中取$x$，在子树$v$外取$y$，则这些路径一定会经过col[v]。那么有两个推论：</p><ul><li>不经过col[v]的路径的两端$x,y$一定同在子树$v$；</li><li>对于$v$的祖先$u$，若col[v]==col[u]，则在$u$上计算时整棵子树$v$都要被排除。</li></ul><p>这样我们可以用合并线段树的方法解决，复杂度$O(nlogn)$，详见附录2。</p><p>又发现线段树实际上只维护了单点增加的操作，可以用sum[i]表示颜色i需要排除的节点数<strong>对于dfs序</strong>的前缀和，复杂度$O(n)$。</p><h3 id="1006-Function"><a href="#1006-Function" class="headerlink" title="1006. Function"></a>1006. Function</h3><p>考虑置换$a$的一个循环节，长度为$l$，那么有$$\LARGE f(i) = b_{f(a_i)} = b_{b_{f(a_{a_i})}} = \underbrace{b_{\cdots b_{f(i)}}}_{l\text{ times }b}$$</p><p>那么 $f(i)$ 的值在置换 $b$ 中所在的循环节的长度必须为 $l$ 的因数。</p><p>而如果 $f(i)$ 的值确定下来了，这个循环节的另外 $l - 1$ 个数的函数值也都确定下来了。</p><p>答案就是$\sum_{i = 1}^{k} \sum_{j | l_i} {j \cdot cal_j}$，其中 $k$ 是置换 $a$ 中循环节的个数，$l_i$ 表示置换 $a$ 中第 $i$ 个循环节的长度， $cal_j$​​ 表示置换 $b$ 中长度为 $j$ 的循环节的个数。</p><h3 id="1008-Hints-of-sd0061"><a href="#1008-Hints-of-sd0061" class="headerlink" title="1008. Hints of sd0061"></a>1008. Hints of sd0061</h3><h3 id="1009-I-Curse-Myself"><a href="#1009-I-Curse-Myself" class="headerlink" title="1009. I Curse Myself"></a>1009. I Curse Myself</h3><p>按题解写出来的那个方法过的，时间很险，3697ms。。。</p><h3 id="1011-KazaQ’s-Socks"><a href="#1011-KazaQ’s-Socks" class="headerlink" title="1011. KazaQ’s Socks"></a>1011. KazaQ’s Socks</h3><h3 id="1012-Limited-Permutation"><a href="#1012-Limited-Permutation" class="headerlink" title="1012. Limited Permutation"></a>1012. Limited Permutation</h3><p>题目给的信息实际上就是 $p[l_i…r_i]\ge p[i]$。</p><p>首先必须有一个位置 $i$ 满足 $l_i=1,r_i=n$，否则方案数为 0 。考虑 $i$ 左右的两段数，因为 $p[i]$ 是最小的，所以左边数向右的界不会越过 $i$，即 $(r_j \lt i)$ ；右边数向左的界不会越过 $i$，即 $(l_k \gt i)$ 。可以发现：左边数和右边数不会再有任何联系，是完全相同的两个子问题。每次递归给答案累乘<strong>从 $r_i-l_i$ 个数中选出一部分作为左边数</strong>的方案数即可。思路来自附录3，对应<code>1012_NlogN.cpp</code>。</p><p>很显然，递归算法的瓶颈不在于递归本身而在于利用映射查询是否有位置对应$[L,R]$ 。某大佬：用一个栈搞一搞就行了，对应<code>1012.cpp</code>。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ol><li><a href="http://bestcoder.hdu.edu.cn/blog/2017-multi-university-training-contest-8-solutions-by-%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6/" target="_blank" rel="noopener">solutions BY 北京航空航天大学</a></li><li><a href="http://blog.csdn.net/banfcc/article/details/76091240" target="_blank" rel="noopener">HDU6035 Colorful Tree</a></li><li><a href="http://blog.csdn.net/say\_c\_box/article/details/76147001" target="_blank" rel="noopener">HDU6044 Limited Permutation</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hihocoder 1529 不上升序列</title>
    <link href="https://Smlight.github.io/blog/2017/07/02/hihocoder1529/"/>
    <id>https://Smlight.github.io/blog/2017/07/02/hihocoder1529/</id>
    <published>2017-07-02T03:03:03.000Z</published>
    <updated>2018-02-06T09:39:34.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>听说最早的题目原型是<a href="http://codeforces.com/problemset/problem/13/C" target="_blank" rel="noopener">CF13C</a><br>下面按这题来讲，其实就是换成了不降。</p><h3 id="朴素DP"><a href="#朴素DP" class="headerlink" title="朴素DP"></a>朴素DP</h3><p>定义$f_i(X)$ 为前$i$个数变为不降序列且$a_i\le X$的最小步数。<br>显然有<br>$f_1(X) = min_{Y\le X}{|a_1-Y|}$<br>$f_i(X) = min_{Y\le X}{f_{i-1}(Y)+|a_i-Y|}$</p><h3 id="离散的DP"><a href="#离散的DP" class="headerlink" title="离散的DP"></a>离散的DP</h3><p>可以令${b_i}$为${a_i}$的一个有序copy，复杂度$O(n^2)$。<br>详情请阅 <a href="http://codeforces.com/blog/entry/364" target="_blank" rel="noopener">CF13C Tutorial</a> 。</p><h3 id="单调性优化"><a href="#单调性优化" class="headerlink" title="单调性优化"></a>单调性优化</h3><p>$f_i(X) = min_{Y\le X}{f_{i-1}(Y)+|a_i-Y|}=min(f_i(X-1),f_{i-1}(X)+|a_i-X|)$<br>由绝对值和最小值的性质，$f_i$对于$X$是一个单减的非负函数，并最后保持一个非负值。<br>考虑其“斜率函数” $g_i(X)=f_i(X+1)-f_i(X)$，则$g_i(X)$单增（不会证）。<br>$g_i(X)$的值域为有限个小于等于0的整数，我们将值域中每个数对应的最小的$x$写为一个序列（即“变化点”），即序列的最后一个数为使得$g_i(x)=0$的最小的$x$，……</p><p>突然发现我还是不会证，，那就没必要了，，大家还是看资料吧。。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://codeforces.com/blog/entry/47821" target="_blank" rel="noopener">http://codeforces.com/blog/entry/47821</a></li><li><a href="http://codeforces.com/blog/entry/47094?#comment-315161" target="_blank" rel="noopener">http://codeforces.com/blog/entry/47094?#comment-315161</a></li><li><a href="https://media.hihocoder.com/contests/challenge29/sol.pdf" target="_blank" rel="noopener">https://media.hihocoder.com/contests/challenge29/sol.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;听说最早的题目原型是&lt;a href=&quot;http://codeforces.com/problemset/problem/13/C&quot; targ
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年上海金马五校赛 解题报告</title>
    <link href="https://Smlight.github.io/blog/2017/06/04/2017%E5%B9%B4%E4%B8%8A%E6%B5%B7%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9B%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <id>https://Smlight.github.io/blog/2017/06/04/2017年上海金马五校赛解题报告/</id>
    <published>2017-06-04T01:33:52.000Z</published>
    <updated>2018-02-06T13:45:41.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>因为题目实在太多了，代码就不贴在博客里了。。。想看代码的童鞋可以去<a href="https://github.com/Smlight/ACMer/tree/master/2017/6%E6%9C%88/%E9%87%91%E9%A9%AC%E4%BA%94%E6%A0%A1%E8%B5%9B" target="_blank" rel="noopener">github</a>上看看。<br>题目似乎看不了了，我只能凭感觉复述一下题意了。。。</p><h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>这个比赛有一个资格赛，但是跟蓝桥杯决赛冲突了所以不能参加，没想到老师帮我们申请了参赛资格，意外之喜。<br>热身刚结束实验室就断电了。。然后吃完饭背着电脑去了没空调的教室。。。</p><h3 id="WarmUp"><a href="#WarmUp" class="headerlink" title="WarmUp"></a>WarmUp</h3><p>B题就不说了，反正一眼。A题首先肯定要把质数都筛出来，本来想在质数表里直接做的，但是发现写不出来。。。主要是因为对于 $a\leq x\leq b-m+1$ 都要成立，这个放到质数表里细节太多。。。所以想还不如直接交个很好写的二分答案，结果一发过了。。。很无语，要不是怕复杂度不太对这个也是看一眼就能写 = = 。。。C题比较难懂，它定义的线段能组成方形实际上跟线段本身的长度没有关系，读了好久才读懂，反正不会做也无所谓了 =。=</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：D、E、E、S、T 做全排列并且按字典序排序，输出第$n$个$(n\leq 60)$。<br>题解：用<code>next_permutation</code>打个表就行啦 <del>虽然CE了两次</del></p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：给出一个 $n\times n$ 四连通的字符地图$(n\leq 50)$，只包含’*‘,’#’两种字符，从’*‘到’#’要消耗1点能量，从’#’到其他也要消耗1点能量。问从$(1,1)$到$(n,n)$至少要消耗多少能量。<br>题解：每个字符与相邻的字符建图，做一次单源最短路。可以用dijkstra+队列优化，时间复杂度$O(2n^2logn+4n^2)$。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：给出$n$个数的序列$(n\leq 20)$，每个数之前可以加正号或者负号，各个数也可以换位置，问最终能有多少不用的结果。<br>题解：显然换位置对于最后答案没有影响，只需要考虑是正是负就可以了。直接dfs，用<code>set</code>去重一下，时间复杂度$O(2^nnlog2)$。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：有一个无穷的字符串序列${a,b,\dots,z,aa,\dots,az,ba,\dots }$，称不含a也不含bc的字符串为beautiful。给出一个串，问这个串之前有多少beautiful的字符串$(|S|\leq 100)$。<br>题目：很明显的数位dp，实际上跟hdu上的<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089" target="_blank" rel="noopener">不要62</a>差不多，不过这个是不能含a，相当于数字不能含0，那么就不能用前导0来补位了。。。刚开始也想怎么改一改模板，好像改了几十分钟都没搞定，最后就直接各种位数都算一遍就行了 =。= 单组时间复杂度$O(26n^2)$，不过根本到不了，多组就更无压力了。</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>题意：求最长回文子串的长度$(|S|&lt;=50)$。<br>题解：枚举中心和中心对暴力，时间复杂度$O(n^2)$。manacher的板子当然更无压力。</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>题意：有$n$条公交路线，问从S到T至少转车几次，如果多个方案输出时间最短的。<br>题解：做过类似的，写起来太麻烦没写，所以数据范围也没记清楚。仍然是建图dijkstra，中间好像要处理一下不太记得了 = = </p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>题意：A和B在$n\times m$的网格图中移动一枚棋子，棋子的初始位置是$(1,1)$，每次只能向右或者向下移动，不能移动者失败。B后手认为游戏不太公平，增加规则，他可以在游戏开始前破坏<strong>至多</strong>一个格子（不能破坏左上角和右下角），游戏中两人不能移动到这个格子。在A最优策略的情况下，问B有没有必胜策略。<br>题解：首先考虑不破坏的情况，显然总共需要$n-1+m-1$步，如果这个数是偶数，那B必胜。再考虑需要破坏的，不妨令$n \lt m$，先填入SG值，$(n,m)$没有后继。</p><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>可以发现，破坏中间的格子是没有用的，始终都有向右向下两个方向，要破坏就破坏底边的格子。当底边某个格子被破坏后，它左边的格子会没有后继变成0，所以破坏当前是1的格子也是没有用的，我们试着破坏$(3,4)$。</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">X</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>可以发现，$(1,1)$的状态确实变了，变成了0，也就是先手必败。再仔细观察，$(1,4),(2,5)$也发生了改变，而且实际上右边还有多少列也没有关系，比如再多两列。</p><table><thead><tr><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">X</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>相当于用X在左边规划了一个正方形，后手一定能把棋子移动到X的左边。那么样例的$(3,4)$为什么不行呢？因为要划一个$3\times 3$的正方形必须要破坏$(3,4)$，然而B不能破坏右下角，所以就不能必胜了。<br>综上，$n+m$是偶数或者$abs(n-m)$是大于1的奇数时有必胜策略。</p><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>题意：$n$个数，大小为$k$的滑动窗口从左往右滑动$(k\leq n\leq 10^7)$，求滑动过程中，最大值的平均数、平均数的最大值、标准差的最小值。<br>题解：求平均数和标准差只要维护一下区间和跟区间平方和就行了，求最大值的话参考<a href="http://poj.org/problem?id=2823" target="_blank" rel="noopener">poj2823</a>，可以用双端队列维护。计算过程可以用<code>long double</code>，<code>scanf</code>和<code>printf</code>要用<code>double</code>。。。</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>题意：环上有$0\dots n-1$这$n$个点$(n\leq 1000000)$，青蛙从$0$开始每一步跳$x$，问有多少$x$使得青蛙能到达所有的点，青蛙可以跳无穷多次。<br>题解：题意即 $ax-bn=c$ 对于 $c&gt;0$ 均有解。由裴蜀定理可以推知 $gcd(x,n)=1$。输出 $\varphi(n)$ 即可，预处理$O(N)$，回答$O(1)$。</p><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>题意：二维平面有$n$个点，以第一个点为起点、终点，每次走直线段去其他的点，直线段不能相交，问最后能围住多大的面积。<br>题解：刚读完的时候以为求个凸包就行了，后来发现规定了起点终点可能走不了凸包。。。然后就没做了，所以题目记得也不是很清楚。<br><img src="http://img.blog.csdn.net/20170604104149087" alt=""></p><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>题意：在$n\times m$的方格中从(1,1)开始顺时针地蛇形填数，输出结果$(n,m\leq 100)$。</p><blockquote><p>输入：<br>3 3<br>1 2 3 4 5 6 7 8 9<br>输出：<br>1 2 3<br>8 9 4<br>7 6 5</p></blockquote><p>题解：好像有个巧妙的方法，实在不行四种情况都判断一下就行，总之就是模拟。</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>没读</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>题意：给一个$n\times m$的矩阵D，再给一个kernel，即$3\times 3$的矩阵K，求D关于K的卷积$(n,m\leq 100)$。<br>题解：这题要是不给卷积的公式还真能难倒很多人。。。实际上就是按公式计算一下$$\large C_{i,j}=\sum_{a=0}^{min(n-i-1,2)}\sum_{b=0}^{min(m-j-1,2)}D_{i+a,j+b}\times K_{a,b}$$时间复杂度$O(3^2nm)$。</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>题意：$n$可以分解成$k$个正整数$(k\leq n\leq 1000)$，即$\sum_{i=1}^{k}a_i=n$，$a_i$递增，对于每种分解，它的值是这些数两两相乘的和，即$\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}a_i*a_j$。求所有分解的和模$p$，保证$p$是一个奇质数。</p><blockquote><p>输入：<br>5 1000000007<br>输出：<br>44<br>输出解释：<br>5=1+1+1+1+1 值为10<br>5=1+1+1+2   值为9<br>5=1+2+2     值为8<br>5=1+1+3     值为7<br>5=2+3       值为6<br>5=1+4       值为4<br>5=5         值为0</p></blockquote><p>题解：$$记S=\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}a_i*a_j$$ $$\because (\sum_{i=1}^{k}a_i)^2=\sum_{i=1}^{k}a_i^2+2S$$ $$\therefore S=\frac{1}{2}(n^2-\sum_{i=1}^{k}a_i^2)$$由于$S$的值很难维护，我们转而去求所有分解中的数的平方和。借用整数划分的记忆化搜索方法，<code>getspilit(n,m)</code>表示要分解$n$，且分解中出现的数都不超过$m$。分为 $m&gt;n$，$m==n$，$m&lt;n$ 三种情况，后两种再分为最终分解中包不包含m，这样不会重复。同时用<code>f[][]</code>记录不同分解数，<code>g[][]</code>记录所有分解的所有数字的平方和，用<code>f[n][n]</code>倍的$n^2$减去<code>g[n][n]</code>，最后再乘以2的逆元就可以了，时间复杂度$O(n^2)$。</p><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>题意：给出$2n$个数，两两一组，使得每组两个数的差的绝对值之和最小，求这个最小的和。<br>题解：由绝对值的性质，排序后两两分组即可。（可以用初中的数形结合全都标到数轴上证明）</p><h3 id="After"><a href="#After" class="headerlink" title="After"></a>After</h3><p>比赛的时候查了不少资料，还复制粘贴了很多模板，结果竟然还是没打过现场赛的人。。。感觉很多知识点虽然知道但是不太熟练。。。继续学习。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;因为题目实在太多了，代码就不贴在博客里了。。。想看代码的童鞋可以去&lt;a href=&quot;https://github.com/S
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://Smlight.github.io/blog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Piece1</title>
    <link href="https://Smlight.github.io/blog/2017/06/04/Piece1/"/>
    <id>https://Smlight.github.io/blog/2017/06/04/Piece1/</id>
    <published>2017-06-04T00:42:04.000Z</published>
    <updated>2018-02-21T12:51:14.205Z</updated>
    
    <content type="html"><![CDATA[<p>三月份以后就一直没有发过博客蓝桥杯那两篇也是因为跟别人承诺过因为蓝桥杯省赛基本上都是水题实在是没啥好写的压轴题做了也没地方能交毫无意义。比完蓝桥杯省赛以后又开始学dp和流做的都是sb题和old题也没啥好写的。五月份每个周末都有比赛：先是江苏省赛又是买的题还跟湘潭赛一样真tm难还好没有完全按照去年的模式准备这场主要的遗憾是有一个写起来很短的前缀和的题目没想到，再是陕西邀请赛这场主要的遗憾是有一个sb题写得太慢了另外一个矩形枚举倒是没开错但是想法也不对，最后是蓝桥杯决赛每次都很无语填空题和大题的跨度实在太大了权当是旅游。<br>其实蓝桥杯决赛前后已经没做题了一直在做软件杯的网站和各种杂事昨天打了金马五校赛和计祘客一下子做了这么多题而且感觉还不错于是决定今天还是要把解题报告发一下然后一打开博客发现都这么久没更新了又有这么多次比赛没总结所以又临时加了这一篇。从它仅有的标点判断我觉得能看完的人一定都是真爱23333333</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;三月份以后就一直没有发过博客蓝桥杯那两篇也是因为跟别人承诺过因为蓝桥杯省赛基本上都是水题实在是没啥好写的压轴题做了也没地方能交毫无意义。比完蓝桥杯省赛以后又开始学dp和流做的都是sb题和old题也没啥好写的。五月份每个周末都有比赛：先是江苏省赛又是买的题还跟湘潭赛一样真tm
      
    
    </summary>
    
    
      <category term="Life" scheme="https://Smlight.github.io/blog/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Django时间时区问题</title>
    <link href="https://Smlight.github.io/blog/2017/05/06/Django%E6%97%B6%E9%97%B4%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
    <id>https://Smlight.github.io/blog/2017/05/06/Django时间时区问题/</id>
    <published>2017-05-05T16:00:00.000Z</published>
    <updated>2018-02-22T10:34:02.776Z</updated>
    
    <content type="html"><![CDATA[<p>唉。。。写篇blog纪念一下浪费了我半个上午时间的问题。。。<br>写的是这么一个代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">while pre<span class="selector-class">.time</span> != now<span class="selector-class">.time</span>:</div></pre></td></tr></table></figure></p><p><code>pre</code>是从数据库取出来的一条记录，<code>now</code>是我准备插入的一条记录，<code>.time</code>是<code>datetimeField</code>，对应程序里就是一个<code>datetime</code>对象。<br>结果这个条件怎么都是真的，也就是说<code>pre.time</code>和<code>now.time</code>总是不相等，我输出了一下发现<code>pre.time</code>是utc时间而且最后会带一个<code>+00:00</code>。<br>想到以前看到过的warning其实很好查到。<code>now.time</code>是一个 <strong>naive</strong> time，而<code>pre.time</code>是一个 aware time，其实就是带不带时区的问题，所以只要让<code>now.time</code>带上时区变成 aware time 就可以了。<br>然后就去查怎么变，其实第一个查到的就是对的。。。只是代码给的不全导致我产生了误解。。。查到的代码是：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">aware_time</span> = naive_time.replace(tzinfo=utc)</div></pre></td></tr></table></figure></p><p>写进去就显示 unresolved reference 我就觉得它很不靠谱，接着就查到了其他的问题。。。</p><ol><li><p>比如一个字符串<code>Sun, 28 Aug 2016 11:42:00 +0200</code>其实最后是带着时区的，那么怎么转换成 aware time呢？方案是：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from datetime import datetime</div><div class="line">date_published = datetime.strptime(date_published, <span class="string">"%a, %d %b %Y %H:%M:%S %z"</span>)</div></pre></td></tr></table></figure><p>看起来很棒棒啊！我就想直接给我的字符串也带上时区：<code>time_str += u&#39; +0800&#39;</code>，然后再用这个方法岂不是美滋滋？<br>结果就是一直 not match 。%z %Z +08:00 utc+8 都试了，甚至还查到了CCT啥的，还是不行。。。<del>SO要给我精神损失费啊TAT</del></p></li><li>attribute ‘tzinfo’ of ‘datetime.datetime’ objects is not writable<br>题主写的是 <code>book.creationTime.tzinfo = EST</code><br>答主说改成 <code>book.creationTime = book.creationTime.replace(tzinfo=EST)</code><br>我一想这人有点傻啊，但是他能用<code>EST</code>我也能用吧，反正加上了时区一切好说，大不了我再加加减减调整一下。。。大概是<code>aware_time = naive_time.replace(tzinfo=EST)</code> 很显然还是不行TAT</li></ol><p>最终解决方案：看这些查到的代码我一直以为既然有tzinfo这个类，应该就会有实现好的类，然而问这些的人可能都<code>import pytz</code>了。。。所以如果不想加上pytz实际上最佳的方案就是<strong>实现一个tzinfo的类</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, tzinfo</div><div class="line"></div><div class="line">ZERO_TIME_DELTA = timedelta(<span class="number">0</span>)</div><div class="line">LOCAL_TIME_DELTA = timedelta(hours=<span class="number">8</span>)  <span class="comment"># 本地时区偏差</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalTimezone</span><span class="params">(tzinfo)</span>:</span></div><div class="line">    <span class="string">"""实现北京时间的类"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">utcoffset</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> LOCAL_TIME_DELTA</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dst</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> ZERO_TIME_DELTA</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tzname</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'+08:00'</span></div><div class="line"></div><div class="line"></div><div class="line">forma = <span class="string">"%Y-%m-%d %H:%M"</span></div><div class="line">now.time = datetime.strptime(time_str, forma).replace(tzinfo=LocalTimezone())</div></pre></td></tr></table></figure></p><p><em>update</em>：实际上<code>import pytz</code>就是最佳的解决方案，这些方法实在是太挫了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;唉。。。写篇blog纪念一下浪费了我半个上午时间的问题。。。&lt;br&gt;写的是这么一个代码：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="Bug" scheme="https://Smlight.github.io/blog/tags/Bug/"/>
    
  </entry>
  
</feed>
